{"version":3,"file":"utils.esm.js","sources":["../../src/presentation/loader/utils.ts"],"sourcesContent":["import {toPlainText} from '@portabletext/react'\nimport {isPortableTextBlock} from '@portabletext/toolkit'\nimport {type ClientPerspective, type QueryParams} from '@sanity/client'\nimport {type ApplySourceDocumentsUpdateFunction} from '@sanity/client/csm'\nimport {useCallback, useEffect, useMemo, useState, useSyncExternalStore} from 'react'\nimport {type FIXME} from 'sanity'\n\n/**\n * Used by `applySourceDocuments`\n * @internal\n */\nexport const mapChangedValue: ApplySourceDocumentsUpdateFunction = (\n  changedValue: FIXME,\n  {previousValue},\n) => {\n  if (typeof previousValue === 'string') {\n    if (typeof changedValue === 'number') {\n      // If the string() function was used in the query, we need to convert the source value to a string as well\n      return `${changedValue}`\n    }\n    // If it's an array in the source, but a string in the query response, it could be pt::text\n    if (Array.isArray(changedValue)) {\n      if (changedValue.length === 0) {\n        // If it's empty assume it's PT and return an empty string\n        return ''\n      }\n      // If the array contains any valid block type, assume the GROQ initially used pt::text on it and do the same conversion\n      if (changedValue.some((node) => typeof node === 'object' && isPortableTextBlock(node))) {\n        return toPlainText(changedValue)\n      }\n    }\n  }\n\n  return changedValue\n}\n\n/**\n * @internal\n */\nexport type QueryCacheKey = `${string}-${string}-${string}`\n/**\n * @internal\n */\nexport function getQueryCacheKey(\n  perspective: ClientPerspective,\n  query: string,\n  params: QueryParams,\n): QueryCacheKey {\n  return `${perspective}-${query}-${JSON.stringify(params)}`\n}\n\n/**\n * Return params that are stable with deep equal as long as the key order is the same\n * @internal\n */\nexport function useQueryParams(params?: undefined | null | QueryParams): QueryParams {\n  const stringifiedParams = useMemo(() => JSON.stringify(params || {}), [params])\n  return useMemo(() => JSON.parse(stringifiedParams) as QueryParams, [stringifiedParams])\n}\n\n/**\n * 'hit' - the cache is fresh and valid\n * 'stale' - the cache should revalidate, but can't/shouldn't yet (offline, visibility = hidden)\n * 'refresh' - stale cache, and now is a great time to start refreshing\n * 'inflight' - refreshing cache, revalidate events should be ignored\n */\nexport type RevalidateState = 'hit' | 'stale' | 'refresh' | 'inflight'\n/**\n * Keeps track of when queries should revalidate\n */\nexport function useRevalidate(props: {\n  /**\n   * How frequently queries should be refetched in the background to refresh the parts of queries that can't be source mapped.\n   * Setting it to `0` will disable background refresh.\n   */\n  refreshInterval: number\n}): [RevalidateState, () => () => void] {\n  const {refreshInterval} = props\n\n  const shouldPause = useShouldPause()\n  const [state, setState] = useState<RevalidateState>('hit')\n\n  // Keep track of indicators for when revalidation should be 'paused'\n  // Like if we're currently offline, or the document isn't visible\n  // Basically if 'stale' and all good we return 'refresh'\n\n  // Next keep track of staleness itself. If we come back online, on a windows focus event\n  // or on a refreshInterval timeout\n  // Basically it controls if cache should be 'hit' or 'stale'\n\n  // How to handle refresh to inflight?\n\n  const startRefresh = useCallback(() => {\n    setState('inflight')\n    return () => setState('hit')\n  }, [])\n\n  // Revalidate on refreshInterval\n  useEffect(() => {\n    // If refreshInterval is nullish then we don't want to refresh.\n    // Inflight means it's already refreshing and we pause the countdown.\n    // It's only necessary to start the countdown if the cache isn't already stale\n    if (!refreshInterval || state !== 'hit') {\n      return undefined\n    }\n    const timeout = setTimeout(() => setState('stale'), refreshInterval)\n    return () => clearTimeout(timeout)\n  }, [refreshInterval, state])\n  // Revalidate on windows focus\n  useEffect(() => {\n    if (state !== 'hit') {\n      return undefined\n    }\n    const onFocus = () => setState('stale')\n    window.addEventListener('focus', onFocus)\n    return () => window.removeEventListener('focus', onFocus)\n  }, [refreshInterval, state])\n  // Revalidate on changes to shouldPause\n  useEffect(() => {\n    // Mark as stale pre-emptively if we're offline or the document isn't visible\n    if (shouldPause && state === 'hit') {\n      setState('stale')\n    }\n    // If not paused we can mark stale as ready for refresh\n    if (!shouldPause && state === 'stale') {\n      setState('refresh')\n    }\n  }, [shouldPause, state])\n\n  return [state, startRefresh]\n}\n\n/**\n * Keeps track of when revalidation and activities should be paused\n */\nfunction useShouldPause(): boolean {\n  const [online, setOnline] = useState(false)\n  useEffect(() => {\n    setOnline(navigator.onLine)\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    const online = () => setOnline(true)\n    const offline = () => setOnline(false)\n    window.addEventListener('online', online)\n    window.addEventListener('offline', offline)\n    return () => {\n      window.removeEventListener('online', online)\n      window.removeEventListener('offline', offline)\n    }\n  }, [])\n  const visibilityState = useSyncExternalStore(\n    onVisibilityChange,\n    () => document.visibilityState,\n    () => 'hidden' satisfies DocumentVisibilityState,\n  )\n\n  // Should pause activity when offline\n  if (!online) {\n    return true\n  }\n\n  // Should pause when the document isn't visible, as it's likely the user isn't looking at the page\n  if (visibilityState === 'hidden') {\n    return true\n  }\n\n  return false\n}\n\nfunction onVisibilityChange(onStoreChange: () => void): () => void {\n  document.addEventListener('visibilitychange', onStoreChange)\n  return () => document.removeEventListener('visibilitychange', onStoreChange)\n}\n"],"names":["mapChangedValue","changedValue","previousValue","Array","isArray","length","some","node","isPortableTextBlock","toPlainText","useQueryParams","params","stringifiedParams","useMemo","JSON","stringify","parse","useRevalidate","props","$","_c","refreshInterval","shouldPause","useShouldPause","state","setState","useState","t0","Symbol","for","startRefresh","t1","t2","timeout","setTimeout","clearTimeout","useEffect","t3","onFocus","addEventListener","window","removeEventListener","t4","t5","t6","t7","online","setOnline","navigator","onLine","offline","visibilityState","useSyncExternalStore","onVisibilityChange","document","onStoreChange"],"mappings":"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"}
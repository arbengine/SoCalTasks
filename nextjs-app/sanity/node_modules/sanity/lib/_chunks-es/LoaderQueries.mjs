import { jsxs, Fragment, jsx } from "react/jsx-runtime";
import { c } from "react-compiler-runtime";
import { applySourceDocuments, getPublishedId } from "@sanity/client/csm";
import { createConnectionMachine } from "@sanity/comlink";
import { createCompatibilityActors } from "@sanity/presentation-comlink";
import { applyPatch } from "mendoza";
import LRUCache from "mnemonist/lru-cache-with-delete";
import { useState, useEffect, useMemo, memo } from "react";
import { useProjectId, useDataset, useClient } from "sanity";
import { MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL, LIVE_QUERY_CACHE_SIZE, LIVE_QUERY_CACHE_BATCH_SIZE } from "./presentation.mjs";
import { useQueryParams, useRevalidate, mapChangedValue } from "./utils.mjs";
function LoaderQueries(props) {
  const {
    liveDocument,
    controller,
    perspective: activePerspective,
    documentsOnPage,
    onLoadersConnection,
    onDocumentsOnPage
  } = props, [comlink, setComlink] = useState(), [liveQueries, setLiveQueries] = useState({}), projectId = useProjectId(), dataset = useDataset();
  useEffect(() => {
    const interval = setInterval(() => (
      // eslint-disable-next-line @typescript-eslint/no-shadow
      setLiveQueries((liveQueries_0) => {
        if (Object.keys(liveQueries_0).length < 1)
          return liveQueries_0;
        const now = Date.now();
        if (!Object.values(liveQueries_0).some(
          // eslint-disable-next-line max-nested-callbacks
          (liveQuery) => liveQuery.heartbeat !== !1 && now > liveQuery.receivedAt + liveQuery.heartbeat
        ))
          return liveQueries_0;
        const next = {};
        for (const [key, value] of Object.entries(liveQueries_0))
          value.heartbeat !== !1 && now > value.receivedAt + value.heartbeat || (next[key] = value);
        return next;
      })
    ), MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL);
    return () => clearInterval(interval);
  }, []), useEffect(() => {
    if (controller) {
      const comlink_0 = controller.createChannel({
        name: "presentation",
        connectTo: "loaders",
        heartbeat: !0
      }, createConnectionMachine().provide({
        actors: createCompatibilityActors()
      }));
      return setComlink(comlink_0), comlink_0.onStatus(onLoadersConnection), comlink_0.on("loader/documents", (data) => {
        data.projectId === projectId && data.dataset === dataset && onDocumentsOnPage(
          "loaders",
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          data.perspective,
          data.documents
        );
      }), comlink_0.on("loader/query-listen", (data_0) => {
        if (data_0.projectId === projectId && data_0.dataset === dataset) {
          if (typeof data_0.heartbeat == "number" && data_0.heartbeat < MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL)
            throw new Error(`Loader query listen heartbeat interval must be at least ${MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL}ms`);
          setLiveQueries((prev) => ({
            ...prev,
            [getQueryCacheKey(data_0.query, data_0.params)]: {
              perspective: data_0.perspective,
              query: data_0.query,
              params: data_0.params,
              receivedAt: Date.now(),
              heartbeat: data_0.heartbeat ?? !1
            }
          }));
        }
      }), comlink_0.start();
    }
  }, [controller, dataset, onDocumentsOnPage, onLoadersConnection, projectId]);
  const [cache] = useState(() => new LRUCache(LIVE_QUERY_CACHE_SIZE)), studioClient = useClient({
    apiVersion: "2023-10-16"
  }), clientConfig = useMemo(() => studioClient.config(), [studioClient]), client = useMemo(() => studioClient.withConfig({
    resultSourceMap: "withKeyArraySelector"
  }), [studioClient]);
  useEffect(() => {
    if (comlink) {
      const {
        projectId: projectId_0,
        dataset: dataset_0
      } = clientConfig;
      comlink.post("loader/perspective", {
        projectId: projectId_0,
        dataset: dataset_0,
        perspective: activePerspective
      });
    }
  }, [comlink, clientConfig, activePerspective]);
  const turboIds = useMemo(() => {
    const documentsActuallyInUse = documentsOnPage.map(({
      _id
    }) => _id), ids = [...new Set(documentsActuallyInUse)], max = cache.capacity;
    return ids.length >= max && (ids.length = max), ids;
  }, [cache.capacity, documentsOnPage]), [documentsCacheLastUpdated, setDocumentsCacheLastUpdated] = useState(0);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(Turbo, { cache, client, turboIds, setDocumentsCacheLastUpdated }),
    Object.entries(liveQueries).map(([key_0, {
      query,
      params,
      perspective
    }]) => /* @__PURE__ */ jsx(QuerySubscription, { cache, projectId: clientConfig.projectId, dataset: clientConfig.dataset, perspective, query, params, comlink, client, refreshInterval: activePerspective ? 2e3 : 0, liveDocument, documentsCacheLastUpdated }, `${key_0}${perspective}`))
  ] });
}
const Turbo = memo(function(props) {
  const {
    cache,
    client,
    turboIds,
    setDocumentsCacheLastUpdated
  } = props, [batch, setBatch] = useState([]);
  return useEffect(() => {
    const batchSet = new Set(batch.flat()), nextBatch = /* @__PURE__ */ new Set();
    for (const turboId of turboIds)
      !batchSet.has(turboId) && !cache.has(turboId) && nextBatch.add(turboId);
    const nextBatchSlice = [...nextBatch].slice(0, LIVE_QUERY_CACHE_BATCH_SIZE);
    if (nextBatchSlice.length === 0) return;
    const raf = requestAnimationFrame(() => (
      // eslint-disable-next-line max-nested-callbacks
      setBatch((prevBatch) => [...prevBatch.slice(-100), nextBatchSlice])
    ));
    return () => cancelAnimationFrame(raf);
  }, [batch, cache, turboIds]), useEffect(() => {
    const subscription = client.listen("*", {}, {
      events: ["mutation"],
      effectFormat: "mendoza",
      includePreviousRevision: !1,
      includeResult: !1,
      tag: "presentation-loader"
    }).subscribe((update) => {
      if (update.type === "mutation" && update.transition === "disappear" && cache.delete(update.documentId) && setDocumentsCacheLastUpdated(Date.now()), update.type !== "mutation" || !update.effects?.apply?.length) return;
      const cachedDocument = cache.peek(update.documentId);
      if (cachedDocument) {
        const patchDoc = {
          ...cachedDocument
        };
        delete patchDoc._rev;
        const patchedDocument = applyPatch(patchDoc, update.effects.apply);
        cache.set(update.documentId, patchedDocument), setDocumentsCacheLastUpdated(Date.now());
      }
    });
    return () => subscription.unsubscribe();
  }, [cache, client, setDocumentsCacheLastUpdated]), /* @__PURE__ */ jsx(Fragment, { children: batch.map((ids) => /* @__PURE__ */ jsx(GetDocuments, { cache, client, ids, setDocumentsCacheLastUpdated }, JSON.stringify(ids))) });
}), GetDocuments = memo(function(props) {
  const {
    client,
    cache,
    ids,
    setDocumentsCacheLastUpdated
  } = props;
  return useEffect(() => {
    const missingIds = ids.filter((id) => !cache.has(id));
    missingIds.length !== 0 && client.getDocuments(missingIds).then((documents) => {
      for (const doc of documents)
        doc && doc?._id && (cache.set(doc._id, doc), setDocumentsCacheLastUpdated(Date.now()));
    }, console.error);
  }, [cache, client, ids, setDocumentsCacheLastUpdated]), null;
});
GetDocuments.displayName = "GetDocuments";
function QuerySubscription(props) {
  const $ = c(20), {
    cache,
    projectId,
    dataset,
    perspective,
    query,
    client,
    refreshInterval,
    liveDocument,
    comlink,
    documentsCacheLastUpdated
  } = props, params = useQueryParams(props.params);
  let t0;
  $[0] !== cache || $[1] !== client || $[2] !== documentsCacheLastUpdated || $[3] !== liveDocument || $[4] !== params || $[5] !== perspective || $[6] !== query || $[7] !== refreshInterval ? (t0 = {
    cache,
    client,
    liveDocument,
    params,
    perspective,
    query,
    refreshInterval,
    documentsCacheLastUpdated
  }, $[0] = cache, $[1] = client, $[2] = documentsCacheLastUpdated, $[3] = liveDocument, $[4] = params, $[5] = perspective, $[6] = query, $[7] = refreshInterval, $[8] = t0) : t0 = $[8];
  const data = useQuerySubscription(t0), result = data?.result, resultSourceMap = data?.resultSourceMap, tags = data?.tags;
  let t1, t2;
  return $[9] !== comlink || $[10] !== dataset || $[11] !== params || $[12] !== perspective || $[13] !== projectId || $[14] !== query || $[15] !== result || $[16] !== resultSourceMap || $[17] !== tags ? (t1 = () => {
    resultSourceMap && comlink?.post("loader/query-change", {
      projectId,
      dataset,
      perspective,
      query,
      params,
      result,
      resultSourceMap,
      tags
    });
  }, t2 = [comlink, dataset, params, perspective, projectId, query, result, resultSourceMap, tags], $[9] = comlink, $[10] = dataset, $[11] = params, $[12] = perspective, $[13] = projectId, $[14] = query, $[15] = result, $[16] = resultSourceMap, $[17] = tags, $[18] = t1, $[19] = t2) : (t1 = $[18], t2 = $[19]), useEffect(t1, t2), null;
}
function useQuerySubscription(props) {
  const {
    cache,
    liveDocument,
    client,
    refreshInterval,
    query,
    params,
    perspective,
    documentsCacheLastUpdated
  } = props, [snapshot, setSnapshot] = useState(null), {
    projectId: projectId_0,
    dataset: dataset_0
  } = useMemo(() => {
    const {
      projectId,
      dataset
    } = client.config();
    return {
      projectId,
      dataset
    };
  }, [client]), [error, setError] = useState(null);
  if (error) throw error;
  const [revalidate, startRefresh] = useRevalidate({
    refreshInterval
  }), shouldRefetch = revalidate === "refresh" || revalidate === "inflight";
  return useEffect(() => {
    if (!shouldRefetch)
      return;
    let fulfilled = !1, fetching = !1;
    const controller = new AbortController();
    async function effect() {
      const {
        signal
      } = controller;
      fetching = !0;
      const {
        result,
        resultSourceMap,
        syncTags
      } = await client.fetch(query, params, {
        tag: "presentation-loader",
        signal,
        perspective,
        filterResponse: !1
      });
      fetching = !1, signal.aborted || (setSnapshot({
        result,
        resultSourceMap,
        tags: syncTags
      }), fulfilled = !0);
    }
    const onFinally = startRefresh();
    return effect().catch((error_0) => {
      fetching = !1, error_0.name !== "AbortError" && setError(error_0);
    }).finally(onFinally), () => {
      !fulfilled && !fetching && controller.abort();
    };
  }, [client, dataset_0, liveDocument, params, perspective, projectId_0, query, shouldRefetch, startRefresh]), useMemo(() => documentsCacheLastUpdated && snapshot?.resultSourceMap ? {
    result: turboChargeResultIfSourceMap(cache, liveDocument, snapshot.result, perspective, snapshot.resultSourceMap),
    resultSourceMap: snapshot.resultSourceMap
  } : snapshot, [cache, documentsCacheLastUpdated, liveDocument, perspective, snapshot]);
}
let warnedAboutCrossDatasetReference = !1;
function turboChargeResultIfSourceMap(cache, liveDocument, result, perspective, resultSourceMap) {
  if (perspective === "raw")
    throw new Error("turboChargeResultIfSourceMap does not support raw perspective");
  return applySourceDocuments(result, resultSourceMap, (sourceDocument) => {
    if (sourceDocument._projectId) {
      warnedAboutCrossDatasetReference || (console.warn("Cross dataset references are not supported yet, ignoring source document", sourceDocument), warnedAboutCrossDatasetReference = !0);
      return;
    }
    return liveDocument?._id && getPublishedId(liveDocument._id) === getPublishedId(sourceDocument._id) ? typeof liveDocument._id == "string" && typeof sourceDocument._type == "string" ? liveDocument : {
      ...liveDocument,
      _id: liveDocument._id || sourceDocument._id,
      _type: liveDocument._type || sourceDocument._type
    } : cache.get(sourceDocument._id);
  }, mapChangedValue, perspective);
}
function getQueryCacheKey(query, params) {
  return `${query}-${typeof params == "string" ? params : JSON.stringify(params)}`;
}
export {
  LoaderQueries as default,
  turboChargeResultIfSourceMap
};
//# sourceMappingURL=LoaderQueries.mjs.map

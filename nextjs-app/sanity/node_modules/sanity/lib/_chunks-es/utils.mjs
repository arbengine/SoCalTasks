import { c } from "react-compiler-runtime";
import { toPlainText } from "@portabletext/react";
import { isPortableTextBlock } from "@portabletext/toolkit";
import { useMemo, useState, useEffect, useSyncExternalStore } from "react";
const mapChangedValue = (changedValue, {
  previousValue
}) => {
  if (typeof previousValue == "string") {
    if (typeof changedValue == "number")
      return `${changedValue}`;
    if (Array.isArray(changedValue)) {
      if (changedValue.length === 0)
        return "";
      if (changedValue.some((node) => typeof node == "object" && isPortableTextBlock(node)))
        return toPlainText(changedValue);
    }
  }
  return changedValue;
};
function useQueryParams(params) {
  const stringifiedParams = useMemo(() => JSON.stringify(params || {}), [params]);
  return useMemo(() => JSON.parse(stringifiedParams), [stringifiedParams]);
}
function useRevalidate(props) {
  const $ = c(16), {
    refreshInterval
  } = props, shouldPause = useShouldPause(), [state, setState] = useState("hit");
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => (setState("inflight"), () => setState("hit")), $[0] = t0) : t0 = $[0];
  const startRefresh = t0;
  let t1, t2;
  $[1] !== refreshInterval || $[2] !== state ? (t1 = () => {
    if (!refreshInterval || state !== "hit")
      return;
    const timeout = setTimeout(() => setState("stale"), refreshInterval);
    return () => clearTimeout(timeout);
  }, t2 = [refreshInterval, state], $[1] = refreshInterval, $[2] = state, $[3] = t1, $[4] = t2) : (t1 = $[3], t2 = $[4]), useEffect(t1, t2);
  let t3;
  $[5] !== state ? (t3 = () => {
    if (state !== "hit")
      return;
    const onFocus = () => setState("stale");
    return window.addEventListener("focus", onFocus), () => window.removeEventListener("focus", onFocus);
  }, $[5] = state, $[6] = t3) : t3 = $[6];
  let t4;
  $[7] !== refreshInterval || $[8] !== state ? (t4 = [refreshInterval, state], $[7] = refreshInterval, $[8] = state, $[9] = t4) : t4 = $[9], useEffect(t3, t4);
  let t5, t6;
  $[10] !== shouldPause || $[11] !== state ? (t5 = () => {
    shouldPause && state === "hit" && setState("stale"), !shouldPause && state === "stale" && setState("refresh");
  }, t6 = [shouldPause, state], $[10] = shouldPause, $[11] = state, $[12] = t5, $[13] = t6) : (t5 = $[12], t6 = $[13]), useEffect(t5, t6);
  let t7;
  return $[14] !== state ? (t7 = [state, startRefresh], $[14] = state, $[15] = t7) : t7 = $[15], t7;
}
function useShouldPause() {
  const [online, setOnline] = useState(!1);
  useEffect(() => {
    setOnline(navigator.onLine);
    const online_0 = () => setOnline(!0), offline = () => setOnline(!1);
    return window.addEventListener("online", online_0), window.addEventListener("offline", offline), () => {
      window.removeEventListener("online", online_0), window.removeEventListener("offline", offline);
    };
  }, []);
  const visibilityState = useSyncExternalStore(onVisibilityChange, () => document.visibilityState, () => "hidden");
  return !online || visibilityState === "hidden";
}
function onVisibilityChange(onStoreChange) {
  return document.addEventListener("visibilitychange", onStoreChange), () => document.removeEventListener("visibilitychange", onStoreChange);
}
export {
  mapChangedValue,
  useQueryParams,
  useRevalidate
};
//# sourceMappingURL=utils.mjs.map

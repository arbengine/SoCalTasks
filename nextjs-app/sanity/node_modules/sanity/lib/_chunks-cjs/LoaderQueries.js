"use strict";
var jsxRuntime = require("react/jsx-runtime"), reactCompilerRuntime = require("react-compiler-runtime"), csm = require("@sanity/client/csm"), comlink = require("@sanity/comlink"), presentationComlink = require("@sanity/presentation-comlink"), mendoza = require("mendoza"), LRUCache = require("mnemonist/lru-cache-with-delete"), React = require("react"), sanity = require("sanity"), presentation = require("./presentation.js"), utils = require("./utils.js");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var LRUCache__default = /* @__PURE__ */ _interopDefaultCompat(LRUCache);
function LoaderQueries(props) {
  const {
    liveDocument,
    controller,
    perspective: activePerspective,
    documentsOnPage,
    onLoadersConnection,
    onDocumentsOnPage
  } = props, [comlink$1, setComlink] = React.useState(), [liveQueries, setLiveQueries] = React.useState({}), projectId = sanity.useProjectId(), dataset = sanity.useDataset();
  React.useEffect(() => {
    const interval = setInterval(() => (
      // eslint-disable-next-line @typescript-eslint/no-shadow
      setLiveQueries((liveQueries_0) => {
        if (Object.keys(liveQueries_0).length < 1)
          return liveQueries_0;
        const now = Date.now();
        if (!Object.values(liveQueries_0).some(
          // eslint-disable-next-line max-nested-callbacks
          (liveQuery) => liveQuery.heartbeat !== !1 && now > liveQuery.receivedAt + liveQuery.heartbeat
        ))
          return liveQueries_0;
        const next = {};
        for (const [key, value] of Object.entries(liveQueries_0))
          value.heartbeat !== !1 && now > value.receivedAt + value.heartbeat || (next[key] = value);
        return next;
      })
    ), presentation.MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL);
    return () => clearInterval(interval);
  }, []), React.useEffect(() => {
    if (controller) {
      const comlink_0 = controller.createChannel({
        name: "presentation",
        connectTo: "loaders",
        heartbeat: !0
      }, comlink.createConnectionMachine().provide({
        actors: presentationComlink.createCompatibilityActors()
      }));
      return setComlink(comlink_0), comlink_0.onStatus(onLoadersConnection), comlink_0.on("loader/documents", (data) => {
        data.projectId === projectId && data.dataset === dataset && onDocumentsOnPage(
          "loaders",
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          data.perspective,
          data.documents
        );
      }), comlink_0.on("loader/query-listen", (data_0) => {
        if (data_0.projectId === projectId && data_0.dataset === dataset) {
          if (typeof data_0.heartbeat == "number" && data_0.heartbeat < presentation.MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL)
            throw new Error(`Loader query listen heartbeat interval must be at least ${presentation.MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL}ms`);
          setLiveQueries((prev) => ({
            ...prev,
            [getQueryCacheKey(data_0.query, data_0.params)]: {
              perspective: data_0.perspective,
              query: data_0.query,
              params: data_0.params,
              receivedAt: Date.now(),
              heartbeat: data_0.heartbeat ?? !1
            }
          }));
        }
      }), comlink_0.start();
    }
  }, [controller, dataset, onDocumentsOnPage, onLoadersConnection, projectId]);
  const [cache] = React.useState(() => new LRUCache__default.default(presentation.LIVE_QUERY_CACHE_SIZE)), studioClient = sanity.useClient({
    apiVersion: "2023-10-16"
  }), clientConfig = React.useMemo(() => studioClient.config(), [studioClient]), client = React.useMemo(() => studioClient.withConfig({
    resultSourceMap: "withKeyArraySelector"
  }), [studioClient]);
  React.useEffect(() => {
    if (comlink$1) {
      const {
        projectId: projectId_0,
        dataset: dataset_0
      } = clientConfig;
      comlink$1.post("loader/perspective", {
        projectId: projectId_0,
        dataset: dataset_0,
        perspective: activePerspective
      });
    }
  }, [comlink$1, clientConfig, activePerspective]);
  const turboIds = React.useMemo(() => {
    const documentsActuallyInUse = documentsOnPage.map(({
      _id
    }) => _id), ids = [...new Set(documentsActuallyInUse)], max = cache.capacity;
    return ids.length >= max && (ids.length = max), ids;
  }, [cache.capacity, documentsOnPage]), [documentsCacheLastUpdated, setDocumentsCacheLastUpdated] = React.useState(0);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(Turbo, { cache, client, turboIds, setDocumentsCacheLastUpdated }),
    Object.entries(liveQueries).map(([key_0, {
      query,
      params,
      perspective
    }]) => /* @__PURE__ */ jsxRuntime.jsx(QuerySubscription, { cache, projectId: clientConfig.projectId, dataset: clientConfig.dataset, perspective, query, params, comlink: comlink$1, client, refreshInterval: activePerspective ? 2e3 : 0, liveDocument, documentsCacheLastUpdated }, `${key_0}${perspective}`))
  ] });
}
const Turbo = React.memo(function(props) {
  const {
    cache,
    client,
    turboIds,
    setDocumentsCacheLastUpdated
  } = props, [batch, setBatch] = React.useState([]);
  return React.useEffect(() => {
    const batchSet = new Set(batch.flat()), nextBatch = /* @__PURE__ */ new Set();
    for (const turboId of turboIds)
      !batchSet.has(turboId) && !cache.has(turboId) && nextBatch.add(turboId);
    const nextBatchSlice = [...nextBatch].slice(0, presentation.LIVE_QUERY_CACHE_BATCH_SIZE);
    if (nextBatchSlice.length === 0) return;
    const raf = requestAnimationFrame(() => (
      // eslint-disable-next-line max-nested-callbacks
      setBatch((prevBatch) => [...prevBatch.slice(-100), nextBatchSlice])
    ));
    return () => cancelAnimationFrame(raf);
  }, [batch, cache, turboIds]), React.useEffect(() => {
    const subscription = client.listen("*", {}, {
      events: ["mutation"],
      effectFormat: "mendoza",
      includePreviousRevision: !1,
      includeResult: !1,
      tag: "presentation-loader"
    }).subscribe((update) => {
      if (update.type === "mutation" && update.transition === "disappear" && cache.delete(update.documentId) && setDocumentsCacheLastUpdated(Date.now()), update.type !== "mutation" || !update.effects?.apply?.length) return;
      const cachedDocument = cache.peek(update.documentId);
      if (cachedDocument) {
        const patchDoc = {
          ...cachedDocument
        };
        delete patchDoc._rev;
        const patchedDocument = mendoza.applyPatch(patchDoc, update.effects.apply);
        cache.set(update.documentId, patchedDocument), setDocumentsCacheLastUpdated(Date.now());
      }
    });
    return () => subscription.unsubscribe();
  }, [cache, client, setDocumentsCacheLastUpdated]), /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: batch.map((ids) => /* @__PURE__ */ jsxRuntime.jsx(GetDocuments, { cache, client, ids, setDocumentsCacheLastUpdated }, JSON.stringify(ids))) });
}), GetDocuments = React.memo(function(props) {
  const {
    client,
    cache,
    ids,
    setDocumentsCacheLastUpdated
  } = props;
  return React.useEffect(() => {
    const missingIds = ids.filter((id) => !cache.has(id));
    missingIds.length !== 0 && client.getDocuments(missingIds).then((documents) => {
      for (const doc of documents)
        doc && doc?._id && (cache.set(doc._id, doc), setDocumentsCacheLastUpdated(Date.now()));
    }, console.error);
  }, [cache, client, ids, setDocumentsCacheLastUpdated]), null;
});
GetDocuments.displayName = "GetDocuments";
function QuerySubscription(props) {
  const $ = reactCompilerRuntime.c(20), {
    cache,
    projectId,
    dataset,
    perspective,
    query,
    client,
    refreshInterval,
    liveDocument,
    comlink: comlink2,
    documentsCacheLastUpdated
  } = props, params = utils.useQueryParams(props.params);
  let t0;
  $[0] !== cache || $[1] !== client || $[2] !== documentsCacheLastUpdated || $[3] !== liveDocument || $[4] !== params || $[5] !== perspective || $[6] !== query || $[7] !== refreshInterval ? (t0 = {
    cache,
    client,
    liveDocument,
    params,
    perspective,
    query,
    refreshInterval,
    documentsCacheLastUpdated
  }, $[0] = cache, $[1] = client, $[2] = documentsCacheLastUpdated, $[3] = liveDocument, $[4] = params, $[5] = perspective, $[6] = query, $[7] = refreshInterval, $[8] = t0) : t0 = $[8];
  const data = useQuerySubscription(t0), result = data?.result, resultSourceMap = data?.resultSourceMap, tags = data?.tags;
  let t1, t2;
  return $[9] !== comlink2 || $[10] !== dataset || $[11] !== params || $[12] !== perspective || $[13] !== projectId || $[14] !== query || $[15] !== result || $[16] !== resultSourceMap || $[17] !== tags ? (t1 = () => {
    resultSourceMap && comlink2?.post("loader/query-change", {
      projectId,
      dataset,
      perspective,
      query,
      params,
      result,
      resultSourceMap,
      tags
    });
  }, t2 = [comlink2, dataset, params, perspective, projectId, query, result, resultSourceMap, tags], $[9] = comlink2, $[10] = dataset, $[11] = params, $[12] = perspective, $[13] = projectId, $[14] = query, $[15] = result, $[16] = resultSourceMap, $[17] = tags, $[18] = t1, $[19] = t2) : (t1 = $[18], t2 = $[19]), React.useEffect(t1, t2), null;
}
function useQuerySubscription(props) {
  const {
    cache,
    liveDocument,
    client,
    refreshInterval,
    query,
    params,
    perspective,
    documentsCacheLastUpdated
  } = props, [snapshot, setSnapshot] = React.useState(null), {
    projectId: projectId_0,
    dataset: dataset_0
  } = React.useMemo(() => {
    const {
      projectId,
      dataset
    } = client.config();
    return {
      projectId,
      dataset
    };
  }, [client]), [error, setError] = React.useState(null);
  if (error) throw error;
  const [revalidate, startRefresh] = utils.useRevalidate({
    refreshInterval
  }), shouldRefetch = revalidate === "refresh" || revalidate === "inflight";
  return React.useEffect(() => {
    if (!shouldRefetch)
      return;
    let fulfilled = !1, fetching = !1;
    const controller = new AbortController();
    async function effect() {
      const {
        signal
      } = controller;
      fetching = !0;
      const {
        result,
        resultSourceMap,
        syncTags
      } = await client.fetch(query, params, {
        tag: "presentation-loader",
        signal,
        perspective,
        filterResponse: !1
      });
      fetching = !1, signal.aborted || (setSnapshot({
        result,
        resultSourceMap,
        tags: syncTags
      }), fulfilled = !0);
    }
    const onFinally = startRefresh();
    return effect().catch((error_0) => {
      fetching = !1, error_0.name !== "AbortError" && setError(error_0);
    }).finally(onFinally), () => {
      !fulfilled && !fetching && controller.abort();
    };
  }, [client, dataset_0, liveDocument, params, perspective, projectId_0, query, shouldRefetch, startRefresh]), React.useMemo(() => documentsCacheLastUpdated && snapshot?.resultSourceMap ? {
    result: turboChargeResultIfSourceMap(cache, liveDocument, snapshot.result, perspective, snapshot.resultSourceMap),
    resultSourceMap: snapshot.resultSourceMap
  } : snapshot, [cache, documentsCacheLastUpdated, liveDocument, perspective, snapshot]);
}
let warnedAboutCrossDatasetReference = !1;
function turboChargeResultIfSourceMap(cache, liveDocument, result, perspective, resultSourceMap) {
  if (perspective === "raw")
    throw new Error("turboChargeResultIfSourceMap does not support raw perspective");
  return csm.applySourceDocuments(result, resultSourceMap, (sourceDocument) => {
    if (sourceDocument._projectId) {
      warnedAboutCrossDatasetReference || (console.warn("Cross dataset references are not supported yet, ignoring source document", sourceDocument), warnedAboutCrossDatasetReference = !0);
      return;
    }
    return liveDocument?._id && csm.getPublishedId(liveDocument._id) === csm.getPublishedId(sourceDocument._id) ? typeof liveDocument._id == "string" && typeof sourceDocument._type == "string" ? liveDocument : {
      ...liveDocument,
      _id: liveDocument._id || sourceDocument._id,
      _type: liveDocument._type || sourceDocument._type
    } : cache.get(sourceDocument._id);
  }, utils.mapChangedValue, perspective);
}
function getQueryCacheKey(query, params) {
  return `${query}-${typeof params == "string" ? params : JSON.stringify(params)}`;
}
exports.default = LoaderQueries;
exports.turboChargeResultIfSourceMap = turboChargeResultIfSourceMap;
//# sourceMappingURL=LoaderQueries.js.map

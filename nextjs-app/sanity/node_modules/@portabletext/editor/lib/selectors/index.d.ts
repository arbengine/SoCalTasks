import type {
  ArraySchemaType,
  BlockDecoratorDefinition,
  BlockListDefinition,
  BlockStyleDefinition,
  ObjectSchemaType,
  Path,
} from '@sanity/types'
import {
  KeyedSegment,
  PortableTextBlock,
  PortableTextListBlock,
  PortableTextObject,
  PortableTextSpan,
  PortableTextTextBlock,
} from '@sanity/types'

declare type Converter<TMIMEType extends MIMEType = MIMEType> = {
  mimeType: TMIMEType
  serialize: Serializer<TMIMEType>
  deserialize: Deserializer<TMIMEType>
}

declare type ConverterEvent<TMIMEType extends MIMEType = MIMEType> =
  | {
      type: 'serialize'
      originEvent: 'copy' | 'cut' | 'unknown'
    }
  | {
      type: 'serialization.failure'
      mimeType: TMIMEType
      reason: string
    }
  | {
      type: 'serialization.success'
      data: string
      mimeType: TMIMEType
      originEvent: 'copy' | 'cut' | 'unknown'
    }
  | {
      type: 'deserialize'
      data: string
    }
  | {
      type: 'deserialization.failure'
      mimeType: TMIMEType
      reason: string
    }
  | {
      type: 'deserialization.success'
      data: Array<PortableTextBlock>
      mimeType: TMIMEType
    }

declare type Deserializer<TMIMEType extends MIMEType> = ({
  context,
  event,
}: {
  context: EditorContext
  event: PickFromUnion<ConverterEvent<TMIMEType>, 'type', 'deserialize'>
}) => PickFromUnion<
  ConverterEvent<TMIMEType>,
  'type',
  'deserialization.success' | 'deserialization.failure'
>

/**
 * @public
 */
export declare type EditorContext = {
  activeDecorators: Array<string>
  converters: Array<Converter>
  keyGenerator: () => string
  schema: EditorSchema
  selection: EditorSelection
  value: Array<PortableTextBlock>
}

/**
 * @public
 */
export declare type EditorSchema = PortableTextMemberSchemaTypes

/** @public */
export declare type EditorSelection = {
  anchor: EditorSelectionPoint
  focus: EditorSelectionPoint
  backward?: boolean
} | null

/** @public */
export declare type EditorSelectionPoint = {
  path: Path
  offset: number
}

/**
 * @public
 */
export declare type EditorSelector<TSelected> = (
  snapshot: EditorSnapshot,
) => TSelected

/**
 * @public
 */
export declare type EditorSnapshot = {
  context: EditorContext
}

/**
 * @public
 */
export declare const getActiveListItem: EditorSelector<
  PortableTextListBlock['listItem'] | undefined
>

/**
 * @public
 */
export declare const getActiveStyle: EditorSelector<
  PortableTextTextBlock['style']
>

/**
 * @public
 */
export declare const getBlockTextBefore: EditorSelector<string>

/**
 * @public
 */
export declare const getFirstBlock: EditorSelector<
  | {
      node: PortableTextBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getFocusBlock: EditorSelector<
  | {
      node: PortableTextBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getFocusBlockObject: EditorSelector<
  | {
      node: PortableTextObject
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getFocusChild: EditorSelector<
  | {
      node: PortableTextObject | PortableTextSpan
      path: [KeyedSegment, 'children', KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getFocusListBlock: EditorSelector<
  | {
      node: PortableTextListBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getFocusSpan: EditorSelector<
  | {
      node: PortableTextSpan
      path: [KeyedSegment, 'children', KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getFocusTextBlock: EditorSelector<
  | {
      node: PortableTextTextBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getLastBlock: EditorSelector<
  | {
      node: PortableTextBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getNextBlock: EditorSelector<
  | {
      node: PortableTextBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getPreviousBlock: EditorSelector<
  | {
      node: PortableTextBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getSelectedBlocks: EditorSelector<
  Array<{
    node: PortableTextBlock
    path: [KeyedSegment]
  }>
>

/**
 * @public
 */
export declare const getSelectedSlice: EditorSelector<Array<PortableTextBlock>>

/**
 * @public
 */
export declare const getSelectedSpans: EditorSelector<
  Array<{
    node: PortableTextSpan
    path: [KeyedSegment, 'children', KeyedSegment]
  }>
>

/**
 * @public
 */
export declare const getSelectionEndBlock: EditorSelector<
  | {
      node: PortableTextBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getSelectionStartBlock: EditorSelector<
  | {
      node: PortableTextBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getSelectionText: EditorSelector<string>

/**
 * @public
 */
export declare function isActiveAnnotation(
  annotation: string,
): EditorSelector<boolean>

/**
 * @public
 */
export declare function isActiveDecorator(
  decorator: string,
): EditorSelector<boolean>

/**
 * @public
 */
export declare function isActiveListItem(
  listItem: string,
): EditorSelector<boolean>

/**
 * @public
 */
export declare function isActiveStyle(style: string): EditorSelector<boolean>

/**
 * @public
 */
export declare function isAtTheEndOfBlock(block: {
  node: PortableTextBlock
  path: [KeyedSegment]
}): EditorSelector<boolean>

/**
 * @public
 */
export declare function isAtTheStartOfBlock(block: {
  node: PortableTextBlock
  path: [KeyedSegment]
}): EditorSelector<boolean>

/**
 * @public
 */
export declare function isPointAfterSelection(
  point: EditorSelectionPoint,
): EditorSelector<boolean>

/**
 * @public
 */
export declare function isPointBeforeSelection(
  point: EditorSelectionPoint,
): EditorSelector<boolean>

/**
 * @public
 */
export declare const isSelectionCollapsed: EditorSelector<boolean>

/**
 * @public
 */
export declare const isSelectionExpanded: EditorSelector<boolean>

declare type MIMEType = `${string}/${string}`

/**
 * @internal
 */
declare type PickFromUnion<
  TUnion,
  TTagKey extends keyof TUnion,
  TPickedTags extends TUnion[TTagKey],
> = TUnion extends Record<TTagKey, TPickedTags> ? TUnion : never

/** @internal */
export declare type PortableTextMemberSchemaTypes = {
  annotations: (ObjectSchemaType & {
    i18nTitleKey?: string
  })[]
  block: ObjectSchemaType
  blockObjects: ObjectSchemaType[]
  decorators: BlockDecoratorDefinition[]
  inlineObjects: ObjectSchemaType[]
  portableText: ArraySchemaType<PortableTextBlock>
  span: ObjectSchemaType
  styles: BlockStyleDefinition[]
  lists: BlockListDefinition[]
}

declare type Serializer<TMIMEType extends MIMEType> = ({
  context,
  event,
}: {
  context: EditorContext
  event: PickFromUnion<ConverterEvent<TMIMEType>, 'type', 'serialize'>
}) => PickFromUnion<
  ConverterEvent<TMIMEType>,
  'type',
  'serialization.success' | 'serialization.failure'
>

export {}

{"version":3,"file":"index.cjs","sources":["../../src/selectors/selector.get-selected-slice.ts","../../src/selectors/selector.is-point-after-selection.ts","../../src/selectors/selector.is-point-before-selection.ts"],"sourcesContent":["import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {sliceBlocks} from '../utils'\n\n/**\n * @public\n */\nexport const getSelectedSlice: EditorSelector<Array<PortableTextBlock>> = ({\n  context,\n}) => {\n  return sliceBlocks({blocks: context.value, selection: context.selection})\n}\n","import {isKeySegment, isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {reverseSelection} from '../utils/util.reverse-selection'\n\n/**\n * @public\n */\nexport function isPointAfterSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const selection = reverseSelection(snapshot.context.selection)\n\n    const pointBlockKey = isKeySegment(point.path[0])\n      ? point.path[0]._key\n      : undefined\n    const pointChildKey = isKeySegment(point.path[2])\n      ? point.path[2]._key\n      : undefined\n\n    const endBlockKey = isKeySegment(selection.focus.path[0])\n      ? selection.focus.path[0]._key\n      : undefined\n    const endChildKey = isKeySegment(selection.focus.path[2])\n      ? selection.focus.path[2]._key\n      : undefined\n\n    if (!pointBlockKey || !endBlockKey) {\n      return false\n    }\n\n    let after = false\n\n    for (const block of snapshot.context.value) {\n      if (block._key === endBlockKey) {\n        if (block._key !== pointBlockKey) {\n          after = true\n          break\n        }\n\n        // Both the point and the selection end in this block\n\n        if (!isPortableTextTextBlock(block)) {\n          break\n        }\n\n        if (!pointChildKey || !endChildKey) {\n          break\n        }\n\n        for (const child of block.children) {\n          if (child._key === endChildKey) {\n            if (child._key !== pointChildKey) {\n              after = true\n              break\n            }\n\n            // Both the point and the selection end in this child\n\n            after = point.offset > selection.focus.offset\n            break\n          }\n\n          if (child._key === pointChildKey) {\n            break\n          }\n        }\n      }\n\n      if (block._key === pointBlockKey) {\n        break\n      }\n    }\n\n    return after\n  }\n}\n","import {isKeySegment, isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {reverseSelection} from '../utils/util.reverse-selection'\n\n/**\n * @public\n */\nexport function isPointBeforeSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const selection = reverseSelection(snapshot.context.selection)\n\n    const pointBlockKey = isKeySegment(point.path[0])\n      ? point.path[0]._key\n      : undefined\n    const pointChildKey = isKeySegment(point.path[2])\n      ? point.path[2]._key\n      : undefined\n\n    const startBlockKey = isKeySegment(selection.anchor.path[0])\n      ? selection.anchor.path[0]._key\n      : undefined\n    const startChildKey = isKeySegment(selection.anchor.path[2])\n      ? selection.anchor.path[2]._key\n      : undefined\n\n    if (!pointBlockKey || !startBlockKey) {\n      return false\n    }\n\n    let before = false\n\n    for (const block of snapshot.context.value) {\n      if (block._key === pointBlockKey) {\n        if (block._key !== startBlockKey) {\n          before = true\n          break\n        }\n\n        // Both the point and the selection start in this block\n\n        if (!isPortableTextTextBlock(block)) {\n          break\n        }\n\n        if (!pointChildKey || !startChildKey) {\n          break\n        }\n\n        for (const child of block.children) {\n          if (child._key === pointChildKey) {\n            if (child._key !== startChildKey) {\n              before = true\n              break\n            }\n\n            // Both the point and the selection start in this child\n\n            before = point.offset < selection.anchor.offset\n            break\n          }\n\n          if (child._key === startChildKey) {\n            break\n          }\n        }\n      }\n\n      if (block._key === startBlockKey) {\n        break\n      }\n    }\n\n    return before\n  }\n}\n"],"names":["getSelectedSlice","context","sliceBlocks","blocks","value","selection","isPointAfterSelection","point","snapshot","reverseSelection","pointBlockKey","isKeySegment","path","_key","undefined","pointChildKey","endBlockKey","focus","endChildKey","after","block","isPortableTextTextBlock","child","children","offset","isPointBeforeSelection","startBlockKey","anchor","startChildKey","before"],"mappings":"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"}
{"version":3,"file":"selector.is-at-the-start-of-block.cjs","sources":["../../src/behavior-actions/behavior.guards.ts","../../src/selectors/selectors.ts","../../src/selectors/selector.get-active-list-item.ts","../../src/selectors/selector.get-active-style.ts","../../src/selectors/selector.get-selected-spans.ts","../../src/selectors/selector.is-active-annotation.ts","../../src/selectors/selector.is-selection-collapsed.ts","../../src/selectors/selector.is-selection-expanded.ts","../../src/selectors/selector.is-active-decorator.ts","../../src/selectors/selector.is-active-list-item.ts","../../src/selectors/selector.is-active-style.ts","../../src/selectors/selector.is-at-the-end-of-block.ts","../../src/selectors/selector.is-at-the-start-of-block.ts"],"sourcesContent":["import {\n  isPortableTextListBlock,\n  isPortableTextTextBlock,\n  type PortableTextListBlock,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport type {EditorSchema} from '../editor/define-schema'\n\n/**\n * @alpha\n */\nexport type BehaviorGuards = ReturnType<typeof createGuards>\n\nexport function createGuards({schema}: {schema: EditorSchema}) {\n  function isListBlock(block: unknown): block is PortableTextListBlock {\n    return isPortableTextListBlock(block) && block._type === schema.block.name\n  }\n\n  function isTextBlock(block: unknown): block is PortableTextTextBlock {\n    return isPortableTextTextBlock(block) && block._type === schema.block.name\n  }\n\n  return {isListBlock, isTextBlock}\n}\n","import {\n  isKeySegment,\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextBlock,\n  type PortableTextListBlock,\n  type PortableTextObject,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport {createGuards} from '../behavior-actions/behavior.guards'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getFocusBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const key = context.selection\n    ? isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusListBlock: EditorSelector<\n  {node: PortableTextListBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const guards = createGuards(context)\n  const focusBlock = getFocusBlock({context})\n\n  return focusBlock && guards.isListBlock(focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusTextBlock: EditorSelector<\n  {node: PortableTextTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const focusBlock = getFocusBlock({context})\n\n  return focusBlock && isPortableTextTextBlock(focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusBlockObject: EditorSelector<\n  {node: PortableTextObject; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const focusBlock = getFocusBlock({context})\n\n  return focusBlock && !isPortableTextTextBlock(focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusChild: EditorSelector<\n  | {\n      node: PortableTextObject | PortableTextSpan\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  const focusBlock = getFocusTextBlock({context})\n\n  if (!focusBlock) {\n    return undefined\n  }\n\n  const key = context.selection\n    ? isKeySegment(context.selection.focus.path[2])\n      ? context.selection.focus.path[2]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? focusBlock.node.children.find((span) => span._key === key)\n    : undefined\n\n  return node && key\n    ? {node, path: [...focusBlock.path, 'children', {_key: key}]}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusSpan: EditorSelector<\n  | {node: PortableTextSpan; path: [KeyedSegment, 'children', KeyedSegment]}\n  | undefined\n> = ({context}) => {\n  const focusChild = getFocusChild({context})\n\n  return focusChild && isPortableTextSpan(focusChild.node)\n    ? {node: focusChild.node, path: focusChild.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFirstBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const node = context.value[0]\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getLastBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const node = context.value[context.value.length - 1]\n    ? context.value[context.value.length - 1]\n    : undefined\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getSelectedBlocks: EditorSelector<\n  Array<{node: PortableTextBlock; path: [KeyedSegment]}>\n> = ({context}) => {\n  if (!context.selection) {\n    return []\n  }\n\n  const selectedBlocks: Array<{node: PortableTextBlock; path: [KeyedSegment]}> =\n    []\n  const startKey = context.selection.backward\n    ? isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n  const endKey = context.selection.backward\n    ? isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n\n  if (!startKey || !endKey) {\n    return selectedBlocks\n  }\n\n  for (const block of context.value) {\n    if (block._key === startKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n\n      if (startKey === endKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n      break\n    }\n\n    if (selectedBlocks.length > 0) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n    }\n  }\n\n  return selectedBlocks\n}\n\n/**\n * @public\n */\nexport const getSelectionStartBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: [KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  const key = context.selection.backward\n    ? isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n\n  const node = key\n    ? context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getSelectionEndBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: [KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  const key = context.selection.backward\n    ? isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n\n  const node = key\n    ? context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getPreviousBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  let previousBlock: {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n  const selectionStartBlock = getSelectionStartBlock({context})\n\n  if (!selectionStartBlock) {\n    return undefined\n  }\n\n  let foundSelectionStartBlock = false\n\n  for (const block of context.value) {\n    if (block._key === selectionStartBlock.node._key) {\n      foundSelectionStartBlock = true\n      break\n    }\n\n    previousBlock = {node: block, path: [{_key: block._key}]}\n  }\n\n  if (foundSelectionStartBlock && previousBlock) {\n    return previousBlock\n  }\n\n  return undefined\n}\n\n/**\n * @public\n */\nexport const getNextBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  let nextBlock: {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n  const selectionEndBlock = getSelectionEndBlock({context})\n\n  if (!selectionEndBlock) {\n    return undefined\n  }\n\n  let foundSelectionEndBlock = false\n\n  for (const block of context.value) {\n    if (block._key === selectionEndBlock.node._key) {\n      foundSelectionEndBlock = true\n      continue\n    }\n\n    if (foundSelectionEndBlock) {\n      nextBlock = {node: block, path: [{_key: block._key}]}\n      break\n    }\n  }\n\n  if (foundSelectionEndBlock && nextBlock) {\n    return nextBlock\n  }\n\n  return undefined\n}\n","import type {PortableTextListBlock} from '@sanity/types'\nimport {createGuards} from '../behavior-actions/behavior.guards'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport const getActiveListItem: EditorSelector<\n  PortableTextListBlock['listItem'] | undefined\n> = ({context}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  const guards = createGuards(context)\n  const selectedBlocks = getSelectedBlocks({context}).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter(guards.isTextBlock)\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstListItem = firstTextBlock.listItem\n\n  if (!firstListItem) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.listItem === firstListItem)) {\n    return firstListItem\n  }\n\n  return undefined\n}\n","import type {PortableTextTextBlock} from '@sanity/types'\nimport {createGuards} from '../behavior-actions/behavior.guards'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport const getActiveStyle: EditorSelector<PortableTextTextBlock['style']> = ({\n  context,\n}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  const guards = createGuards(context)\n  const selectedBlocks = getSelectedBlocks({context}).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter(guards.isTextBlock)\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstStyle = firstTextBlock.style\n\n  if (!firstStyle) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.style === firstStyle)) {\n    return firstStyle\n  }\n\n  return undefined\n}\n","import {\n  isKeySegment,\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextSpan,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getSelectedSpans: EditorSelector<\n  Array<{\n    node: PortableTextSpan\n    path: [KeyedSegment, 'children', KeyedSegment]\n  }>\n> = ({context}) => {\n  if (!context.selection) {\n    return []\n  }\n\n  const selectedSpans: Array<{\n    node: PortableTextSpan\n    path: [KeyedSegment, 'children', KeyedSegment]\n  }> = []\n\n  const startPoint = context.selection.backward\n    ? context.selection.focus\n    : context.selection.anchor\n  const endPoint = context.selection.backward\n    ? context.selection.anchor\n    : context.selection.focus\n\n  const startBlockKey = isKeySegment(startPoint.path[0])\n    ? startPoint.path[0]._key\n    : undefined\n  const endBlockKey = isKeySegment(endPoint.path[0])\n    ? endPoint.path[0]._key\n    : undefined\n\n  if (!startBlockKey || !endBlockKey) {\n    return selectedSpans\n  }\n\n  const startSpanKey = isKeySegment(startPoint.path[2])\n    ? startPoint.path[2]._key\n    : undefined\n  const endSpanKey = isKeySegment(endPoint.path[2])\n    ? endPoint.path[2]._key\n    : undefined\n\n  for (const block of context.value) {\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    if (block._key === startBlockKey) {\n      for (const child of block.children) {\n        if (!isPortableTextSpan(child)) {\n          continue\n        }\n\n        if (startSpanKey && child._key === startSpanKey) {\n          selectedSpans.push({\n            node: child,\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n          })\n\n          if (startSpanKey === endSpanKey) {\n            break\n          }\n\n          continue\n        }\n\n        if (endSpanKey && child._key === endSpanKey) {\n          selectedSpans.push({\n            node: child,\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n          })\n          break\n        }\n\n        if (selectedSpans.length > 0) {\n          selectedSpans.push({\n            node: child,\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n          })\n        }\n      }\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n\n      continue\n    }\n\n    if (block._key === endBlockKey) {\n      for (const child of block.children) {\n        if (!isPortableTextSpan(child)) {\n          continue\n        }\n\n        if (endSpanKey && child._key === endSpanKey) {\n          selectedSpans.push({\n            node: child,\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n          })\n          break\n        }\n\n        selectedSpans.push({\n          node: child,\n          path: [{_key: block._key}, 'children', {_key: child._key}],\n        })\n      }\n\n      break\n    }\n\n    if (selectedSpans.length > 0) {\n      for (const child of block.children) {\n        if (!isPortableTextSpan(child)) {\n          continue\n        }\n\n        selectedSpans.push({\n          node: child,\n          path: [{_key: block._key}, 'children', {_key: child._key}],\n        })\n      }\n    }\n  }\n\n  return selectedSpans\n}\n","import {isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport function isActiveAnnotation(\n  annotation: string,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const selectedBlocks = getSelectedBlocks(snapshot)\n    const selectedSpans = getSelectedSpans(snapshot)\n\n    if (selectedSpans.length === 0) {\n      return false\n    }\n\n    if (\n      selectedSpans.some(\n        (span) => !span.node.marks || span.node.marks?.length === 0,\n      )\n    ) {\n      return false\n    }\n\n    const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n      isPortableTextTextBlock(block.node) ? (block.node.markDefs ?? []) : [],\n    )\n\n    return selectedSpans.every((span) => {\n      const spanMarkDefs =\n        span.node.marks?.flatMap((mark) => {\n          const markDef = selectionMarkDefs.find(\n            (markDef) => markDef._key === mark,\n          )\n\n          return markDef ? [markDef._type] : []\n        }) ?? []\n\n      return spanMarkDefs.includes(annotation)\n    })\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const isSelectionCollapsed: EditorSelector<boolean> = ({context}) => {\n  if (!context.selection) {\n    return false\n  }\n\n  return (\n    JSON.stringify(context.selection.anchor.path) ===\n      JSON.stringify(context.selection.focus.path) &&\n    context.selection?.anchor.offset === context.selection?.focus.offset\n  )\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport const isSelectionExpanded: EditorSelector<boolean> = ({context}) => {\n  return !isSelectionCollapsed({context})\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\n\n/**\n * @public\n */\nexport function isActiveDecorator(decorator: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (isSelectionExpanded(snapshot)) {\n      const selectedSpans = getSelectedSpans(snapshot)\n\n      return (\n        selectedSpans.length > 0 &&\n        selectedSpans.every((span) => span.node.marks?.includes(decorator))\n      )\n    }\n\n    return snapshot.context.activeDecorators.includes(decorator)\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveListItem} from './selector.get-active-list-item'\n\n/**\n * @public\n */\nexport function isActiveListItem(listItem: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeListItem = getActiveListItem(snapshot)\n\n    return activeListItem === listItem\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveStyle} from './selector.get-active-style'\n\n/**\n * @public\n */\nexport function isActiveStyle(style: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeStyle = getActiveStyle(snapshot)\n\n    return activeStyle === style\n  }\n}\n","import type {KeyedSegment, PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport * as utils from '../utils'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheEndOfBlock(block: {\n  node: PortableTextBlock\n  path: [KeyedSegment]\n}): EditorSelector<boolean> {\n  return ({context}) => {\n    if (!context.selection || !isSelectionCollapsed({context})) {\n      return false\n    }\n\n    const blockEndPoint = utils.getBlockEndPoint(block)\n\n    return utils.isEqualSelectionPoints(context.selection.focus, blockEndPoint)\n  }\n}\n","import type {KeyedSegment, PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport * as utils from '../utils'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheStartOfBlock(block: {\n  node: PortableTextBlock\n  path: [KeyedSegment]\n}): EditorSelector<boolean> {\n  return ({context}) => {\n    if (!context.selection || !isSelectionCollapsed({context})) {\n      return false\n    }\n\n    const blockStartPoint = utils.getBlockStartPoint(block)\n\n    return utils.isEqualSelectionPoints(\n      context.selection.focus,\n      blockStartPoint,\n    )\n  }\n}\n"],"names":["createGuards","schema","isListBlock","block","isPortableTextListBlock","_type","name","isTextBlock","isPortableTextTextBlock","getFocusBlock","context","key","selection","isKeySegment","focus","path","_key","undefined","node","value","find","getFocusListBlock","guards","focusBlock","getFocusTextBlock","getFocusBlockObject","getFocusChild","children","span","getFocusSpan","focusChild","isPortableTextSpan","getFirstBlock","getLastBlock","length","getSelectedBlocks","selectedBlocks","startKey","backward","anchor","endKey","push","getSelectionStartBlock","getSelectionEndBlock","getPreviousBlock","previousBlock","selectionStartBlock","foundSelectionStartBlock","getNextBlock","nextBlock","selectionEndBlock","foundSelectionEndBlock","getActiveListItem","selectedTextBlocks","map","filter","firstTextBlock","at","firstListItem","listItem","every","getActiveStyle","firstStyle","style","getSelectedSpans","selectedSpans","startPoint","endPoint","startBlockKey","endBlockKey","startSpanKey","endSpanKey","child","isActiveAnnotation","annotation","snapshot","some","marks","selectionMarkDefs","flatMap","markDefs","mark","markDef","includes","isSelectionCollapsed","JSON","stringify","offset","isSelectionExpanded","isActiveDecorator","decorator","activeDecorators","isActiveListItem","isActiveStyle","isAtTheEndOfBlock","blockEndPoint","utils","getBlockEndPoint","isEqualSelectionPoints","isAtTheStartOfBlock","blockStartPoint","getBlockStartPoint"],"mappings":";;AAaO,SAASA,aAAa;AAAA,EAACC;AAA8B,GAAG;AAC7D,WAASC,YAAYC,OAAgD;AACnE,WAAOC,MAAAA,wBAAwBD,KAAK,KAAKA,MAAME,UAAUJ,OAAOE,MAAMG;AAAAA,EAAAA;AAGxE,WAASC,YAAYJ,OAAgD;AACnE,WAAOK,MAAAA,wBAAwBL,KAAK,KAAKA,MAAME,UAAUJ,OAAOE,MAAMG;AAAAA,EAAAA;AAGjE,SAAA;AAAA,IAACJ;AAAAA,IAAaK;AAAAA,EAAW;AAClC;ACNO,MAAME,gBAETA,CAAC;AAAA,EAACC;AAAO,MAAM;AACjB,QAAMC,MAAMD,QAAQE,aAChBC,MAAAA,aAAaH,QAAQE,UAAUE,MAAMC,KAAK,CAAC,CAAC,IAC1CL,QAAQE,UAAUE,MAAMC,KAAK,CAAC,EAAEC,OAElCC,QAEEC,OAAOP,MACTD,QAAQS,MAAMC,KAAMjB,CAAUA,UAAAA,MAAMa,SAASL,GAAG,IAChDM;AAEJ,SAAOC,QAAQP,MAAM;AAAA,IAACO;AAAAA,IAAMH,MAAM,CAAC;AAAA,MAACC,MAAML;AAAAA,IAAI,CAAA;AAAA,EAAA,IAAKM;AACrD,GAKaI,oBAETA,CAAC;AAAA,EAACX;AAAO,MAAM;AACjB,QAAMY,SAAStB,aAAaU,OAAO,GAC7Ba,aAAad,cAAc;AAAA,IAACC;AAAAA,EAAAA,CAAQ;AAE1C,SAAOa,cAAcD,OAAOpB,YAAYqB,WAAWL,IAAI,IACnD;AAAA,IAACA,MAAMK,WAAWL;AAAAA,IAAMH,MAAMQ,WAAWR;AAAAA,EAAAA,IACzCE;AACN,GAKaO,oBAETA,CAAC;AAAA,EAACd;AAAO,MAAM;AACjB,QAAMa,aAAad,cAAc;AAAA,IAACC;AAAAA,EAAAA,CAAQ;AAE1C,SAAOa,cAAcf,MAAAA,wBAAwBe,WAAWL,IAAI,IACxD;AAAA,IAACA,MAAMK,WAAWL;AAAAA,IAAMH,MAAMQ,WAAWR;AAAAA,EAAAA,IACzCE;AACN,GAKaQ,sBAETA,CAAC;AAAA,EAACf;AAAO,MAAM;AACjB,QAAMa,aAAad,cAAc;AAAA,IAACC;AAAAA,EAAAA,CAAQ;AAE1C,SAAOa,cAAc,CAACf,MAAAA,wBAAwBe,WAAWL,IAAI,IACzD;AAAA,IAACA,MAAMK,WAAWL;AAAAA,IAAMH,MAAMQ,WAAWR;AAAAA,EAAAA,IACzCE;AACN,GAKaS,gBAMTA,CAAC;AAAA,EAAChB;AAAO,MAAM;AACjB,QAAMa,aAAaC,kBAAkB;AAAA,IAACd;AAAAA,EAAAA,CAAQ;AAE9C,MAAI,CAACa;AACH;AAGF,QAAMZ,MAAMD,QAAQE,aAChBC,MAAAA,aAAaH,QAAQE,UAAUE,MAAMC,KAAK,CAAC,CAAC,IAC1CL,QAAQE,UAAUE,MAAMC,KAAK,CAAC,EAAEC,OAElCC,QAEEC,OAAOP,MACTY,WAAWL,KAAKS,SAASP,KAAMQ,CAAAA,SAASA,KAAKZ,SAASL,GAAG,IACzDM;AAEJ,SAAOC,QAAQP,MACX;AAAA,IAACO;AAAAA,IAAMH,MAAM,CAAC,GAAGQ,WAAWR,MAAM,YAAY;AAAA,MAACC,MAAML;AAAAA,IAAI,CAAA;AAAA,EAAA,IACzDM;AACN,GAKaY,eAGTA,CAAC;AAAA,EAACnB;AAAO,MAAM;AACjB,QAAMoB,aAAaJ,cAAc;AAAA,IAAChB;AAAAA,EAAAA,CAAQ;AAE1C,SAAOoB,cAAcC,MAAAA,mBAAmBD,WAAWZ,IAAI,IACnD;AAAA,IAACA,MAAMY,WAAWZ;AAAAA,IAAMH,MAAMe,WAAWf;AAAAA,EAAAA,IACzCE;AACN,GAKae,gBAETA,CAAC;AAAA,EAACtB;AAAO,MAAM;AACXQ,QAAAA,OAAOR,QAAQS,MAAM,CAAC;AAE5B,SAAOD,OAAO;AAAA,IAACA;AAAAA,IAAMH,MAAM,CAAC;AAAA,MAACC,MAAME,KAAKF;AAAAA,IAAK,CAAA;AAAA,EAAA,IAAKC;AACpD,GAKagB,eAETA,CAAC;AAAA,EAACvB;AAAO,MAAM;AACjB,QAAMQ,OAAOR,QAAQS,MAAMT,QAAQS,MAAMe,SAAS,CAAC,IAC/CxB,QAAQS,MAAMT,QAAQS,MAAMe,SAAS,CAAC,IACtCjB;AAEJ,SAAOC,OAAO;AAAA,IAACA;AAAAA,IAAMH,MAAM,CAAC;AAAA,MAACC,MAAME,KAAKF;AAAAA,IAAK,CAAA;AAAA,EAAA,IAAKC;AACpD,GAKakB,oBAETA,CAAC;AAAA,EAACzB;AAAO,MAAM;AACjB,MAAI,CAACA,QAAQE;AACX,WAAO,CAAE;AAGX,QAAMwB,iBACJ,CAAA,GACIC,WAAW3B,QAAQE,UAAU0B,WAC/BzB,MAAaH,aAAAA,QAAQE,UAAUE,MAAMC,KAAK,CAAC,CAAC,IAC1CL,QAAQE,UAAUE,MAAMC,KAAK,CAAC,EAAEC,OAChCC,SACFJ,mBAAaH,QAAQE,UAAU2B,OAAOxB,KAAK,CAAC,CAAC,IAC3CL,QAAQE,UAAU2B,OAAOxB,KAAK,CAAC,EAAEC,OACjCC,QACAuB,SAAS9B,QAAQE,UAAU0B,WAC7BzB,MAAaH,aAAAA,QAAQE,UAAU2B,OAAOxB,KAAK,CAAC,CAAC,IAC3CL,QAAQE,UAAU2B,OAAOxB,KAAK,CAAC,EAAEC,OACjCC,SACFJ,MAAAA,aAAaH,QAAQE,UAAUE,MAAMC,KAAK,CAAC,CAAC,IAC1CL,QAAQE,UAAUE,MAAMC,KAAK,CAAC,EAAEC,OAChCC;AAEF,MAAA,CAACoB,YAAY,CAACG;AACTJ,WAAAA;AAGEjC,aAAAA,SAASO,QAAQS,OAAO;AAC7BhB,QAAAA,MAAMa,SAASqB,UAAU;AAG3B,UAFAD,eAAeK,KAAK;AAAA,QAACvB,MAAMf;AAAAA,QAAOY,MAAM,CAAC;AAAA,UAACC,MAAMb,MAAMa;AAAAA,QAAK,CAAA;AAAA,MAAA,CAAE,GAEzDqB,aAAaG;AACf;AAEF;AAAA,IAAA;AAGErC,QAAAA,MAAMa,SAASwB,QAAQ;AACzBJ,qBAAeK,KAAK;AAAA,QAACvB,MAAMf;AAAAA,QAAOY,MAAM,CAAC;AAAA,UAACC,MAAMb,MAAMa;AAAAA,QAAK,CAAA;AAAA,MAAA,CAAE;AAC7D;AAAA,IAAA;AAGEoB,mBAAeF,SAAS,KAC1BE,eAAeK,KAAK;AAAA,MAACvB,MAAMf;AAAAA,MAAOY,MAAM,CAAC;AAAA,QAACC,MAAMb,MAAMa;AAAAA,MAAK,CAAA;AAAA,IAAA,CAAE;AAAA,EAAA;AAI1DoB,SAAAA;AACT,GAKaM,yBAMTA,CAAC;AAAA,EAAChC;AAAO,MAAM;AACjB,MAAI,CAACA,QAAQE;AACX;AAGID,QAAAA,MAAMD,QAAQE,UAAU0B,WAC1BzB,mBAAaH,QAAQE,UAAUE,MAAMC,KAAK,CAAC,CAAC,IAC1CL,QAAQE,UAAUE,MAAMC,KAAK,CAAC,EAAEC,OAChCC,SACFJ,MAAaH,aAAAA,QAAQE,UAAU2B,OAAOxB,KAAK,CAAC,CAAC,IAC3CL,QAAQE,UAAU2B,OAAOxB,KAAK,CAAC,EAAEC,OACjCC,QAEAC,OAAOP,MACTD,QAAQS,MAAMC,KAAMjB,CAAUA,UAAAA,MAAMa,SAASL,GAAG,IAChDM;AAEJ,SAAOC,QAAQP,MAAM;AAAA,IAACO;AAAAA,IAAMH,MAAM,CAAC;AAAA,MAACC,MAAML;AAAAA,IAAI,CAAA;AAAA,EAAA,IAAKM;AACrD,GAKa0B,uBAMTA,CAAC;AAAA,EAACjC;AAAO,MAAM;AACjB,MAAI,CAACA,QAAQE;AACX;AAGID,QAAAA,MAAMD,QAAQE,UAAU0B,WAC1BzB,mBAAaH,QAAQE,UAAU2B,OAAOxB,KAAK,CAAC,CAAC,IAC3CL,QAAQE,UAAU2B,OAAOxB,KAAK,CAAC,EAAEC,OACjCC,SACFJ,MAAaH,aAAAA,QAAQE,UAAUE,MAAMC,KAAK,CAAC,CAAC,IAC1CL,QAAQE,UAAUE,MAAMC,KAAK,CAAC,EAAEC,OAChCC,QAEAC,OAAOP,MACTD,QAAQS,MAAMC,KAAMjB,CAAUA,UAAAA,MAAMa,SAASL,GAAG,IAChDM;AAEJ,SAAOC,QAAQP,MAAM;AAAA,IAACO;AAAAA,IAAMH,MAAM,CAAC;AAAA,MAACC,MAAML;AAAAA,IAAI,CAAA;AAAA,EAAA,IAAKM;AACrD,GAKa2B,mBAETA,CAAC;AAAA,EAAClC;AAAO,MAAM;AACbmC,MAAAA;AACJ,QAAMC,sBAAsBJ,uBAAuB;AAAA,IAAChC;AAAAA,EAAAA,CAAQ;AAE5D,MAAI,CAACoC;AACH;AAGF,MAAIC,2BAA2B;AAEpB5C,aAAAA,SAASO,QAAQS,OAAO;AACjC,QAAIhB,MAAMa,SAAS8B,oBAAoB5B,KAAKF,MAAM;AACrB,iCAAA;AAC3B;AAAA,IAAA;AAGc,oBAAA;AAAA,MAACE,MAAMf;AAAAA,MAAOY,MAAM,CAAC;AAAA,QAACC,MAAMb,MAAMa;AAAAA,MAAK,CAAA;AAAA,IAAC;AAAA,EAAA;AAG1D,MAAI+B,4BAA4BF;AACvBA,WAAAA;AAIX,GAKaG,eAETA,CAAC;AAAA,EAACtC;AAAO,MAAM;AACbuC,MAAAA;AACJ,QAAMC,oBAAoBP,qBAAqB;AAAA,IAACjC;AAAAA,EAAAA,CAAQ;AAExD,MAAI,CAACwC;AACH;AAGF,MAAIC,yBAAyB;AAElBhD,aAAAA,SAASO,QAAQS,OAAO;AACjC,QAAIhB,MAAMa,SAASkC,kBAAkBhC,KAAKF,MAAM;AACrB,+BAAA;AACzB;AAAA,IAAA;AAGF,QAAImC,wBAAwB;AACd,kBAAA;AAAA,QAACjC,MAAMf;AAAAA,QAAOY,MAAM,CAAC;AAAA,UAACC,MAAMb,MAAMa;AAAAA,QAAK,CAAA;AAAA,MAAC;AACpD;AAAA,IAAA;AAAA,EACF;AAGF,MAAImC,0BAA0BF;AACrBA,WAAAA;AAIX,GCrTaG,oBAETA,CAAC;AAAA,EAAC1C;AAAO,MAAM;AACjB,MAAI,CAACA,QAAQE;AACX;AAGF,QAAMU,SAAStB,aAAaU,OAAO,GAE7B2C,qBADiBlB,kBAAkB;AAAA,IAACzB;AAAAA,EAAQ,CAAA,EAAE4C,IAAKnD,CAAAA,UAAUA,MAAMe,IAAI,EACnCqC,OAAOjC,OAAOf,WAAW,GAE7DiD,iBAAiBH,mBAAmBI,GAAG,CAAC;AAE9C,MAAI,CAACD;AACH;AAGF,QAAME,gBAAgBF,eAAeG;AAErC,MAAKD,iBAIDL,mBAAmBO,MAAOzD,CAAUA,UAAAA,MAAMwD,aAAaD,aAAa;AAC/DA,WAAAA;AAIX,GC5BaG,iBAAiEA,CAAC;AAAA,EAC7EnD;AACF,MAAM;AACJ,MAAI,CAACA,QAAQE;AACX;AAGF,QAAMU,SAAStB,aAAaU,OAAO,GAE7B2C,qBADiBlB,kBAAkB;AAAA,IAACzB;AAAAA,EAAQ,CAAA,EAAE4C,IAAKnD,CAAAA,UAAUA,MAAMe,IAAI,EACnCqC,OAAOjC,OAAOf,WAAW,GAE7DiD,iBAAiBH,mBAAmBI,GAAG,CAAC;AAE9C,MAAI,CAACD;AACH;AAGF,QAAMM,aAAaN,eAAeO;AAElC,MAAKD,cAIDT,mBAAmBO,MAAOzD,CAAUA,UAAAA,MAAM4D,UAAUD,UAAU;AACzDA,WAAAA;AAIX,GCxBaE,mBAKTA,CAAC;AAAA,EAACtD;AAAO,MAAM;AACjB,MAAI,CAACA,QAAQE;AACX,WAAO,CAAE;AAGLqD,QAAAA,gBAGD,IAECC,aAAaxD,QAAQE,UAAU0B,WACjC5B,QAAQE,UAAUE,QAClBJ,QAAQE,UAAU2B,QAChB4B,WAAWzD,QAAQE,UAAU0B,WAC/B5B,QAAQE,UAAU2B,SAClB7B,QAAQE,UAAUE,OAEhBsD,gBAAgBvD,MAAaqD,aAAAA,WAAWnD,KAAK,CAAC,CAAC,IACjDmD,WAAWnD,KAAK,CAAC,EAAEC,OACnBC,QACEoD,cAAcxD,mBAAasD,SAASpD,KAAK,CAAC,CAAC,IAC7CoD,SAASpD,KAAK,CAAC,EAAEC,OACjBC;AAEA,MAAA,CAACmD,iBAAiB,CAACC;AACdJ,WAAAA;AAGHK,QAAAA,eAAezD,MAAAA,aAAaqD,WAAWnD,KAAK,CAAC,CAAC,IAChDmD,WAAWnD,KAAK,CAAC,EAAEC,OACnBC,QACEsD,aAAa1D,MAAAA,aAAasD,SAASpD,KAAK,CAAC,CAAC,IAC5CoD,SAASpD,KAAK,CAAC,EAAEC,OACjBC;AAEJ,aAAWd,SAASO,QAAQS;AACrBX,QAAAA,MAAAA,wBAAwBL,KAAK,GAIlC;AAAIA,UAAAA,MAAMa,SAASoD,eAAe;AAChC,mBAAWI,SAASrE,MAAMwB;AACnBI,cAAAA,MAAAA,mBAAmByC,KAAK,GAI7B;AAAIF,gBAAAA,gBAAgBE,MAAMxD,SAASsD,cAAc;AAM/C,kBALAL,cAAcxB,KAAK;AAAA,gBACjBvB,MAAMsD;AAAAA,gBACNzD,MAAM,CAAC;AAAA,kBAACC,MAAMb,MAAMa;AAAAA,mBAAO,YAAY;AAAA,kBAACA,MAAMwD,MAAMxD;AAAAA,gBAAK,CAAA;AAAA,cAAA,CAC1D,GAEGsD,iBAAiBC;AACnB;AAGF;AAAA,YAAA;AAGEA,gBAAAA,cAAcC,MAAMxD,SAASuD,YAAY;AAC3CN,4BAAcxB,KAAK;AAAA,gBACjBvB,MAAMsD;AAAAA,gBACNzD,MAAM,CAAC;AAAA,kBAACC,MAAMb,MAAMa;AAAAA,mBAAO,YAAY;AAAA,kBAACA,MAAMwD,MAAMxD;AAAAA,gBAAK,CAAA;AAAA,cAAA,CAC1D;AACD;AAAA,YAAA;AAGEiD,0BAAc/B,SAAS,KACzB+B,cAAcxB,KAAK;AAAA,cACjBvB,MAAMsD;AAAAA,cACNzD,MAAM,CAAC;AAAA,gBAACC,MAAMb,MAAMa;AAAAA,iBAAO,YAAY;AAAA,gBAACA,MAAMwD,MAAMxD;AAAAA,cAAK,CAAA;AAAA,YAAA,CAC1D;AAAA,UAAA;AAIL,YAAIoD,kBAAkBC;AACpB;AAGF;AAAA,MAAA;AAGElE,UAAAA,MAAMa,SAASqD,aAAa;AAC9B,mBAAWG,SAASrE,MAAMwB;AACnBI,cAAAA,MAAAA,mBAAmByC,KAAK,GAI7B;AAAID,gBAAAA,cAAcC,MAAMxD,SAASuD,YAAY;AAC3CN,4BAAcxB,KAAK;AAAA,gBACjBvB,MAAMsD;AAAAA,gBACNzD,MAAM,CAAC;AAAA,kBAACC,MAAMb,MAAMa;AAAAA,mBAAO,YAAY;AAAA,kBAACA,MAAMwD,MAAMxD;AAAAA,gBAAK,CAAA;AAAA,cAAA,CAC1D;AACD;AAAA,YAAA;AAGFiD,0BAAcxB,KAAK;AAAA,cACjBvB,MAAMsD;AAAAA,cACNzD,MAAM,CAAC;AAAA,gBAACC,MAAMb,MAAMa;AAAAA,iBAAO,YAAY;AAAA,gBAACA,MAAMwD,MAAMxD;AAAAA,cAAK,CAAA;AAAA,YAAA,CAC1D;AAAA,UAAA;AAGH;AAAA,MAAA;AAGF,UAAIiD,cAAc/B,SAAS;AACzB,mBAAWsC,SAASrE,MAAMwB;AACnBI,gBAAAA,mBAAmByC,KAAK,KAI7BP,cAAcxB,KAAK;AAAA,YACjBvB,MAAMsD;AAAAA,YACNzD,MAAM,CAAC;AAAA,cAACC,MAAMb,MAAMa;AAAAA,eAAO,YAAY;AAAA,cAACA,MAAMwD,MAAMxD;AAAAA,YAAK,CAAA;AAAA,UAAA,CAC1D;AAAA,IAAA;AAKAiD,SAAAA;AACT;ACjIO,SAASQ,mBACdC,YACyB;AACzB,SAAQC,CAAa,aAAA;AACf,QAAA,CAACA,SAASjE,QAAQE;AACb,aAAA;AAGT,UAAMwB,iBAAiBD,kBAAkBwC,QAAQ,GAC3CV,gBAAgBD,iBAAiBW,QAAQ;AAM/C,QAJIV,cAAc/B,WAAW,KAK3B+B,cAAcW,KACXhD,CAAS,SAAA,CAACA,KAAKV,KAAK2D,SAASjD,KAAKV,KAAK2D,OAAO3C,WAAW,CAC5D;AAEO,aAAA;AAGT,UAAM4C,oBAAoB1C,eAAe2C,QAAS5E,CAAAA,UAChDK,MAAAA,wBAAwBL,MAAMe,IAAI,IAAKf,MAAMe,KAAK8D,YAAY,CAAA,IAAM,CAAA,CACtE;AAEA,WAAOf,cAAcL,MAAOhC,CAAAA,UAExBA,KAAKV,KAAK2D,OAAOE,QAASE,CAAS,SAAA;AACjC,YAAMC,UAAUJ,kBAAkB1D,KAC/B8D,CAAAA,aAAYA,SAAQlE,SAASiE,IAChC;AAEA,aAAOC,UAAU,CAACA,QAAQ7E,KAAK,IAAI,CAAE;AAAA,IACtC,CAAA,KAAK,CAEY8E,GAAAA,SAAST,UAAU,CACxC;AAAA,EACH;AACF;AC3CO,MAAMU,uBAAgDA,CAAC;AAAA,EAAC1E;AAAO,MAC/DA,QAAQE,YAKXyE,KAAKC,UAAU5E,QAAQE,UAAU2B,OAAOxB,IAAI,MAC1CsE,KAAKC,UAAU5E,QAAQE,UAAUE,MAAMC,IAAI,KAC7CL,QAAQE,WAAW2B,OAAOgD,WAAW7E,QAAQE,WAAWE,MAAMyE,SANvD,ICDEC,sBAA+CA,CAAC;AAAA,EAAC9E;AAAO,MAC5D,CAAC0E,qBAAqB;AAAA,EAAC1E;AAAO,CAAC;ACAjC,SAAS+E,kBAAkBC,WAA4C;AAC5E,SAAQf,CAAa,aAAA;AACfa,QAAAA,oBAAoBb,QAAQ,GAAG;AAC3BV,YAAAA,gBAAgBD,iBAAiBW,QAAQ;AAG7CV,aAAAA,cAAc/B,SAAS,KACvB+B,cAAcL,MAAOhC,CAASA,SAAAA,KAAKV,KAAK2D,OAAOM,SAASO,SAAS,CAAC;AAAA,IAAA;AAItE,WAAOf,SAASjE,QAAQiF,iBAAiBR,SAASO,SAAS;AAAA,EAC7D;AACF;ACdO,SAASE,iBAAiBjC,UAA2C;AAClEgB,SAAAA,CAAAA,aACiBvB,kBAAkBuB,QAAQ,MAEvBhB;AAE9B;ACNO,SAASkC,cAAc9B,OAAwC;AAC5DY,SAAAA,CAAAA,aACcd,eAAec,QAAQ,MAEpBZ;AAE3B;ACJO,SAAS+B,kBAAkB3F,OAGN;AAC1B,SAAO,CAAC;AAAA,IAACO;AAAAA,EAAAA,MAAa;AACpB,QAAI,CAACA,QAAQE,aAAa,CAACwE,qBAAqB;AAAA,MAAC1E;AAAAA,IAAAA,CAAQ;AAChD,aAAA;AAGHqF,UAAAA,gBAAgBC,4BAAMC,iBAAiB9F,KAAK;AAElD,WAAO6F,4BAAME,uBAAuBxF,QAAQE,UAAUE,OAAOiF,aAAa;AAAA,EAC5E;AACF;ACbO,SAASI,oBAAoBhG,OAGR;AAC1B,SAAO,CAAC;AAAA,IAACO;AAAAA,EAAAA,MAAa;AACpB,QAAI,CAACA,QAAQE,aAAa,CAACwE,qBAAqB;AAAA,MAAC1E;AAAAA,IAAAA,CAAQ;AAChD,aAAA;AAGH0F,UAAAA,kBAAkBJ,4BAAMK,mBAAmBlG,KAAK;AAEtD,WAAO6F,4BAAME,uBACXxF,QAAQE,UAAUE,OAClBsF,eACF;AAAA,EACF;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;"}
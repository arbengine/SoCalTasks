"use strict";
var types = require("@sanity/types");
function sliceBlocks({
  blocks,
  selection
}) {
  const slice = [];
  if (!selection)
    return slice;
  let startBlock;
  const middleBlocks = [];
  let endBlock;
  const startPoint = selection.backward ? selection.focus : selection.anchor, endPoint = selection.backward ? selection.anchor : selection.focus, startBlockKey = types.isKeySegment(startPoint.path[0]) ? startPoint.path[0]._key : void 0, endBlockKey = types.isKeySegment(endPoint.path[0]) ? endPoint.path[0]._key : void 0, startChildKey = types.isKeySegment(startPoint.path[2]) ? startPoint.path[2]._key : void 0, endChildKey = types.isKeySegment(endPoint.path[2]) ? endPoint.path[2]._key : void 0;
  if (!startBlockKey || !endBlockKey)
    return slice;
  for (const block of blocks) {
    if (!types.isPortableTextTextBlock(block) && block._key === startBlockKey && block._key === endBlockKey) {
      startBlock = block;
      break;
    }
    if (block._key === startBlockKey) {
      if (!types.isPortableTextTextBlock(block)) {
        startBlock = block;
        continue;
      }
      if (startChildKey) {
        for (const child of block.children) {
          if (child._key === startChildKey) {
            if (types.isPortableTextSpan(child)) {
              const text = child._key === endChildKey ? child.text.slice(startPoint.offset, endPoint.offset) : child.text.slice(startPoint.offset);
              startBlock = {
                ...block,
                children: [{
                  ...child,
                  text
                }]
              };
            } else
              startBlock = {
                ...block,
                children: [child]
              };
            if (startChildKey === endChildKey)
              break;
            continue;
          }
          if (startBlock && types.isPortableTextTextBlock(startBlock) && (startBlock.children.push(child), block._key === endBlockKey && endChildKey && child._key === endChildKey))
            break;
        }
        if (startBlockKey === endBlockKey)
          break;
        continue;
      }
      if (startBlock = block, startBlockKey === endBlockKey)
        break;
    }
    if (block._key === endBlockKey) {
      if (!types.isPortableTextTextBlock(block)) {
        endBlock = block;
        break;
      }
      if (endChildKey) {
        endBlock = {
          ...block,
          children: []
        };
        for (const child of block.children)
          if (endBlock && types.isPortableTextTextBlock(endBlock)) {
            if (child._key === endChildKey && types.isPortableTextSpan(child)) {
              endBlock.children.push({
                ...child,
                text: child.text.slice(0, endPoint.offset)
              });
              break;
            }
            if (endBlock.children.push(child), endChildKey && child._key === endChildKey)
              break;
          }
        break;
      }
      endBlock = block;
      break;
    }
    startBlock && middleBlocks.push(block);
  }
  return [...startBlock ? [startBlock] : [], ...middleBlocks, ...endBlock ? [endBlock] : []];
}
exports.sliceBlocks = sliceBlocks;
//# sourceMappingURL=util.slice-blocks.cjs.map

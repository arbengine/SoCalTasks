{"version":3,"file":"util.slice-blocks.cjs","sources":["../../src/utils/util.slice-blocks.ts"],"sourcesContent":["import {\n  isKeySegment,\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type PortableTextBlock,\n} from '@sanity/types'\nimport type {EditorSelection} from '../selectors'\n\n/**\n * @public\n */\nexport function sliceBlocks({\n  blocks,\n  selection,\n}: {\n  blocks: Array<PortableTextBlock>\n  selection: EditorSelection\n}): Array<PortableTextBlock> {\n  const slice: Array<PortableTextBlock> = []\n\n  if (!selection) {\n    return slice\n  }\n\n  let startBlock: PortableTextBlock | undefined\n  const middleBlocks: PortableTextBlock[] = []\n  let endBlock: PortableTextBlock | undefined\n\n  const startPoint = selection.backward ? selection.focus : selection.anchor\n  const endPoint = selection.backward ? selection.anchor : selection.focus\n\n  const startBlockKey = isKeySegment(startPoint.path[0])\n    ? startPoint.path[0]._key\n    : undefined\n  const endBlockKey = isKeySegment(endPoint.path[0])\n    ? endPoint.path[0]._key\n    : undefined\n  const startChildKey = isKeySegment(startPoint.path[2])\n    ? startPoint.path[2]._key\n    : undefined\n  const endChildKey = isKeySegment(endPoint.path[2])\n    ? endPoint.path[2]._key\n    : undefined\n\n  if (!startBlockKey || !endBlockKey) {\n    return slice\n  }\n\n  for (const block of blocks) {\n    if (!isPortableTextTextBlock(block)) {\n      if (block._key === startBlockKey && block._key === endBlockKey) {\n        startBlock = block\n        break\n      }\n    }\n\n    if (block._key === startBlockKey) {\n      if (!isPortableTextTextBlock(block)) {\n        startBlock = block\n        continue\n      }\n\n      if (startChildKey) {\n        for (const child of block.children) {\n          if (child._key === startChildKey) {\n            if (isPortableTextSpan(child)) {\n              const text =\n                child._key === endChildKey\n                  ? child.text.slice(startPoint.offset, endPoint.offset)\n                  : child.text.slice(startPoint.offset)\n\n              startBlock = {\n                ...block,\n                children: [\n                  {\n                    ...child,\n                    text,\n                  },\n                ],\n              }\n            } else {\n              startBlock = {\n                ...block,\n                children: [child],\n              }\n            }\n\n            if (startChildKey === endChildKey) {\n              break\n            }\n            continue\n          }\n\n          if (startBlock && isPortableTextTextBlock(startBlock)) {\n            startBlock.children.push(child)\n\n            if (\n              block._key === endBlockKey &&\n              endChildKey &&\n              child._key === endChildKey\n            ) {\n              break\n            }\n          }\n        }\n\n        if (startBlockKey === endBlockKey) {\n          break\n        }\n\n        continue\n      }\n\n      startBlock = block\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n    }\n\n    if (block._key === endBlockKey) {\n      if (!isPortableTextTextBlock(block)) {\n        endBlock = block\n        break\n      }\n\n      if (endChildKey) {\n        endBlock = {\n          ...block,\n          children: [],\n        }\n\n        for (const child of block.children) {\n          if (endBlock && isPortableTextTextBlock(endBlock)) {\n            if (child._key === endChildKey && isPortableTextSpan(child)) {\n              endBlock.children.push({\n                ...child,\n                text: child.text.slice(0, endPoint.offset),\n              })\n\n              break\n            }\n\n            endBlock.children.push(child)\n\n            if (endChildKey && child._key === endChildKey) {\n              break\n            }\n          }\n        }\n\n        break\n      }\n\n      endBlock = block\n\n      break\n    }\n\n    if (startBlock) {\n      middleBlocks.push(block)\n    }\n  }\n\n  return [\n    ...(startBlock ? [startBlock] : []),\n    ...middleBlocks,\n    ...(endBlock ? [endBlock] : []),\n  ]\n}\n"],"names":["sliceBlocks","blocks","selection","slice","startBlock","middleBlocks","endBlock","startPoint","backward","focus","anchor","endPoint","startBlockKey","isKeySegment","path","_key","undefined","endBlockKey","startChildKey","endChildKey","block","isPortableTextTextBlock","child","children","isPortableTextSpan","text","offset","push"],"mappings":"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"}
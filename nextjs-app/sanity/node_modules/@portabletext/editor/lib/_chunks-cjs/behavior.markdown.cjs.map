{"version":3,"file":"behavior.markdown.cjs","sources":["../../src/behaviors/behavior.markdown.ts"],"sourcesContent":["import {isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSchema} from '../editor/define-schema'\nimport * as selectors from '../selectors'\nimport {getBlockTextBefore} from '../selectors/selector.get-text-before'\nimport {spanSelectionPointToBlockOffset} from '../utils/util.block-offset'\nimport {getTextBlockText} from '../utils/util.get-text-block-text'\nimport {defineBehavior} from './behavior.types'\n\n/**\n * @beta\n */\nexport type MarkdownBehaviorsConfig = {\n  horizontalRuleObject?: (context: {\n    schema: EditorSchema\n  }) => {name: string; value?: {[prop: string]: unknown}} | undefined\n  defaultStyle?: (context: {schema: EditorSchema}) => string | undefined\n  headingStyle?: (context: {\n    schema: EditorSchema\n    level: number\n  }) => string | undefined\n  blockquoteStyle?: (context: {schema: EditorSchema}) => string | undefined\n  unorderedListStyle?: (context: {schema: EditorSchema}) => string | undefined\n  orderedListStyle?: (context: {schema: EditorSchema}) => string | undefined\n}\n\n/**\n * @beta\n * Create markdown behaviors for common markdown actions such as converting ### to headings, --- to HRs, and more.\n *\n * @example\n * Configure the bundled markdown behaviors\n * ```ts\n * import {EditorProvider} from '@portabletext/editor'\n * import {createMarkdownBehaviors, coreBehaviors} from '@portabletext/editor/behaviors'\n *\n * function App() {\n *  return (\n *   <EditorProvider\n *    initialConfig={{\n *    behaviors: [\n *    ...coreBehaviors,\n *    ...createMarkdownBehaviors({\n *        horizontalRuleObject: ({schema}) => {\n *          const name = schema.blockObjects.find(\n *            (object) => object.name === 'break',\n *          )?.name\n *          return name ? {name} : undefined\n *        },\n *        defaultStyle: ({schema}) => schema.styles[0].value,\n *        headingStyle: ({schema, level}) =>\n *          schema.styles.find((style) => style.value === `h${level}`)\n *            ?.value,\n *        blockquoteStyle: ({schema}) =>\n *          schema.styles.find((style) => style.value === 'blockquote')\n *            ?.value,\n *        unorderedListStyle: ({schema}) =>\n *          schema.lists.find((list) => list.value === 'bullet')?.value,\n *        orderedListStyle: ({schema}) =>\n *          schema.lists.find((list) => list.value === 'number')?.value,\n *      }),\n *      ]\n *    }}\n *    >\n *    {...}\n *    </EditorProvider>\n *  )\n * }\n * ```\n *\n */\nexport function createMarkdownBehaviors(config: MarkdownBehaviorsConfig) {\n  const automaticBlockquoteOnSpace = defineBehavior({\n    on: 'insert.text',\n    guard: ({context, event}) => {\n      const isSpace = event.text === ' '\n\n      if (!isSpace) {\n        return false\n      }\n\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n      const focusTextBlock = selectors.getFocusTextBlock({context})\n      const focusSpan = selectors.getFocusSpan({context})\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: context.value,\n        selectionPoint: {\n          path: [\n            {_key: focusTextBlock.node._key},\n            'children',\n            {_key: focusSpan.node._key},\n          ],\n          offset: context.selection?.focus.offset ?? 0,\n        },\n      })\n\n      if (!blockOffset) {\n        return false\n      }\n\n      const blockText = getTextBlockText(focusTextBlock.node)\n      const caretAtTheEndOfQuote = blockOffset.offset === 1\n      const looksLikeMarkdownQuote = /^>/.test(blockText)\n      const blockquoteStyle = config.blockquoteStyle?.(context)\n\n      if (\n        caretAtTheEndOfQuote &&\n        looksLikeMarkdownQuote &&\n        blockquoteStyle !== undefined\n      ) {\n        return {focusTextBlock, style: blockquoteStyle}\n      }\n\n      return false\n    },\n    actions: [\n      () => [\n        {\n          type: 'insert.text',\n          text: ' ',\n        },\n      ],\n      (_, {focusTextBlock, style}) => [\n        {\n          type: 'text block.unset',\n          props: ['listItem', 'level'],\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'text block.set',\n          style,\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'delete.text',\n          anchor: {\n            path: focusTextBlock.path,\n            offset: 0,\n          },\n          focus: {\n            path: focusTextBlock.path,\n            offset: 2,\n          },\n        },\n      ],\n    ],\n  })\n  const automaticHr = defineBehavior({\n    on: 'insert.text',\n    guard: ({context, event}) => {\n      const hrCharacter =\n        event.text === '-'\n          ? '-'\n          : event.text === '*'\n            ? '*'\n            : event.text === '_'\n              ? '_'\n              : undefined\n\n      if (hrCharacter === undefined) {\n        return false\n      }\n\n      const hrObject = config.horizontalRuleObject?.(context)\n      const focusBlock = selectors.getFocusTextBlock({context})\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n\n      if (!hrObject || !focusBlock || !selectionCollapsed) {\n        return false\n      }\n\n      const textBefore = getBlockTextBefore({context})\n      const hrBlockOffsets = {\n        anchor: {\n          path: focusBlock.path,\n          offset: 0,\n        },\n        focus: {\n          path: focusBlock.path,\n          offset: 3,\n        },\n      }\n\n      if (textBefore === `${hrCharacter}${hrCharacter}`) {\n        return {hrObject, focusBlock, hrCharacter, hrBlockOffsets}\n      }\n\n      return false\n    },\n    actions: [\n      (_, {hrCharacter}) => [\n        {\n          type: 'insert.text',\n          text: hrCharacter,\n        },\n      ],\n      (_, {hrObject, hrBlockOffsets}) => [\n        {\n          type: 'insert.block object',\n          placement: 'before',\n          blockObject: hrObject,\n        },\n        {\n          type: 'delete.text',\n          ...hrBlockOffsets,\n        },\n      ],\n    ],\n  })\n  const automaticHrOnPaste = defineBehavior({\n    on: 'paste',\n    guard: ({context, event}) => {\n      const text = event.data.getData('text/plain')\n      const hrRegExp = /^(---)$|(___)$|(\\*\\*\\*)$/gm\n      const hrCharacters = text.match(hrRegExp)?.[0]\n      const hrObject = config.horizontalRuleObject?.(context)\n      const focusBlock = selectors.getFocusBlock({context})\n\n      if (!hrCharacters || !hrObject || !focusBlock) {\n        return false\n      }\n\n      return {hrCharacters, hrObject, focusBlock}\n    },\n    actions: [\n      (_, {hrCharacters}) => [\n        {\n          type: 'insert.text',\n          text: hrCharacters,\n        },\n      ],\n      (_, {hrObject, focusBlock}) =>\n        isPortableTextTextBlock(focusBlock.node)\n          ? [\n              {\n                type: 'insert.text block',\n                textBlock: {children: focusBlock.node.children},\n                placement: 'after',\n              },\n              {\n                type: 'insert.block object',\n                blockObject: hrObject,\n                placement: 'after',\n              },\n              {type: 'delete.block', blockPath: focusBlock.path},\n            ]\n          : [\n              {\n                type: 'insert.block object',\n                blockObject: hrObject,\n                placement: 'after',\n              },\n            ],\n    ],\n  })\n  const automaticHeadingOnSpace = defineBehavior({\n    on: 'insert.text',\n    guard: ({context, event}) => {\n      const isSpace = event.text === ' '\n\n      if (!isSpace) {\n        return false\n      }\n\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n      const focusTextBlock = selectors.getFocusTextBlock({context})\n      const focusSpan = selectors.getFocusSpan({context})\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: context.value,\n        selectionPoint: {\n          path: [\n            {_key: focusTextBlock.node._key},\n            'children',\n            {_key: focusSpan.node._key},\n          ],\n          offset: context.selection?.focus.offset ?? 0,\n        },\n      })\n\n      if (!blockOffset) {\n        return false\n      }\n\n      const blockText = getTextBlockText(focusTextBlock.node)\n      const markdownHeadingSearch = /^#+/.exec(blockText)\n      const level = markdownHeadingSearch\n        ? markdownHeadingSearch[0].length\n        : undefined\n      const caretAtTheEndOfHeading = blockOffset.offset === level\n\n      if (!caretAtTheEndOfHeading) {\n        return false\n      }\n\n      const style =\n        level !== undefined\n          ? config.headingStyle?.({schema: context.schema, level})\n          : undefined\n\n      if (level !== undefined && style !== undefined) {\n        return {\n          focusTextBlock,\n          style: style,\n          level,\n        }\n      }\n\n      return false\n    },\n    actions: [\n      ({event}) => [event],\n      (_, {focusTextBlock, style, level}) => [\n        {\n          type: 'text block.unset',\n          props: ['listItem', 'level'],\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'text block.set',\n          style,\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'delete.text',\n          anchor: {\n            path: focusTextBlock.path,\n            offset: 0,\n          },\n          focus: {\n            path: focusTextBlock.path,\n            offset: level + 1,\n          },\n        },\n      ],\n    ],\n  })\n  const clearStyleOnBackspace = defineBehavior({\n    on: 'delete.backward',\n    guard: ({context}) => {\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n      const focusTextBlock = selectors.getFocusTextBlock({context})\n      const focusSpan = selectors.getFocusSpan({context})\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const atTheBeginningOfBLock =\n        focusTextBlock.node.children[0]._key === focusSpan.node._key &&\n        context.selection?.focus.offset === 0\n\n      const defaultStyle = config.defaultStyle?.(context)\n\n      if (\n        atTheBeginningOfBLock &&\n        defaultStyle &&\n        focusTextBlock.node.style !== defaultStyle\n      ) {\n        return {defaultStyle, focusTextBlock}\n      }\n\n      return false\n    },\n    actions: [\n      (_, {defaultStyle, focusTextBlock}) => [\n        {\n          type: 'text block.set',\n          style: defaultStyle,\n          at: focusTextBlock.path,\n        },\n      ],\n    ],\n  })\n  const automaticListOnSpace = defineBehavior({\n    on: 'insert.text',\n    guard: ({context, event}) => {\n      const isSpace = event.text === ' '\n\n      if (!isSpace) {\n        return false\n      }\n\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n      const focusTextBlock = selectors.getFocusTextBlock({context})\n      const focusSpan = selectors.getFocusSpan({context})\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: context.value,\n        selectionPoint: {\n          path: [\n            {_key: focusTextBlock.node._key},\n            'children',\n            {_key: focusSpan.node._key},\n          ],\n          offset: context.selection?.focus.offset ?? 0,\n        },\n      })\n\n      if (!blockOffset) {\n        return false\n      }\n\n      const blockText = getTextBlockText(focusTextBlock.node)\n      const defaultStyle = config.defaultStyle?.(context)\n      const looksLikeUnorderedList = /^(-|\\*)/.test(blockText)\n      const unorderedListStyle = config.unorderedListStyle?.(context)\n      const caretAtTheEndOfUnorderedList = blockOffset.offset === 1\n\n      if (\n        defaultStyle &&\n        caretAtTheEndOfUnorderedList &&\n        looksLikeUnorderedList &&\n        unorderedListStyle !== undefined\n      ) {\n        return {\n          focusTextBlock,\n          listItem: unorderedListStyle,\n          listItemLength: 1,\n          style: defaultStyle,\n        }\n      }\n\n      const looksLikeOrderedList = /^1\\./.test(blockText)\n      const orderedListStyle = config.orderedListStyle?.(context)\n      const caretAtTheEndOfOrderedList = blockOffset.offset === 2\n\n      if (\n        defaultStyle &&\n        caretAtTheEndOfOrderedList &&\n        looksLikeOrderedList &&\n        orderedListStyle !== undefined\n      ) {\n        return {\n          focusTextBlock,\n          listItem: orderedListStyle,\n          listItemLength: 2,\n          style: defaultStyle,\n        }\n      }\n\n      return false\n    },\n    actions: [\n      ({event}) => [event],\n      (_, {focusTextBlock, style, listItem, listItemLength}) => [\n        {\n          type: 'text block.set',\n          listItem,\n          level: 1,\n          style,\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'delete.text',\n          anchor: {\n            path: focusTextBlock.path,\n            offset: 0,\n          },\n          focus: {\n            path: focusTextBlock.path,\n            offset: listItemLength + 1,\n          },\n        },\n      ],\n    ],\n  })\n\n  const markdownBehaviors = [\n    automaticBlockquoteOnSpace,\n    automaticHeadingOnSpace,\n    automaticHr,\n    automaticHrOnPaste,\n    clearStyleOnBackspace,\n    automaticListOnSpace,\n  ]\n\n  return markdownBehaviors\n}\n"],"names":["createMarkdownBehaviors","config","automaticBlockquoteOnSpace","defineBehavior","on","guard","context","event","text","selectionCollapsed","selectors","focusTextBlock","focusSpan","blockOffset","spanSelectionPointToBlockOffset","value","selectionPoint","path","_key","node","offset","selection","focus","blockText","getTextBlockText","caretAtTheEndOfQuote","looksLikeMarkdownQuote","test","blockquoteStyle","undefined","style","actions","type","_","props","at","anchor","automaticHr","hrCharacter","hrObject","horizontalRuleObject","focusBlock","textBefore","getBlockTextBefore","hrBlockOffsets","placement","blockObject","automaticHrOnPaste","data","getData","hrRegExp","hrCharacters","match","isPortableTextTextBlock","textBlock","children","blockPath","automaticHeadingOnSpace","markdownHeadingSearch","exec","level","length","headingStyle","schema","clearStyleOnBackspace","atTheBeginningOfBLock","defaultStyle","automaticListOnSpace","looksLikeUnorderedList","unorderedListStyle","caretAtTheEndOfUnorderedList","listItem","listItemLength","looksLikeOrderedList","orderedListStyle","caretAtTheEndOfOrderedList"],"mappings":"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"}
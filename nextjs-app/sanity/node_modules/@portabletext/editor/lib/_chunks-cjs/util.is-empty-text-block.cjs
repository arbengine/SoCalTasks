"use strict";
var types = require("@sanity/types"), util_isEqualSelectionPoints = require("./util.is-equal-selection-points.cjs");
function blockOffsetToSpanSelectionPoint({
  value,
  blockOffset
}) {
  let offsetLeft = blockOffset.offset, selectionPoint;
  for (const block of value)
    if (block._key === blockOffset.path[0]._key && types.isPortableTextTextBlock(block)) {
      for (const child of block.children)
        if (types.isPortableTextSpan(child)) {
          if (offsetLeft === 0) {
            selectionPoint = {
              path: [...blockOffset.path, "children", {
                _key: child._key
              }],
              offset: 0
            };
            break;
          }
          if (offsetLeft <= child.text.length) {
            selectionPoint = {
              path: [...blockOffset.path, "children", {
                _key: child._key
              }],
              offset: offsetLeft
            };
            break;
          }
          offsetLeft -= child.text.length;
        }
    }
  return selectionPoint;
}
function spanSelectionPointToBlockOffset({
  value,
  selectionPoint
}) {
  let offset = 0;
  const blockKey = util_isEqualSelectionPoints.isKeyedSegment(selectionPoint.path[0]) ? selectionPoint.path[0]._key : void 0, spanKey = util_isEqualSelectionPoints.isKeyedSegment(selectionPoint.path[2]) ? selectionPoint.path[2]._key : void 0;
  if (!(!blockKey || !spanKey)) {
    for (const block of value)
      if (block._key === blockKey && types.isPortableTextTextBlock(block)) {
        for (const child of block.children)
          if (types.isPortableTextSpan(child)) {
            if (child._key === spanKey)
              return {
                path: [{
                  _key: block._key
                }],
                offset: offset + selectionPoint.offset
              };
            offset += child.text.length;
          }
      }
  }
}
function getTextBlockText(block) {
  return block.children.map((child) => child.text ?? "").join("");
}
function isEmptyTextBlock(block) {
  if (!types.isPortableTextTextBlock(block))
    return !1;
  const onlyText = block.children.every(types.isPortableTextSpan), blockText = getTextBlockText(block);
  return onlyText && blockText === "";
}
exports.blockOffsetToSpanSelectionPoint = blockOffsetToSpanSelectionPoint;
exports.getTextBlockText = getTextBlockText;
exports.isEmptyTextBlock = isEmptyTextBlock;
exports.spanSelectionPointToBlockOffset = spanSelectionPointToBlockOffset;
//# sourceMappingURL=util.is-empty-text-block.cjs.map

import { isPortableTextListBlock, isPortableTextTextBlock, isKeySegment, isPortableTextSpan } from "@sanity/types";
import { getBlockEndPoint, isEqualSelectionPoints, getBlockStartPoint } from "./util.is-equal-selection-points.js";
function createGuards({
  schema
}) {
  function isListBlock(block) {
    return isPortableTextListBlock(block) && block._type === schema.block.name;
  }
  function isTextBlock(block) {
    return isPortableTextTextBlock(block) && block._type === schema.block.name;
  }
  return {
    isListBlock,
    isTextBlock
  };
}
const getFocusBlock = ({
  context
}) => {
  const key = context.selection && isKeySegment(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0, node = key ? context.value.find((block) => block._key === key) : void 0;
  return node && key ? {
    node,
    path: [{
      _key: key
    }]
  } : void 0;
}, getFocusListBlock = ({
  context
}) => {
  const guards = createGuards(context), focusBlock = getFocusBlock({
    context
  });
  return focusBlock && guards.isListBlock(focusBlock.node) ? {
    node: focusBlock.node,
    path: focusBlock.path
  } : void 0;
}, getFocusTextBlock = ({
  context
}) => {
  const focusBlock = getFocusBlock({
    context
  });
  return focusBlock && isPortableTextTextBlock(focusBlock.node) ? {
    node: focusBlock.node,
    path: focusBlock.path
  } : void 0;
}, getFocusBlockObject = ({
  context
}) => {
  const focusBlock = getFocusBlock({
    context
  });
  return focusBlock && !isPortableTextTextBlock(focusBlock.node) ? {
    node: focusBlock.node,
    path: focusBlock.path
  } : void 0;
}, getFocusChild = ({
  context
}) => {
  const focusBlock = getFocusTextBlock({
    context
  });
  if (!focusBlock)
    return;
  const key = context.selection && isKeySegment(context.selection.focus.path[2]) ? context.selection.focus.path[2]._key : void 0, node = key ? focusBlock.node.children.find((span) => span._key === key) : void 0;
  return node && key ? {
    node,
    path: [...focusBlock.path, "children", {
      _key: key
    }]
  } : void 0;
}, getFocusSpan = ({
  context
}) => {
  const focusChild = getFocusChild({
    context
  });
  return focusChild && isPortableTextSpan(focusChild.node) ? {
    node: focusChild.node,
    path: focusChild.path
  } : void 0;
}, getFirstBlock = ({
  context
}) => {
  const node = context.value[0];
  return node ? {
    node,
    path: [{
      _key: node._key
    }]
  } : void 0;
}, getLastBlock = ({
  context
}) => {
  const node = context.value[context.value.length - 1] ? context.value[context.value.length - 1] : void 0;
  return node ? {
    node,
    path: [{
      _key: node._key
    }]
  } : void 0;
}, getSelectedBlocks = ({
  context
}) => {
  if (!context.selection)
    return [];
  const selectedBlocks = [], startKey = context.selection.backward ? isKeySegment(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0 : isKeySegment(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0, endKey = context.selection.backward ? isKeySegment(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0 : isKeySegment(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0;
  if (!startKey || !endKey)
    return selectedBlocks;
  for (const block of context.value) {
    if (block._key === startKey) {
      if (selectedBlocks.push({
        node: block,
        path: [{
          _key: block._key
        }]
      }), startKey === endKey)
        break;
      continue;
    }
    if (block._key === endKey) {
      selectedBlocks.push({
        node: block,
        path: [{
          _key: block._key
        }]
      });
      break;
    }
    selectedBlocks.length > 0 && selectedBlocks.push({
      node: block,
      path: [{
        _key: block._key
      }]
    });
  }
  return selectedBlocks;
}, getSelectionStartBlock = ({
  context
}) => {
  if (!context.selection)
    return;
  const key = context.selection.backward ? isKeySegment(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0 : isKeySegment(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0, node = key ? context.value.find((block) => block._key === key) : void 0;
  return node && key ? {
    node,
    path: [{
      _key: key
    }]
  } : void 0;
}, getSelectionEndBlock = ({
  context
}) => {
  if (!context.selection)
    return;
  const key = context.selection.backward ? isKeySegment(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0 : isKeySegment(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0, node = key ? context.value.find((block) => block._key === key) : void 0;
  return node && key ? {
    node,
    path: [{
      _key: key
    }]
  } : void 0;
}, getPreviousBlock = ({
  context
}) => {
  let previousBlock;
  const selectionStartBlock = getSelectionStartBlock({
    context
  });
  if (!selectionStartBlock)
    return;
  let foundSelectionStartBlock = !1;
  for (const block of context.value) {
    if (block._key === selectionStartBlock.node._key) {
      foundSelectionStartBlock = !0;
      break;
    }
    previousBlock = {
      node: block,
      path: [{
        _key: block._key
      }]
    };
  }
  if (foundSelectionStartBlock && previousBlock)
    return previousBlock;
}, getNextBlock = ({
  context
}) => {
  let nextBlock;
  const selectionEndBlock = getSelectionEndBlock({
    context
  });
  if (!selectionEndBlock)
    return;
  let foundSelectionEndBlock = !1;
  for (const block of context.value) {
    if (block._key === selectionEndBlock.node._key) {
      foundSelectionEndBlock = !0;
      continue;
    }
    if (foundSelectionEndBlock) {
      nextBlock = {
        node: block,
        path: [{
          _key: block._key
        }]
      };
      break;
    }
  }
  if (foundSelectionEndBlock && nextBlock)
    return nextBlock;
}, getActiveListItem = ({
  context
}) => {
  if (!context.selection)
    return;
  const guards = createGuards(context), selectedTextBlocks = getSelectedBlocks({
    context
  }).map((block) => block.node).filter(guards.isTextBlock), firstTextBlock = selectedTextBlocks.at(0);
  if (!firstTextBlock)
    return;
  const firstListItem = firstTextBlock.listItem;
  if (firstListItem && selectedTextBlocks.every((block) => block.listItem === firstListItem))
    return firstListItem;
}, getActiveStyle = ({
  context
}) => {
  if (!context.selection)
    return;
  const guards = createGuards(context), selectedTextBlocks = getSelectedBlocks({
    context
  }).map((block) => block.node).filter(guards.isTextBlock), firstTextBlock = selectedTextBlocks.at(0);
  if (!firstTextBlock)
    return;
  const firstStyle = firstTextBlock.style;
  if (firstStyle && selectedTextBlocks.every((block) => block.style === firstStyle))
    return firstStyle;
}, getSelectedSpans = ({
  context
}) => {
  if (!context.selection)
    return [];
  const selectedSpans = [], startPoint = context.selection.backward ? context.selection.focus : context.selection.anchor, endPoint = context.selection.backward ? context.selection.anchor : context.selection.focus, startBlockKey = isKeySegment(startPoint.path[0]) ? startPoint.path[0]._key : void 0, endBlockKey = isKeySegment(endPoint.path[0]) ? endPoint.path[0]._key : void 0;
  if (!startBlockKey || !endBlockKey)
    return selectedSpans;
  const startSpanKey = isKeySegment(startPoint.path[2]) ? startPoint.path[2]._key : void 0, endSpanKey = isKeySegment(endPoint.path[2]) ? endPoint.path[2]._key : void 0;
  for (const block of context.value)
    if (isPortableTextTextBlock(block)) {
      if (block._key === startBlockKey) {
        for (const child of block.children)
          if (isPortableTextSpan(child)) {
            if (startSpanKey && child._key === startSpanKey) {
              if (selectedSpans.push({
                node: child,
                path: [{
                  _key: block._key
                }, "children", {
                  _key: child._key
                }]
              }), startSpanKey === endSpanKey)
                break;
              continue;
            }
            if (endSpanKey && child._key === endSpanKey) {
              selectedSpans.push({
                node: child,
                path: [{
                  _key: block._key
                }, "children", {
                  _key: child._key
                }]
              });
              break;
            }
            selectedSpans.length > 0 && selectedSpans.push({
              node: child,
              path: [{
                _key: block._key
              }, "children", {
                _key: child._key
              }]
            });
          }
        if (startBlockKey === endBlockKey)
          break;
        continue;
      }
      if (block._key === endBlockKey) {
        for (const child of block.children)
          if (isPortableTextSpan(child)) {
            if (endSpanKey && child._key === endSpanKey) {
              selectedSpans.push({
                node: child,
                path: [{
                  _key: block._key
                }, "children", {
                  _key: child._key
                }]
              });
              break;
            }
            selectedSpans.push({
              node: child,
              path: [{
                _key: block._key
              }, "children", {
                _key: child._key
              }]
            });
          }
        break;
      }
      if (selectedSpans.length > 0)
        for (const child of block.children)
          isPortableTextSpan(child) && selectedSpans.push({
            node: child,
            path: [{
              _key: block._key
            }, "children", {
              _key: child._key
            }]
          });
    }
  return selectedSpans;
};
function isActiveAnnotation(annotation) {
  return (snapshot) => {
    if (!snapshot.context.selection)
      return !1;
    const selectedBlocks = getSelectedBlocks(snapshot), selectedSpans = getSelectedSpans(snapshot);
    if (selectedSpans.length === 0 || selectedSpans.some((span) => !span.node.marks || span.node.marks?.length === 0))
      return !1;
    const selectionMarkDefs = selectedBlocks.flatMap((block) => isPortableTextTextBlock(block.node) ? block.node.markDefs ?? [] : []);
    return selectedSpans.every((span) => (span.node.marks?.flatMap((mark) => {
      const markDef = selectionMarkDefs.find((markDef2) => markDef2._key === mark);
      return markDef ? [markDef._type] : [];
    }) ?? []).includes(annotation));
  };
}
const isSelectionCollapsed = ({
  context
}) => context.selection ? JSON.stringify(context.selection.anchor.path) === JSON.stringify(context.selection.focus.path) && context.selection?.anchor.offset === context.selection?.focus.offset : !1, isSelectionExpanded = ({
  context
}) => !isSelectionCollapsed({
  context
});
function isActiveDecorator(decorator) {
  return (snapshot) => {
    if (isSelectionExpanded(snapshot)) {
      const selectedSpans = getSelectedSpans(snapshot);
      return selectedSpans.length > 0 && selectedSpans.every((span) => span.node.marks?.includes(decorator));
    }
    return snapshot.context.activeDecorators.includes(decorator);
  };
}
function isActiveListItem(listItem) {
  return (snapshot) => getActiveListItem(snapshot) === listItem;
}
function isActiveStyle(style) {
  return (snapshot) => getActiveStyle(snapshot) === style;
}
function isAtTheEndOfBlock(block) {
  return ({
    context
  }) => {
    if (!context.selection || !isSelectionCollapsed({
      context
    }))
      return !1;
    const blockEndPoint = getBlockEndPoint(block);
    return isEqualSelectionPoints(context.selection.focus, blockEndPoint);
  };
}
function isAtTheStartOfBlock(block) {
  return ({
    context
  }) => {
    if (!context.selection || !isSelectionCollapsed({
      context
    }))
      return !1;
    const blockStartPoint = getBlockStartPoint(block);
    return isEqualSelectionPoints(context.selection.focus, blockStartPoint);
  };
}
export {
  createGuards,
  getActiveListItem,
  getActiveStyle,
  getFirstBlock,
  getFocusBlock,
  getFocusBlockObject,
  getFocusChild,
  getFocusListBlock,
  getFocusSpan,
  getFocusTextBlock,
  getLastBlock,
  getNextBlock,
  getPreviousBlock,
  getSelectedBlocks,
  getSelectedSpans,
  getSelectionEndBlock,
  getSelectionStartBlock,
  isActiveAnnotation,
  isActiveDecorator,
  isActiveListItem,
  isActiveStyle,
  isAtTheEndOfBlock,
  isAtTheStartOfBlock,
  isSelectionCollapsed,
  isSelectionExpanded
};
//# sourceMappingURL=selector.is-at-the-start-of-block.js.map

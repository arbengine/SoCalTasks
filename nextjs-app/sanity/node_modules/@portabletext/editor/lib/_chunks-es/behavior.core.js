import { isActiveAnnotation, getFocusBlockObject, getNextBlock, getPreviousBlock, isSelectionCollapsed, getFocusTextBlock, isActiveDecorator, isAtTheEndOfBlock, getFocusSpan, isAtTheStartOfBlock, isActiveListItem, getFocusListBlock, getSelectedBlocks, createGuards, isActiveStyle } from "./selector.is-at-the-start-of-block.js";
import { isPortableTextTextBlock } from "@sanity/types";
import { isEmptyTextBlock } from "./util.is-empty-text-block.js";
function isCustomBehaviorEvent(event) {
  return event.type.startsWith("custom.");
}
function raise(event) {
  return {
    type: "raise",
    event
  };
}
function defineBehavior(behavior) {
  return behavior;
}
const toggleAnnotationOff = {
  on: "annotation.toggle",
  guard: ({
    context,
    event
  }) => isActiveAnnotation(event.annotation.name)({
    context
  }),
  actions: [({
    event
  }) => [raise({
    type: "annotation.remove",
    annotation: event.annotation
  })]]
}, toggleAnnotationOn = {
  on: "annotation.toggle",
  guard: ({
    context,
    event
  }) => !isActiveAnnotation(event.annotation.name)({
    context
  }),
  actions: [({
    event
  }) => [raise({
    type: "annotation.add",
    annotation: event.annotation
  })]]
}, coreAnnotationBehaviors = {
  toggleAnnotationOff,
  toggleAnnotationOn
}, IS_MAC = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.userAgent), modifiers = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, aliases = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: IS_MAC ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, keyCodes = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222,
  f1: 112,
  f2: 113,
  f3: 114,
  f4: 115,
  f5: 116,
  f6: 117,
  f7: 118,
  f8: 119,
  f9: 120,
  f10: 121,
  f11: 122,
  f12: 123,
  f13: 124,
  f14: 125,
  f15: 126,
  f16: 127,
  f17: 128,
  f18: 129,
  f19: 130,
  f20: 131
};
function isHotkey(hotkey, event) {
  return compareHotkey(parseHotkey(hotkey), event);
}
function parseHotkey(hotkey) {
  const parsedHotkey = {
    altKey: !1,
    ctrlKey: !1,
    metaKey: !1,
    shiftKey: !1
  }, hotkeySegments = hotkey.replace("++", "+add").split("+");
  for (const rawHotkeySegment of hotkeySegments) {
    const optional = rawHotkeySegment.endsWith("?") && rawHotkeySegment.length > 1, hotkeySegment = optional ? rawHotkeySegment.slice(0, -1) : rawHotkeySegment, keyName = toKeyName(hotkeySegment), modifier = modifiers[keyName], alias = aliases[hotkeySegment], code = keyCodes[keyName];
    if (hotkeySegment.length > 1 && modifier === void 0 && alias === void 0 && code === void 0)
      throw new TypeError(`Unknown modifier: "${hotkeySegment}"`);
    (hotkeySegments.length === 1 || modifier === void 0) && (parsedHotkey.key = keyName, parsedHotkey.keyCode = toKeyCode(hotkeySegment)), modifier !== void 0 && (parsedHotkey[modifier] = optional ? null : !0);
  }
  return parsedHotkey;
}
function compareHotkey(parsedHotkey, event) {
  return (parsedHotkey.altKey == null || parsedHotkey.altKey === event.altKey) && (parsedHotkey.ctrlKey == null || parsedHotkey.ctrlKey === event.ctrlKey) && (parsedHotkey.metaKey == null || parsedHotkey.metaKey === event.metaKey) && (parsedHotkey.shiftKey == null || parsedHotkey.shiftKey === event.shiftKey) ? parsedHotkey.keyCode !== void 0 && event.keyCode !== void 0 ? parsedHotkey.keyCode === 91 && event.keyCode === 93 ? !0 : parsedHotkey.keyCode === event.keyCode : parsedHotkey.keyCode === event.keyCode || parsedHotkey.key === event.key.toLowerCase() : !1;
}
function toKeyCode(name) {
  const keyName = toKeyName(name);
  return keyCodes[keyName] ?? keyName.toUpperCase().charCodeAt(0);
}
function toKeyName(name) {
  const keyName = name.toLowerCase();
  return aliases[keyName] ?? keyName;
}
const arrowDownOnLonelyBlockObject = {
  on: "key.down",
  guard: ({
    context,
    event
  }) => {
    const isArrowDown = isHotkey("ArrowDown", event.keyboardEvent), focusBlockObject = getFocusBlockObject({
      context
    }), nextBlock = getNextBlock({
      context
    });
    return isArrowDown && focusBlockObject && !nextBlock;
  },
  actions: [() => [raise({
    type: "insert.text block",
    placement: "after"
  })]]
}, arrowUpOnLonelyBlockObject = {
  on: "key.down",
  guard: ({
    context,
    event
  }) => {
    const isArrowUp = isHotkey("ArrowUp", event.keyboardEvent), focusBlockObject = getFocusBlockObject({
      context
    }), previousBlock = getPreviousBlock({
      context
    });
    return isArrowUp && focusBlockObject && !previousBlock;
  },
  actions: [() => [raise({
    type: "insert.text block",
    placement: "before"
  }), raise({
    type: "select.previous block"
  })]]
}, breakingBlockObject = {
  on: "insert.break",
  guard: ({
    context
  }) => {
    const focusBlockObject = getFocusBlockObject({
      context
    });
    return isSelectionCollapsed({
      context
    }) && focusBlockObject !== void 0;
  },
  actions: [() => [raise({
    type: "insert.text block",
    placement: "after"
  })]]
}, deletingEmptyTextBlockAfterBlockObject = {
  on: "delete.backward",
  guard: ({
    context
  }) => {
    const focusTextBlock = getFocusTextBlock({
      context
    }), selectionCollapsed = isSelectionCollapsed({
      context
    }), previousBlock = getPreviousBlock({
      context
    });
    return !focusTextBlock || !selectionCollapsed || !previousBlock ? !1 : isEmptyTextBlock(focusTextBlock.node) && !isPortableTextTextBlock(previousBlock.node) ? {
      focusTextBlock,
      previousBlock
    } : !1;
  },
  actions: [(_, {
    focusTextBlock,
    previousBlock
  }) => [raise({
    type: "delete.block",
    blockPath: focusTextBlock.path
  }), raise({
    type: "select",
    selection: {
      anchor: {
        path: previousBlock.path,
        offset: 0
      },
      focus: {
        path: previousBlock.path,
        offset: 0
      }
    }
  })]]
}, deletingEmptyTextBlockBeforeBlockObject = {
  on: "delete.forward",
  guard: ({
    context
  }) => {
    const focusTextBlock = getFocusTextBlock({
      context
    }), selectionCollapsed = isSelectionCollapsed({
      context
    }), nextBlock = getNextBlock({
      context
    });
    return !focusTextBlock || !selectionCollapsed || !nextBlock ? !1 : isEmptyTextBlock(focusTextBlock.node) && !isPortableTextTextBlock(nextBlock.node) ? {
      focusTextBlock,
      nextBlock
    } : !1;
  },
  actions: [(_, {
    focusTextBlock,
    nextBlock
  }) => [raise({
    type: "delete.block",
    blockPath: focusTextBlock.path
  }), raise({
    type: "select",
    selection: {
      anchor: {
        path: nextBlock.path,
        offset: 0
      },
      focus: {
        path: nextBlock.path,
        offset: 0
      }
    }
  })]]
}, coreBlockObjectBehaviors = {
  arrowDownOnLonelyBlockObject,
  arrowUpOnLonelyBlockObject,
  breakingBlockObject,
  deletingEmptyTextBlockAfterBlockObject,
  deletingEmptyTextBlockBeforeBlockObject
}, coreDecoratorBehaviors = {
  toggleDecoratorOff: {
    on: "decorator.toggle",
    guard: ({
      context,
      event
    }) => isActiveDecorator(event.decorator)({
      context
    }),
    actions: [({
      event
    }) => [raise({
      type: "decorator.remove",
      decorator: event.decorator
    })]]
  },
  toggleDecoratorOn: {
    on: "decorator.toggle",
    guard: ({
      context,
      event
    }) => !isActiveDecorator(event.decorator)({
      context
    }),
    actions: [({
      event
    }) => [raise({
      type: "decorator.add",
      decorator: event.decorator
    })]]
  },
  strongShortcut: {
    on: "key.down",
    guard: ({
      context,
      event
    }) => isHotkey("mod+b", event.keyboardEvent) && context.schema.decorators.some((decorator) => decorator.value === "strong"),
    actions: [() => [raise({
      type: "decorator.toggle",
      decorator: "strong"
    })]]
  },
  emShortcut: {
    on: "key.down",
    guard: ({
      context,
      event
    }) => isHotkey("mod+i", event.keyboardEvent) && context.schema.decorators.some((decorator) => decorator.value === "em"),
    actions: [() => [raise({
      type: "decorator.toggle",
      decorator: "em"
    })]]
  },
  underlineShortcut: {
    on: "key.down",
    guard: ({
      context,
      event
    }) => isHotkey("mod+u", event.keyboardEvent) && context.schema.decorators.some((decorator) => decorator.value === "underline"),
    actions: [() => [raise({
      type: "decorator.toggle",
      decorator: "underline"
    })]]
  },
  codeShortcut: {
    on: "key.down",
    guard: ({
      context,
      event
    }) => isHotkey("mod+'", event.keyboardEvent) && context.schema.decorators.some((decorator) => decorator.value === "code"),
    actions: [() => [raise({
      type: "decorator.toggle",
      decorator: "code"
    })]]
  }
}, coreDeserializeBehavior = {
  on: "deserialize",
  guard: ({
    context,
    event
  }) => {
    const deserializeEvents = context.converters.flatMap((converter) => {
      const data = event.dataTransfer.getData(converter.mimeType);
      return data ? [converter.deserialize({
        context,
        event: {
          type: "deserialize",
          data
        }
      })] : [];
    });
    return deserializeEvents.find((deserializeEvent) => deserializeEvent.type === "deserialization.success") || {
      type: "deserialization.failure",
      mimeType: "*/*",
      reason: deserializeEvents.map((deserializeEvent) => deserializeEvent.type === "deserialization.failure" ? deserializeEvent.reason : "").join(", ")
    };
  },
  actions: [({
    event
  }, deserializeEvent) => [raise({
    ...deserializeEvent,
    dataTransfer: event.dataTransfer
  })]]
}, atTheEndOfTextBlock = {
  on: "insert.break",
  guard: ({
    context
  }) => {
    const focusTextBlock = getFocusTextBlock({
      context
    }), selectionCollapsed = isSelectionCollapsed({
      context
    });
    if (!context.selection || !focusTextBlock || !selectionCollapsed)
      return !1;
    const atTheEndOfBlock = isAtTheEndOfBlock(focusTextBlock)({
      context
    }), focusListItem = focusTextBlock.node.listItem, focusLevel = focusTextBlock.node.level;
    return atTheEndOfBlock ? {
      focusListItem,
      focusLevel
    } : !1;
  },
  actions: [({
    context
  }, {
    focusListItem,
    focusLevel
  }) => [raise({
    type: "insert.block",
    block: {
      _type: context.schema.block.name,
      _key: context.keyGenerator(),
      children: [{
        _key: context.keyGenerator(),
        _type: context.schema.span.name,
        text: "",
        marks: []
      }],
      markDefs: [],
      listItem: focusListItem,
      level: focusLevel,
      style: context.schema.styles[0]?.value
    },
    placement: "after"
  })]]
}, atTheStartOfTextBlock = {
  on: "insert.break",
  guard: ({
    context
  }) => {
    const focusTextBlock = getFocusTextBlock({
      context
    }), selectionCollapsed = isSelectionCollapsed({
      context
    });
    if (!context.selection || !focusTextBlock || !selectionCollapsed)
      return !1;
    const focusSpan = getFocusSpan({
      context
    }), focusDecorators = focusSpan?.node.marks?.filter((mark) => context.schema.decorators.some((decorator) => decorator.value === mark) ?? []), focusAnnotations = focusSpan?.node.marks?.filter((mark) => !context.schema.decorators.some((decorator) => decorator.value === mark)) ?? [], focusListItem = focusTextBlock.node.listItem, focusLevel = focusTextBlock.node.level;
    return isAtTheStartOfBlock(focusTextBlock)({
      context
    }) ? {
      focusAnnotations,
      focusDecorators,
      focusListItem,
      focusLevel
    } : !1;
  },
  actions: [({
    context
  }, {
    focusAnnotations,
    focusDecorators,
    focusListItem,
    focusLevel
  }) => [raise({
    type: "insert.block",
    block: {
      _key: context.keyGenerator(),
      _type: context.schema.block.name,
      children: [{
        _key: context.keyGenerator(),
        _type: context.schema.span.name,
        marks: focusAnnotations.length === 0 ? focusDecorators : [],
        text: ""
      }],
      listItem: focusListItem,
      level: focusLevel,
      style: context.schema.styles[0]?.value
    },
    placement: "before"
  })]]
}, coreInsertBreakBehaviors = {
  atTheEndOfTextBlock,
  atTheStartOfTextBlock
}, MAX_LIST_LEVEL = 10, toggleListItemOff = {
  on: "list item.toggle",
  guard: ({
    context,
    event
  }) => isActiveListItem(event.listItem)({
    context
  }),
  actions: [({
    event
  }) => [raise({
    type: "list item.remove",
    listItem: event.listItem
  })]]
}, toggleListItemOn = {
  on: "list item.toggle",
  guard: ({
    context,
    event
  }) => !isActiveListItem(event.listItem)({
    context
  }),
  actions: [({
    event
  }) => [raise({
    type: "list item.add",
    listItem: event.listItem
  })]]
}, clearListOnBackspace = {
  on: "delete.backward",
  guard: ({
    context
  }) => {
    const selectionCollapsed = isSelectionCollapsed({
      context
    }), focusTextBlock = getFocusTextBlock({
      context
    }), focusSpan = getFocusSpan({
      context
    });
    return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && context.selection?.focus.offset === 0 && focusTextBlock.node.level === 1 ? {
      focusTextBlock
    } : !1;
  },
  actions: [(_, {
    focusTextBlock
  }) => [raise({
    type: "text block.unset",
    props: ["listItem", "level"],
    at: focusTextBlock.path
  })]]
}, unindentListOnBackspace = {
  on: "delete.backward",
  guard: ({
    context
  }) => {
    const selectionCollapsed = isSelectionCollapsed({
      context
    }), focusTextBlock = getFocusTextBlock({
      context
    }), focusSpan = getFocusSpan({
      context
    });
    return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && context.selection?.focus.offset === 0 && focusTextBlock.node.level !== void 0 && focusTextBlock.node.level > 1 ? {
      focusTextBlock,
      level: focusTextBlock.node.level - 1
    } : !1;
  },
  actions: [(_, {
    focusTextBlock,
    level
  }) => [raise({
    type: "text block.set",
    level,
    at: focusTextBlock.path
  })]]
}, clearListOnEnter = {
  on: "insert.break",
  guard: ({
    context
  }) => {
    const selectionCollapsed = isSelectionCollapsed({
      context
    }), focusListBlock = getFocusListBlock({
      context
    });
    return !selectionCollapsed || !focusListBlock || !isEmptyTextBlock(focusListBlock.node) ? !1 : {
      focusListBlock
    };
  },
  actions: [(_, {
    focusListBlock
  }) => [raise({
    type: "text block.unset",
    props: ["listItem", "level"],
    at: focusListBlock.path
  })]]
}, indentListOnTab = {
  on: "key.down",
  guard: ({
    context,
    event
  }) => {
    if (!isHotkey("Tab", event.keyboardEvent))
      return !1;
    const selectedBlocks = getSelectedBlocks({
      context
    }), guards = createGuards(context), selectedListBlocks = selectedBlocks.flatMap((block) => guards.isListBlock(block.node) ? [{
      node: block.node,
      path: block.path
    }] : []);
    return selectedListBlocks.length === selectedBlocks.length ? {
      selectedListBlocks
    } : !1;
  },
  actions: [(_, {
    selectedListBlocks
  }) => selectedListBlocks.map((selectedListBlock) => raise({
    type: "text block.set",
    level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level + 1)),
    at: selectedListBlock.path
  }))]
}, unindentListOnShiftTab = {
  on: "key.down",
  guard: ({
    context,
    event
  }) => {
    if (!isHotkey("Shift+Tab", event.keyboardEvent))
      return !1;
    const selectedBlocks = getSelectedBlocks({
      context
    }), guards = createGuards(context), selectedListBlocks = selectedBlocks.flatMap((block) => guards.isListBlock(block.node) ? [{
      node: block.node,
      path: block.path
    }] : []);
    return selectedListBlocks.length === selectedBlocks.length ? {
      selectedListBlocks
    } : !1;
  },
  actions: [(_, {
    selectedListBlocks
  }) => selectedListBlocks.map((selectedListBlock) => raise({
    type: "text block.set",
    level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level - 1)),
    at: selectedListBlock.path
  }))]
}, coreListBehaviors = {
  toggleListItemOff,
  toggleListItemOn,
  clearListOnBackspace,
  unindentListOnBackspace,
  clearListOnEnter,
  indentListOnTab,
  unindentListOnShiftTab
}, coreSerializeBehaviors = {
  serialize: {
    on: "serialize",
    guard: ({
      context,
      event
    }) => {
      if (context.converters.length === 0)
        return !1;
      const serializeEvents = context.converters.map((converter) => converter.serialize({
        context,
        event
      }));
      return serializeEvents.length === 0 ? !1 : serializeEvents;
    },
    actions: [({
      event
    }, serializeEvents) => serializeEvents.map((serializeEvent) => raise({
      ...serializeEvent,
      dataTransfer: event.dataTransfer
    }))]
  },
  "serialization.success": {
    on: "serialization.success",
    actions: [({
      event
    }) => [raise({
      type: "data transfer.set",
      data: event.data,
      dataTransfer: event.dataTransfer,
      mimeType: event.mimeType
    })]]
  }
}, toggleStyleOff = {
  on: "style.toggle",
  guard: ({
    context,
    event
  }) => isActiveStyle(event.style)({
    context
  }),
  actions: [({
    event
  }) => [raise({
    type: "style.remove",
    style: event.style
  })]]
}, toggleStyleOn = {
  on: "style.toggle",
  guard: ({
    context,
    event
  }) => !isActiveStyle(event.style)({
    context
  }),
  actions: [({
    event
  }) => [raise({
    type: "style.add",
    style: event.style
  })]]
}, coreStyleBehaviors = {
  toggleStyleOff,
  toggleStyleOn
}, softReturn = {
  on: "insert.soft break",
  actions: [() => [raise({
    type: "insert.text",
    text: `
`
  })]]
}, coreBehaviors = [softReturn, coreAnnotationBehaviors.toggleAnnotationOff, coreAnnotationBehaviors.toggleAnnotationOn, coreDecoratorBehaviors.toggleDecoratorOff, coreDecoratorBehaviors.toggleDecoratorOn, coreDecoratorBehaviors.strongShortcut, coreDecoratorBehaviors.emShortcut, coreDecoratorBehaviors.underlineShortcut, coreDecoratorBehaviors.codeShortcut, coreDeserializeBehavior, coreBlockObjectBehaviors.arrowDownOnLonelyBlockObject, coreBlockObjectBehaviors.arrowUpOnLonelyBlockObject, coreBlockObjectBehaviors.breakingBlockObject, coreBlockObjectBehaviors.deletingEmptyTextBlockAfterBlockObject, coreBlockObjectBehaviors.deletingEmptyTextBlockBeforeBlockObject, coreListBehaviors.toggleListItemOff, coreListBehaviors.toggleListItemOn, coreListBehaviors.clearListOnBackspace, coreListBehaviors.unindentListOnBackspace, coreListBehaviors.clearListOnEnter, coreListBehaviors.indentListOnTab, coreListBehaviors.unindentListOnShiftTab, coreInsertBreakBehaviors.atTheEndOfTextBlock, coreInsertBreakBehaviors.atTheStartOfTextBlock, coreSerializeBehaviors.serialize, coreSerializeBehaviors["serialization.success"], coreStyleBehaviors.toggleStyleOff, coreStyleBehaviors.toggleStyleOn], coreBehavior = {
  softReturn,
  annotation: coreAnnotationBehaviors,
  decorators: coreDecoratorBehaviors,
  deserialize: coreDeserializeBehavior,
  blockObjects: coreBlockObjectBehaviors,
  insertBreak: coreInsertBreakBehaviors,
  lists: coreListBehaviors,
  ...coreSerializeBehaviors,
  style: coreSerializeBehaviors
};
export {
  coreBehavior,
  coreBehaviors,
  defineBehavior,
  isCustomBehaviorEvent,
  isHotkey,
  raise
};
//# sourceMappingURL=behavior.core.js.map

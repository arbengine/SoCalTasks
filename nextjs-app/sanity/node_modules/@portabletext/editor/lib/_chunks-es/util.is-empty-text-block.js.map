{"version":3,"file":"util.is-empty-text-block.js","sources":["../../src/utils/util.block-offset.ts","../../src/utils/util.get-text-block-text.ts","../../src/utils/util.is-empty-text-block.ts"],"sourcesContent":["import {\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextBlock,\n} from '@sanity/types'\nimport type {BlockOffset} from '../behaviors/behavior.types'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {isKeyedSegment} from './util.is-keyed-segment'\n\n/**\n * @public\n */\nexport function blockOffsetToSpanSelectionPoint({\n  value,\n  blockOffset,\n}: {\n  value: Array<PortableTextBlock>\n  blockOffset: BlockOffset\n}) {\n  let offsetLeft = blockOffset.offset\n  let selectionPoint:\n    | {path: [KeyedSegment, 'children', KeyedSegment]; offset: number}\n    | undefined\n\n  for (const block of value) {\n    if (block._key !== blockOffset.path[0]._key) {\n      continue\n    }\n\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (!isPortableTextSpan(child)) {\n        continue\n      }\n\n      if (offsetLeft === 0) {\n        selectionPoint = {\n          path: [...blockOffset.path, 'children', {_key: child._key}],\n          offset: 0,\n        }\n        break\n      }\n\n      if (offsetLeft <= child.text.length) {\n        selectionPoint = {\n          path: [...blockOffset.path, 'children', {_key: child._key}],\n          offset: offsetLeft,\n        }\n        break\n      }\n\n      offsetLeft -= child.text.length\n    }\n  }\n\n  return selectionPoint\n}\n\n/**\n * @public\n */\nexport function spanSelectionPointToBlockOffset({\n  value,\n  selectionPoint,\n}: {\n  value: Array<PortableTextBlock>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  let offset = 0\n\n  const blockKey = isKeyedSegment(selectionPoint.path[0])\n    ? selectionPoint.path[0]._key\n    : undefined\n  const spanKey = isKeyedSegment(selectionPoint.path[2])\n    ? selectionPoint.path[2]._key\n    : undefined\n\n  if (!blockKey || !spanKey) {\n    return undefined\n  }\n\n  for (const block of value) {\n    if (block._key !== blockKey) {\n      continue\n    }\n\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (!isPortableTextSpan(child)) {\n        continue\n      }\n\n      if (child._key === spanKey) {\n        return {\n          path: [{_key: block._key}],\n          offset: offset + selectionPoint.offset,\n        }\n      }\n\n      offset += child.text.length\n    }\n  }\n}\n","import type {PortableTextTextBlock} from '@sanity/types'\n\n/**\n * @public\n */\nexport function getTextBlockText(block: PortableTextTextBlock) {\n  return block.children.map((child) => child.text ?? '').join('')\n}\n","import {\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type PortableTextBlock,\n} from '@sanity/types'\nimport {getTextBlockText} from './util.get-text-block-text'\n\n/**\n * @public\n */\nexport function isEmptyTextBlock(block: PortableTextBlock) {\n  if (!isPortableTextTextBlock(block)) {\n    return false\n  }\n\n  const onlyText = block.children.every(isPortableTextSpan)\n  const blockText = getTextBlockText(block)\n\n  return onlyText && blockText === ''\n}\n"],"names":["blockOffsetToSpanSelectionPoint","value","blockOffset","offsetLeft","offset","selectionPoint","block","_key","path","isPortableTextTextBlock","child","children","isPortableTextSpan","text","length","spanSelectionPointToBlockOffset","blockKey","isKeyedSegment","undefined","spanKey","getTextBlockText","map","join","isEmptyTextBlock","onlyText","every","blockText"],"mappings":";;AAaO,SAASA,gCAAgC;AAAA,EAC9CC;AAAAA,EACAC;AAIF,GAAG;AACGC,MAAAA,aAAaD,YAAYE,QACzBC;AAIJ,aAAWC,SAASL;AACdK,QAAAA,MAAMC,SAASL,YAAYM,KAAK,CAAC,EAAED,QAIlCE,wBAAwBH,KAAK;AAIlC,iBAAWI,SAASJ,MAAMK;AACnBC,YAAAA,mBAAmBF,KAAK,GAI7B;AAAA,cAAIP,eAAe,GAAG;AACH,6BAAA;AAAA,cACfK,MAAM,CAAC,GAAGN,YAAYM,MAAM,YAAY;AAAA,gBAACD,MAAMG,MAAMH;AAAAA,cAAAA,CAAK;AAAA,cAC1DH,QAAQ;AAAA,YACV;AACA;AAAA,UAAA;AAGED,cAAAA,cAAcO,MAAMG,KAAKC,QAAQ;AAClB,6BAAA;AAAA,cACfN,MAAM,CAAC,GAAGN,YAAYM,MAAM,YAAY;AAAA,gBAACD,MAAMG,MAAMH;AAAAA,cAAAA,CAAK;AAAA,cAC1DH,QAAQD;AAAAA,YACV;AACA;AAAA,UAAA;AAGFA,wBAAcO,MAAMG,KAAKC;AAAAA,QAAAA;AAAAA;AAItBT,SAAAA;AACT;AAKO,SAASU,gCAAgC;AAAA,EAC9Cd;AAAAA,EACAI;AAIF,GAA4B;AAC1B,MAAID,SAAS;AAEPY,QAAAA,WAAWC,eAAeZ,eAAeG,KAAK,CAAC,CAAC,IAClDH,eAAeG,KAAK,CAAC,EAAED,OACvBW,QACEC,UAAUF,eAAeZ,eAAeG,KAAK,CAAC,CAAC,IACjDH,eAAeG,KAAK,CAAC,EAAED,OACvBW;AAEA,MAAA,EAAA,CAACF,YAAY,CAACG;AAIlB,eAAWb,SAASL;AAClB,UAAIK,MAAMC,SAASS,YAIdP,wBAAwBH,KAAK;AAIlC,mBAAWI,SAASJ,MAAMK;AACnBC,cAAAA,mBAAmBF,KAAK,GAI7B;AAAA,gBAAIA,MAAMH,SAASY;AACV,qBAAA;AAAA,gBACLX,MAAM,CAAC;AAAA,kBAACD,MAAMD,MAAMC;AAAAA,gBAAAA,CAAK;AAAA,gBACzBH,QAAQA,SAASC,eAAeD;AAAAA,cAClC;AAGFA,sBAAUM,MAAMG,KAAKC;AAAAA,UAAAA;AAAAA;AAAAA;AAG3B;ACxGO,SAASM,iBAAiBd,OAA8B;AACtDA,SAAAA,MAAMK,SAASU,IAAKX,CAAAA,UAAUA,MAAMG,QAAQ,EAAE,EAAES,KAAK,EAAE;AAChE;ACGO,SAASC,iBAAiBjB,OAA0B;AACrD,MAAA,CAACG,wBAAwBH,KAAK;AACzB,WAAA;AAGHkB,QAAAA,WAAWlB,MAAMK,SAASc,MAAMb,kBAAkB,GAClDc,YAAYN,iBAAiBd,KAAK;AAExC,SAAOkB,YAAYE,cAAc;AACnC;"}
{"version":3,"file":"selector.get-text-before.js","sources":["../../src/selectors/selector.get-selection-text.ts","../../src/selectors/selector.get-text-before.ts"],"sourcesContent":["import {isPortableTextSpan, isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\nimport {reverseSelection} from '../utils/util.reverse-selection'\n\n/**\n * @public\n */\nexport const getSelectionText: EditorSelector<string> = ({context}) => {\n  let text = ''\n\n  const {value, selection} = context\n\n  if (!value || !selection) {\n    return text\n  }\n\n  const forwardSelection = selection.backward\n    ? reverseSelection(selection)\n    : selection\n\n  if (!forwardSelection) {\n    return text\n  }\n\n  for (const block of value) {\n    if (\n      isKeyedSegment(forwardSelection.anchor.path[0]) &&\n      block._key !== forwardSelection.anchor.path[0]._key\n    ) {\n      continue\n    }\n\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (isPortableTextSpan(child)) {\n        if (\n          isKeyedSegment(forwardSelection.anchor.path[2]) &&\n          child._key === forwardSelection.anchor.path[2]._key &&\n          isKeyedSegment(forwardSelection.focus.path[2]) &&\n          child._key === forwardSelection.focus.path[2]._key\n        ) {\n          text =\n            text +\n            child.text.slice(\n              forwardSelection.anchor.offset,\n              forwardSelection.focus.offset,\n            )\n\n          break\n        }\n\n        if (\n          isKeyedSegment(forwardSelection.anchor.path[2]) &&\n          child._key === forwardSelection.anchor.path[2]._key\n        ) {\n          text = text + child.text.slice(forwardSelection.anchor.offset)\n          continue\n        }\n\n        if (\n          isKeyedSegment(forwardSelection.focus.path[2]) &&\n          child._key === forwardSelection.focus.path[2]._key\n        ) {\n          text = text + child.text.slice(0, forwardSelection.focus.offset)\n          break\n        }\n\n        if (text.length > 0) {\n          text = text + child.text\n        }\n      }\n    }\n\n    if (\n      isKeyedSegment(forwardSelection.focus.path[0]) &&\n      block._key === forwardSelection.focus.path[0]._key\n    ) {\n      break\n    }\n  }\n\n  return text\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getBlockStartPoint} from '../utils/util.get-block-start-point'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\nimport {reverseSelection} from '../utils/util.reverse-selection'\nimport {getSelectionText} from './selector.get-selection-text'\n\n/**\n * @public\n */\nexport const getBlockTextBefore: EditorSelector<string> = ({context}) => {\n  if (!context.selection) {\n    return ''\n  }\n\n  const selection = context.selection.backward\n    ? reverseSelection(context.selection)\n    : context.selection\n  const point = selection.anchor\n  const key = isKeyedSegment(point.path[0]) ? point.path[0]._key : undefined\n\n  const block = key\n    ? context.value.find((block) => block._key === key)\n    : undefined\n\n  if (!block) {\n    return ''\n  }\n\n  const startOfBlock = getBlockStartPoint({\n    node: block,\n    path: [{_key: block._key}],\n  })\n\n  return getSelectionText({\n    context: {\n      ...context,\n      value: context.value,\n      selection: {\n        anchor: startOfBlock,\n        focus: point,\n      },\n    },\n  })\n}\n"],"names":["getSelectionText","context","text","value","selection","forwardSelection","backward","reverseSelection","block","isKeyedSegment","anchor","path","_key","isPortableTextTextBlock","child","children","isPortableTextSpan","focus","slice","offset","length","getBlockTextBefore","point","key","undefined","find","startOfBlock","getBlockStartPoint","node"],"mappings":";;;AAQO,MAAMA,mBAA2CA,CAAC;AAAA,EAACC;AAAO,MAAM;AACrE,MAAIC,OAAO;AAEL,QAAA;AAAA,IAACC;AAAAA,IAAOC;AAAAA,EAAAA,IAAaH;AAEvB,MAAA,CAACE,SAAS,CAACC;AACNF,WAAAA;AAGT,QAAMG,mBAAmBD,UAAUE,WAC/BC,iBAAiBH,SAAS,IAC1BA;AAEJ,MAAI,CAACC;AACIH,WAAAA;AAGT,aAAWM,SAASL;AAClB,QACEM,iBAAeJ,iBAAiBK,OAAOC,KAAK,CAAC,CAAC,KAC9CH,MAAMI,SAASP,iBAAiBK,OAAOC,KAAK,CAAC,EAAEC,SAK5CC,wBAAwBL,KAAK,GAIlC;AAAA,iBAAWM,SAASN,MAAMO;AACpBC,YAAAA,mBAAmBF,KAAK,GAAG;AAC7B,cACEL,eAAeJ,iBAAiBK,OAAOC,KAAK,CAAC,CAAC,KAC9CG,MAAMF,SAASP,iBAAiBK,OAAOC,KAAK,CAAC,EAAEC,QAC/CH,eAAeJ,iBAAiBY,MAAMN,KAAK,CAAC,CAAC,KAC7CG,MAAMF,SAASP,iBAAiBY,MAAMN,KAAK,CAAC,EAAEC,MAC9C;AAEEV,mBAAAA,OACAY,MAAMZ,KAAKgB,MACTb,iBAAiBK,OAAOS,QACxBd,iBAAiBY,MAAME,MACzB;AAEF;AAAA,UAAA;AAGF,cACEV,eAAeJ,iBAAiBK,OAAOC,KAAK,CAAC,CAAC,KAC9CG,MAAMF,SAASP,iBAAiBK,OAAOC,KAAK,CAAC,EAAEC,MAC/C;AACAV,mBAAOA,OAAOY,MAAMZ,KAAKgB,MAAMb,iBAAiBK,OAAOS,MAAM;AAC7D;AAAA,UAAA;AAGF,cACEV,eAAeJ,iBAAiBY,MAAMN,KAAK,CAAC,CAAC,KAC7CG,MAAMF,SAASP,iBAAiBY,MAAMN,KAAK,CAAC,EAAEC,MAC9C;AACAV,mBAAOA,OAAOY,MAAMZ,KAAKgB,MAAM,GAAGb,iBAAiBY,MAAME,MAAM;AAC/D;AAAA,UAAA;AAGEjB,eAAKkB,SAAS,MAChBlB,OAAOA,OAAOY,MAAMZ;AAAAA,QAAAA;AAK1B,UACEO,eAAeJ,iBAAiBY,MAAMN,KAAK,CAAC,CAAC,KAC7CH,MAAMI,SAASP,iBAAiBY,MAAMN,KAAK,CAAC,EAAEC;AAE9C;AAAA,IAAA;AAIGV,SAAAA;AACT,GC7EamB,qBAA6CA,CAAC;AAAA,EAACpB;AAAO,MAAM;AACvE,MAAI,CAACA,QAAQG;AACJ,WAAA;AAMT,QAAMkB,SAHYrB,QAAQG,UAAUE,WAChCC,iBAAiBN,QAAQG,SAAS,IAClCH,QAAQG,WACYM,QAClBa,MAAMd,eAAea,MAAMX,KAAK,CAAC,CAAC,IAAIW,MAAMX,KAAK,CAAC,EAAEC,OAAOY,QAE3DhB,QAAQe,MACVtB,QAAQE,MAAMsB,KAAMjB,CAAAA,WAAUA,OAAMI,SAASW,GAAG,IAChDC;AAEJ,MAAI,CAAChB;AACI,WAAA;AAGT,QAAMkB,eAAeC,mBAAmB;AAAA,IACtCC,MAAMpB;AAAAA,IACNG,MAAM,CAAC;AAAA,MAACC,MAAMJ,MAAMI;AAAAA,IAAK,CAAA;AAAA,EAAA,CAC1B;AAED,SAAOZ,iBAAiB;AAAA,IACtBC,SAAS;AAAA,MACP,GAAGA;AAAAA,MACHE,OAAOF,QAAQE;AAAAA,MACfC,WAAW;AAAA,QACTM,QAAQgB;AAAAA,QACRT,OAAOK;AAAAA,MAAAA;AAAAA,IACT;AAAA,EACF,CACD;AACH;"}
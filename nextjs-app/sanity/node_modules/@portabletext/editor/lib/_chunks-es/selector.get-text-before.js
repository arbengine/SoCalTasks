import { isKeyedSegment, getBlockStartPoint } from "./util.is-equal-selection-points.js";
import { reverseSelection } from "./util.reverse-selection.js";
import { isPortableTextTextBlock, isPortableTextSpan } from "@sanity/types";
const getSelectionText = ({
  context
}) => {
  let text = "";
  const {
    value,
    selection
  } = context;
  if (!value || !selection)
    return text;
  const forwardSelection = selection.backward ? reverseSelection(selection) : selection;
  if (!forwardSelection)
    return text;
  for (const block of value)
    if (!(isKeyedSegment(forwardSelection.anchor.path[0]) && block._key !== forwardSelection.anchor.path[0]._key) && isPortableTextTextBlock(block)) {
      for (const child of block.children)
        if (isPortableTextSpan(child)) {
          if (isKeyedSegment(forwardSelection.anchor.path[2]) && child._key === forwardSelection.anchor.path[2]._key && isKeyedSegment(forwardSelection.focus.path[2]) && child._key === forwardSelection.focus.path[2]._key) {
            text = text + child.text.slice(forwardSelection.anchor.offset, forwardSelection.focus.offset);
            break;
          }
          if (isKeyedSegment(forwardSelection.anchor.path[2]) && child._key === forwardSelection.anchor.path[2]._key) {
            text = text + child.text.slice(forwardSelection.anchor.offset);
            continue;
          }
          if (isKeyedSegment(forwardSelection.focus.path[2]) && child._key === forwardSelection.focus.path[2]._key) {
            text = text + child.text.slice(0, forwardSelection.focus.offset);
            break;
          }
          text.length > 0 && (text = text + child.text);
        }
      if (isKeyedSegment(forwardSelection.focus.path[0]) && block._key === forwardSelection.focus.path[0]._key)
        break;
    }
  return text;
}, getBlockTextBefore = ({
  context
}) => {
  if (!context.selection)
    return "";
  const point = (context.selection.backward ? reverseSelection(context.selection) : context.selection).anchor, key = isKeyedSegment(point.path[0]) ? point.path[0]._key : void 0, block = key ? context.value.find((block2) => block2._key === key) : void 0;
  if (!block)
    return "";
  const startOfBlock = getBlockStartPoint({
    node: block,
    path: [{
      _key: block._key
    }]
  });
  return getSelectionText({
    context: {
      ...context,
      value: context.value,
      selection: {
        anchor: startOfBlock,
        focus: point
      }
    }
  });
};
export {
  getBlockTextBefore,
  getSelectionText
};
//# sourceMappingURL=selector.get-text-before.js.map

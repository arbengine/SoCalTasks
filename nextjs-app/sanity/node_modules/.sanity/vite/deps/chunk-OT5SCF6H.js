import {
  EMPTY,
  assertEvent,
  assign,
  bufferCount,
  concatMap,
  createActor,
  defer,
  emit,
  enqueueActions,
  filter,
  fromCallback,
  fromEvent,
  fromEventObservable,
  map,
  pipe,
  raise,
  sendTo,
  setup,
  stopChild,
  take,
  takeUntil
} from "./chunk-ZOF6MRAE.js";

// node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reKeySegment = /_key\s*==\s*['"](.*)['"]/;
var reIndexTuple = /^\d*:\d*$/;
function isIndexSegment(segment) {
  return typeof segment == "number" || typeof segment == "string" && /^\[\d+\]$/.test(segment);
}
function isKeySegment(segment) {
  return typeof segment == "string" ? reKeySegment.test(segment.trim()) : typeof segment == "object" && "_key" in segment;
}
function isIndexTuple(segment) {
  if (typeof segment == "string" && reIndexTuple.test(segment))
    return true;
  if (!Array.isArray(segment) || segment.length !== 2)
    return false;
  const [from, to] = segment;
  return (typeof from == "number" || from === "") && (typeof to == "number" || to === "");
}
function get(obj, path, defaultVal) {
  const select = typeof path == "string" ? fromString(path) : path;
  if (!Array.isArray(select))
    throw new Error("Path must be an array or a string");
  let acc = obj;
  for (let i = 0; i < select.length; i++) {
    const segment = select[i];
    if (isIndexSegment(segment)) {
      if (!Array.isArray(acc))
        return defaultVal;
      acc = acc[segment];
    }
    if (isKeySegment(segment)) {
      if (!Array.isArray(acc))
        return defaultVal;
      acc = acc.find((item) => item._key === segment._key);
    }
    if (typeof segment == "string" && (acc = typeof acc == "object" && acc !== null ? acc[segment] : void 0), typeof acc > "u")
      return defaultVal;
  }
  return acc;
}
function toString(path) {
  if (!Array.isArray(path))
    throw new Error("Path is not an array");
  return path.reduce((target, segment, i) => {
    const segmentType = typeof segment;
    if (segmentType === "number")
      return `${target}[${segment}]`;
    if (segmentType === "string")
      return `${target}${i === 0 ? "" : "."}${segment}`;
    if (isKeySegment(segment) && segment._key)
      return `${target}[_key=="${segment._key}"]`;
    if (Array.isArray(segment)) {
      const [from, to] = segment;
      return `${target}[${from}:${to}]`;
    }
    throw new Error(`Unsupported path segment \`${JSON.stringify(segment)}\``);
  }, "");
}
function fromString(path) {
  if (typeof path != "string")
    throw new Error("Path is not a string");
  const segments = path.match(rePropName);
  if (!segments)
    throw new Error("Invalid path string");
  return segments.map(parsePathSegment);
}
function parsePathSegment(segment) {
  return isIndexSegment(segment) ? parseIndexSegment(segment) : isKeySegment(segment) ? parseKeySegment(segment) : isIndexTuple(segment) ? parseIndexTupleSegment(segment) : segment;
}
function parseIndexSegment(segment) {
  return Number(segment.replace(/[^\d]/g, ""));
}
function parseKeySegment(segment) {
  return { _key: segment.match(reKeySegment)[1] };
}
function parseIndexTupleSegment(segment) {
  const [from, to] = segment.split(":").map((seg) => seg === "" ? seg : Number(seg));
  return [from, to];
}
var studioPath = Object.freeze({
  __proto__: null,
  fromString,
  get,
  isIndexSegment,
  isIndexTuple,
  isKeySegment,
  reKeySegment,
  toString
});
var DRAFTS_FOLDER = "drafts";
var VERSION_FOLDER = "versions";
var PATH_SEPARATOR = ".";
var DRAFTS_PREFIX = `${DRAFTS_FOLDER}${PATH_SEPARATOR}`;
var VERSION_PREFIX = `${VERSION_FOLDER}${PATH_SEPARATOR}`;
function isDraftId(id) {
  return id.startsWith(DRAFTS_PREFIX);
}
function isVersionId(id) {
  return id.startsWith(VERSION_PREFIX);
}
function getDraftId(id) {
  if (isVersionId(id)) {
    const publishedId = getPublishedId(id);
    return DRAFTS_PREFIX + publishedId;
  }
  return isDraftId(id) ? id : DRAFTS_PREFIX + id;
}
function getVersionId(id, version) {
  if (version === "drafts" || version === "published")
    throw new Error('Version can not be "published" or "drafts"');
  return `${VERSION_PREFIX}${version}${PATH_SEPARATOR}${getPublishedId(id)}`;
}
function getPublishedId(id) {
  return isVersionId(id) ? id.split(PATH_SEPARATOR).slice(2).join(PATH_SEPARATOR) : isDraftId(id) ? id.slice(DRAFTS_PREFIX.length) : id;
}
var ESCAPE = {
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "'": "\\'",
  "\\": "\\\\"
};
var UNESCAPE = {
  "\\f": "\f",
  "\\n": `
`,
  "\\r": "\r",
  "\\t": "	",
  "\\'": "'",
  "\\\\": "\\"
};
function jsonPath(path) {
  return `$${path.map((segment) => typeof segment == "string" ? `['${segment.replace(/[\f\n\r\t'\\]/g, (match) => ESCAPE[match])}']` : typeof segment == "number" ? `[${segment}]` : segment._key !== "" ? `[?(@._key=='${segment._key.replace(/['\\]/g, (match) => ESCAPE[match])}')]` : `[${segment._index}]`).join("")}`;
}
function parseJsonPath(path) {
  const parsed = [], parseRe = /\['(.*?)'\]|\[(\d+)\]|\[\?\(@\._key=='(.*?)'\)\]/g;
  let match;
  for (; (match = parseRe.exec(path)) !== null; ) {
    if (match[1] !== void 0) {
      const key = match[1].replace(/\\(\\|f|n|r|t|')/g, (m) => UNESCAPE[m]);
      parsed.push(key);
      continue;
    }
    if (match[2] !== void 0) {
      parsed.push(parseInt(match[2], 10));
      continue;
    }
    if (match[3] !== void 0) {
      const _key = match[3].replace(/\\(\\')/g, (m) => UNESCAPE[m]);
      parsed.push({
        _key,
        _index: -1
      });
      continue;
    }
  }
  return parsed;
}
function jsonPathToMappingPath(path) {
  return path.map((segment) => {
    if (typeof segment == "string" || typeof segment == "number")
      return segment;
    if (segment._index !== -1)
      return segment._index;
    throw new Error(`invalid segment:${JSON.stringify(segment)}`);
  });
}
function resolveMapping(resultPath, csm) {
  if (!(csm == null ? void 0 : csm.mappings))
    return;
  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));
  if (csm.mappings[resultMappingPath] !== void 0)
    return {
      mapping: csm.mappings[resultMappingPath],
      matchedPath: resultMappingPath,
      pathSuffix: ""
    };
  const mappings = Object.entries(csm.mappings).filter(([key]) => resultMappingPath.startsWith(key)).sort(([key1], [key2]) => key2.length - key1.length);
  if (mappings.length == 0)
    return;
  const [matchedPath, mapping] = mappings[0], pathSuffix = resultMappingPath.substring(matchedPath.length);
  return { mapping, matchedPath, pathSuffix };
}
function isArray(value) {
  return value !== null && Array.isArray(value);
}
function isRecord(value) {
  return typeof value == "object" && value !== null;
}
function walkMap(value, mappingFn, path = []) {
  if (isArray(value))
    return value.map((v, idx) => {
      if (isRecord(v)) {
        const _key = v._key;
        if (typeof _key == "string")
          return walkMap(v, mappingFn, path.concat({ _key, _index: idx }));
      }
      return walkMap(v, mappingFn, path.concat(idx));
    });
  if (isRecord(value)) {
    if (value._type === "block" || value._type === "span") {
      const result = { ...value };
      return value._type === "block" ? result.children = walkMap(value.children, mappingFn, path.concat("children")) : value._type === "span" && (result.text = walkMap(value.text, mappingFn, path.concat("text"))), result;
    }
    return Object.fromEntries(
      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))])
    );
  }
  return mappingFn(value, path);
}

// node_modules/@sanity/client/dist/_chunks-es/config.js
var BASE_URL = "https://www.sanity.io/help/";
function generateHelpUrl(slug) {
  return BASE_URL + slug;
}
function once(fn) {
  let didCall = false, returnValue;
  return (...args) => (didCall || (returnValue = fn(...args), didCall = true), returnValue);
}
var createWarningPrinter = (message) => (
  // eslint-disable-next-line no-console
  once((...args) => console.warn(message.join(" "), ...args))
);
var printCdnAndWithCredentialsWarning = createWarningPrinter([
  "Because you set `withCredentials` to true, we will override your `useCdn`",
  "setting to be false since (cookie-based) credentials are never set on the CDN"
]);
var printCdnWarning = createWarningPrinter([
  "Since you haven't set a value for `useCdn`, we will deliver content using our",
  "global, edge-cached API-CDN. If you wish to have content delivered faster, set",
  "`useCdn: false` to use the Live API. Note: You may incur higher costs using the live API."
]);
var printCdnPreviewDraftsWarning = createWarningPrinter([
  "The Sanity client is configured with the `perspective` set to `previewDrafts`, which doesn't support the API-CDN.",
  "The Live API will be used instead. Set `useCdn: false` in your configuration to hide this warning."
]);
var printBrowserTokenWarning = createWarningPrinter([
  "You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.",
  `See ${generateHelpUrl(
    "js-client-browser-token"
  )} for more information and how to hide this warning.`
]);
var printNoApiVersionSpecifiedWarning = createWarningPrinter([
  "Using the Sanity client without specifying an API version is deprecated.",
  `See ${generateHelpUrl("js-client-api-version")}`
]);
var printNoDefaultExport = createWarningPrinter([
  "The default export of @sanity/client has been deprecated. Use the named export `createClient` instead."
]);
function validateApiPerspective(perspective) {
  if (Array.isArray(perspective)) {
    for (const perspectiveValue of perspective)
      if (perspectiveValue !== "published" && perspectiveValue !== "drafts" && !(typeof perspectiveValue == "string" && perspectiveValue.startsWith("r") && perspectiveValue !== "raw"))
        throw new TypeError(
          "Invalid API perspective value, expected `published`, `drafts` or a valid release identifier string"
        );
    return;
  }
  switch (perspective) {
    case "previewDrafts":
    case "drafts":
    case "published":
    case "raw":
      return;
    default:
      throw new TypeError(
        "Invalid API perspective string, expected `published`, `previewDrafts` or `raw`"
      );
  }
}

// node_modules/@sanity/client/dist/csm.js
function resolvePerspectives(perspective) {
  if (validateApiPerspective(perspective), Array.isArray(perspective))
    return perspective.includes("published") ? perspective : [...perspective, "published"];
  switch (perspective) {
    case "previewDrafts":
    case "drafts":
      return ["drafts", "published"];
    case "published":
    default:
      return ["published"];
  }
}
function createSourceDocumentResolver(getCachedDocument, _perspective) {
  const perspectives = resolvePerspectives(_perspective);
  function findDocument(sourceDocument) {
    for (const perspective of perspectives) {
      let match = null;
      if (perspective.startsWith("r") && (match = getCachedDocument({
        ...sourceDocument,
        _id: getVersionId(sourceDocument._id, perspective)
      })), perspective === "drafts" && (match = getCachedDocument({
        ...sourceDocument,
        _id: getDraftId(sourceDocument._id)
      })), perspective === "published" && (match = getCachedDocument({
        ...sourceDocument,
        _id: getPublishedId(sourceDocument._id)
      })), match)
        return { ...match, _id: getPublishedId(match._id), _originalId: match._id };
    }
    return null;
  }
  return function(sourceDocument) {
    return findDocument(sourceDocument);
  };
}
function applySourceDocuments(result, resultSourceMap, getCachedDocument, updateFn, perspective) {
  var _a, _b;
  if (!resultSourceMap) return result;
  const resolveDocument = createSourceDocumentResolver(getCachedDocument, perspective), cachedDocuments = ((_b = (_a = resultSourceMap.documents) == null ? void 0 : _a.map) == null ? void 0 : _b.call(_a, resolveDocument)) || [];
  return walkMap(JSON.parse(JSON.stringify(result)), (value, path) => {
    const resolveMappingResult = resolveMapping(path, resultSourceMap);
    if (!resolveMappingResult)
      return value;
    const { mapping, pathSuffix } = resolveMappingResult;
    if (mapping.type !== "value" || mapping.source.type !== "documentValue")
      return value;
    const sourceDocument = resultSourceMap.documents[mapping.source.document], sourcePath = resultSourceMap.paths[mapping.source.path];
    if (sourceDocument) {
      const parsedPath = parseJsonPath(sourcePath + pathSuffix), stringifiedPath = toString(parsedPath), cachedDocument = cachedDocuments[mapping.source.document];
      if (!cachedDocument)
        return value;
      const changedValue = cachedDocument ? get(cachedDocument, stringifiedPath, value) : value;
      return value === changedValue ? value : updateFn(changedValue, {
        cachedDocument,
        previousValue: value,
        sourceDocument,
        sourcePath: parsedPath
      });
    }
    return value;
  });
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  var _a;
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? ((_a = options.rng) == null ? void 0 : _a.call(options)) ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  const words = uint8ToUint32(bytes);
  const md5Bytes = wordsToMd5(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes = new Uint8Array(input.length * 4);
  for (let i = 0; i < input.length * 4; i++) {
    bytes[i] = input[i >> 2] >>> i % 4 * 8 & 255;
  }
  return bytes;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x = xpad;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return Uint32Array.of(a, b, c, d);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i = 0; i < input.length; i++) {
    output[i >> 2] |= (input[i] & 255) << i % 4 * 8;
  }
  return output;
}
function safeAdd(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; ++i) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(version, hash, value, namespace, buf, offset) {
  const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
  const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default(namespace);
  }
  if ((namespace == null ? void 0 : namespace.length) !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash(bytes);
  bytes[6] = bytes[6] & 15 | version;
  bytes[8] = bytes[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}

// node_modules/uuid/dist/esm-browser/v3.js
function v3(value, namespace, buf, offset) {
  return v35(48, md5_default, value, namespace, buf, offset);
}
v3.DNS = DNS;
v3.URL = URL;

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 128;
  bytes = newBytes;
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
function v5(value, namespace, buf, offset) {
  return v35(80, sha1_default, value, namespace, buf, offset);
}
v5.DNS = DNS;
v5.URL = URL;

// node_modules/@sanity/comlink/dist/index.js
var listenInputFromContext = (config) => ({
  context
}) => {
  const { count, include, exclude, responseType = "message.received" } = config;
  return {
    count,
    domain: context.domain,
    from: context.connectTo,
    include: include ? Array.isArray(include) ? include : [include] : [],
    exclude: exclude ? Array.isArray(exclude) ? exclude : [exclude] : [],
    responseType,
    target: context.target,
    to: context.name
  };
};
var listenFilter = (input) => (event) => {
  const { data } = event;
  return (input.include.length ? input.include.includes(data.type) : true) && (input.exclude.length ? !input.exclude.includes(data.type) : true) && data.domain === input.domain && data.from === input.from && data.to === input.to && (!input.target || event.source === input.target);
};
var eventToMessage = (type) => (event) => ({
  type,
  message: event
});
var messageEvents$ = defer(
  () => fromEvent(window, "message")
);
var createListenLogic = (compatMap) => fromEventObservable(({ input }) => messageEvents$.pipe(
  compatMap ? map(compatMap) : pipe(),
  filter(listenFilter(input)),
  map(eventToMessage(input.responseType)),
  input.count ? pipe(
    bufferCount(input.count),
    concatMap((arr) => arr),
    take(input.count)
  ) : pipe()
));
var DOMAIN = "sanity/comlink";
var RESPONSE_TIMEOUT_DEFAULT = 3e3;
var HANDSHAKE_INTERVAL = 500;
var MSG_RESPONSE = "comlink/response";
var MSG_HEARTBEAT = "comlink/heartbeat";
var MSG_DISCONNECT = "comlink/disconnect";
var MSG_HANDSHAKE_SYN = "comlink/handshake/syn";
var MSG_HANDSHAKE_SYN_ACK = "comlink/handshake/syn-ack";
var MSG_HANDSHAKE_ACK = "comlink/handshake/ack";
var HANDSHAKE_MSG_TYPES = [
  MSG_HANDSHAKE_SYN,
  MSG_HANDSHAKE_SYN_ACK,
  MSG_HANDSHAKE_ACK
];
var INTERNAL_MSG_TYPES = [
  MSG_RESPONSE,
  MSG_DISCONNECT,
  MSG_HEARTBEAT,
  ...HANDSHAKE_MSG_TYPES
];
var throwOnEvent = (message) => (source) => source.pipe(
  take(1),
  map(() => {
    throw new Error(message);
  })
);
var createRequestMachine = () => setup({
  types: {},
  actors: {
    listen: fromEventObservable(
      ({
        input
      }) => {
        const abortSignal$ = input.signal ? fromEvent(input.signal, "abort").pipe(
          throwOnEvent(`Request ${input.requestId} aborted`)
        ) : EMPTY, messageFilter = (event) => {
          var _a, _b;
          return ((_a = event.data) == null ? void 0 : _a.type) === MSG_RESPONSE && ((_b = event.data) == null ? void 0 : _b.responseTo) === input.requestId && !!event.source && input.sources.has(event.source);
        };
        return fromEvent(window, "message").pipe(
          filter(messageFilter),
          take(input.sources.size),
          takeUntil(abortSignal$)
        );
      }
    )
  },
  actions: {
    "send message": ({ context }, params) => {
      const { sources, targetOrigin } = context, { message } = params;
      sources.forEach((source) => {
        source.postMessage(message, { targetOrigin });
      });
    },
    "on success": sendTo(
      ({ context }) => context.parentRef,
      ({ context, self }) => {
        var _a;
        return context.response && ((_a = context.resolvable) == null ? void 0 : _a.resolve(context.response)), {
          type: "request.success",
          requestId: self.id,
          response: context.response,
          responseTo: context.responseTo
        };
      }
    ),
    "on fail": sendTo(
      ({ context }) => context.parentRef,
      ({ context, self }) => {
        var _a;
        return context.suppressWarnings || console.warn(
          `[@sanity/comlink] Received no response to message '${context.type}' on client '${context.from}' (ID: '${context.id}').`
        ), (_a = context.resolvable) == null ? void 0 : _a.reject(new Error("No response received")), { type: "request.failed", requestId: self.id };
      }
    ),
    "on abort": sendTo(
      ({ context }) => context.parentRef,
      ({ context, self }) => {
        var _a;
        return (_a = context.resolvable) == null ? void 0 : _a.reject(new Error("Request aborted")), { type: "request.aborted", requestId: self.id };
      }
    )
  },
  guards: {
    expectsResponse: ({ context }) => context.expectResponse
  },
  delays: {
    initialTimeout: 0,
    responseTimeout: ({ context }) => context.responseTimeout ?? RESPONSE_TIMEOUT_DEFAULT
  }
}).createMachine({
  /** @xstate-layout N4IgpgJg5mDOIC5QAoC2BDAxgCwJYDswBKAOlwgBswBiAD1gBd0GwT0AzFgJ2QNwdzoKAFVyowAewCuDItTRY8hUuSoBtAAwBdRKAAOE2P1wT8ukLUQBGAEwBWEgBYAnK+eOAzB7sB2DzY8rABoQAE9rDQc3V0cNTw8fAA4NHwBfVJCFHAJiElgwfAgCKGpNHSQQAyMBU3NLBDsrDxI7DTaAjQA2OOcNDxDwhHsNJx9Ou0TOq2cJxP9HdMyMbOU8gqL8ErUrcv1DY1qK+sbm1vaPLp6+gcRnGydo9wDGycWQLKVc9AB3dGNN6jiWCwdAwMrmKoHMxHRCJRKOEiJHwuZKBZwXKzBMKIGyYkhtAkXOweTqOHw2RJvD45Ug-P4CAH0JgsNicMA8LhwAz4fKicTSWTyZafWm-f5QcEVSE1aGgepwhFIlF9aYYrGDC4+JzEppjGzOUkeGbpDIgfASCBwczU5QQ-YyuqIAC0nRuCBd+IJXu9KSpwppZEoYDt1RMsosiEcNjdVjiJEeGisiSTHkcVgWpptuXyhWKIahjqGzi1BqRJINnVcdkcbuTLS9VYC8ISfsUAbp4vzDphCHJIyjBvJNlxNmRNexQ3sJGH43GPj8jWJrZWuXYfyoEC7YcLsbrgRsjkcvkmdgNbopVhIPhVfnsh8ClMz-tWsCkmEwcHgUvt257u8v+6Hse4xnhOdZnImVidPqCRNB4JqpEAA */
  context: ({ input }) => ({
    channelId: input.channelId,
    data: input.data,
    domain: input.domain,
    expectResponse: input.expectResponse ?? false,
    from: input.from,
    id: `msg-${v4_default()}`,
    parentRef: input.parentRef,
    resolvable: input.resolvable,
    response: null,
    responseTimeout: input.responseTimeout,
    responseTo: input.responseTo,
    signal: input.signal,
    sources: input.sources instanceof Set ? input.sources : /* @__PURE__ */ new Set([input.sources]),
    suppressWarnings: input.suppressWarnings,
    targetOrigin: input.targetOrigin,
    to: input.to,
    type: input.type
  }),
  initial: "idle",
  on: {
    abort: ".aborted"
  },
  states: {
    idle: {
      after: {
        initialTimeout: [
          {
            target: "sending"
          }
        ]
      }
    },
    sending: {
      entry: {
        type: "send message",
        params: ({ context }) => {
          const { channelId, data, domain, from, id, responseTo, to, type } = context;
          return { message: {
            channelId,
            data,
            domain,
            from,
            id,
            to,
            type,
            responseTo
          } };
        }
      },
      always: [
        {
          guard: "expectsResponse",
          target: "awaiting"
        },
        "success"
      ]
    },
    awaiting: {
      invoke: {
        id: "listen for response",
        src: "listen",
        input: ({ context }) => ({
          requestId: context.id,
          sources: context.sources,
          signal: context.signal
        }),
        onError: "aborted"
      },
      after: {
        responseTimeout: "failed"
      },
      on: {
        message: {
          actions: assign({
            response: ({ event }) => event.data.data,
            responseTo: ({ event }) => event.data.responseTo
          }),
          target: "success"
        }
      }
    },
    failed: {
      type: "final",
      entry: "on fail"
    },
    success: {
      type: "final",
      entry: "on success"
    },
    aborted: {
      type: "final",
      entry: "on abort"
    }
  },
  output: ({ context, self }) => ({
    requestId: self.id,
    response: context.response,
    responseTo: context.responseTo
  })
});
var sendBackAtInterval = fromCallback(({ sendBack, input }) => {
  const send = () => {
    sendBack(input.event);
  };
  input.immediate && send();
  const interval = setInterval(send, input.interval);
  return () => {
    clearInterval(interval);
  };
});
var createConnectionMachine = () => setup({
  types: {},
  actors: {
    requestMachine: createRequestMachine(),
    listen: createListenLogic(),
    sendBackAtInterval
  },
  actions: {
    "buffer message": enqueueActions(({ enqueue }) => {
      enqueue.assign({
        buffer: ({ event, context }) => (assertEvent(event, "post"), [...context.buffer, event.data])
      }), enqueue.emit(({ event }) => (assertEvent(event, "post"), {
        type: "buffer.added",
        message: event.data
      }));
    }),
    "create request": assign({
      requests: ({ context, event, self, spawn }) => {
        assertEvent(event, "request");
        const requests = (Array.isArray(event.data) ? event.data : [event.data]).map((request) => {
          const id = `req-${v4_default()}`;
          return spawn("requestMachine", {
            id,
            input: {
              channelId: context.channelId,
              data: request.data,
              domain: context.domain,
              expectResponse: request.expectResponse,
              from: context.name,
              parentRef: self,
              responseTo: request.responseTo,
              sources: context.target,
              targetOrigin: context.targetOrigin,
              to: context.connectTo,
              type: request.type
            }
          });
        });
        return [...context.requests, ...requests];
      }
    }),
    "emit received message": enqueueActions(({ enqueue }) => {
      enqueue.emit(({ event }) => (assertEvent(event, "message.received"), {
        type: "message",
        message: event.message.data
      }));
    }),
    "emit status": emit((_, params) => ({
      type: "status",
      status: params.status
    })),
    "post message": raise(({ event }) => (assertEvent(event, "post"), {
      type: "request",
      data: {
        data: event.data.data,
        expectResponse: true,
        type: event.data.type
      }
    })),
    "remove request": enqueueActions(({ context, enqueue, event }) => {
      assertEvent(event, ["request.success", "request.failed", "request.aborted"]), stopChild(event.requestId), enqueue.assign({ requests: context.requests.filter(({ id }) => id !== event.requestId) });
    }),
    respond: raise(({ event }) => (assertEvent(event, "response"), {
      type: "request",
      data: {
        data: event.data,
        type: MSG_RESPONSE,
        responseTo: event.respondTo
      }
    })),
    "send handshake ack": raise({
      type: "request",
      data: { type: MSG_HANDSHAKE_ACK }
    }),
    "send disconnect": raise(() => ({
      type: "request",
      data: { type: MSG_DISCONNECT }
    })),
    "send handshake syn": raise({
      type: "request",
      data: { type: MSG_HANDSHAKE_SYN }
    }),
    "send pending messages": enqueueActions(({ enqueue }) => {
      enqueue.raise(({ context }) => ({
        type: "request",
        data: context.buffer.map(({ data, type }) => ({ data, type }))
      })), enqueue.emit(({ context }) => ({
        type: "buffer.flushed",
        messages: context.buffer
      })), enqueue.assign({
        buffer: []
      });
    }),
    "set target": assign({
      target: ({ event }) => (assertEvent(event, "target.set"), event.target)
    })
  },
  guards: {
    "has target": ({ context }) => !!context.target,
    "should send heartbeats": ({ context }) => context.heartbeat
  }
}).createMachine({
  /** @xstate-layout N4IgpgJg5mDOIC5QGMAWBDAdpsAbAxAC7oBOMhAdLGIQNoAMAuoqAA4D2sAloV+5ixAAPRAHZRAJgoAWABz0ArHICMy2QGZZCgJwAaEAE9EE+tIrb6ANgkLl46fTuj1AXxf60WHARJgAjgCucJSwAcjIcLAMzEggHNy8-IIiCKLS2hQS6qb2yurisrL6RgjK9LIyCuqq0g7WstZuHhjYePi+gcEUAGboXLiQ0YLxPHwCsSmiCgoykpayDtqS6trqxYjKEk0gnq24FFwQA-jI-DjIdEzDnKNJExuOZpZ12eq29OrSCuupypYUojUaTKCnm5Wk2123gORzA+HilxibBuiXGoBSGnUAIU4gU9FWamUtR+lmUM1EllBEkslMUEnpkJa0JaEFgGAA1lxMFB8LADJghrERqjkhtshk3mTtNo5OpqpYfqCKhTptoqpY1WUtu4dky8BQWWz0Jzue1-EFYIjrgkxqLSupqRRPpoPqJtLI0hIioZENJJE7NnJ8ZYHVk1YyvPrDRyuTyEYLkTa7uixVlMh81KGFhS1j6EPkZlpVjTphr8mkI3sDVhWTHTQBbSLoGAUXwRLgAN0GVyFKNt91KimUFEKXvKC2s9R+6X+jipnzJeSqEJ1UKjNaNJp5EC4sFOrQuCbifeTwg2cgoym0RPxDtqkj0eaB9Ao8zSolMEivZVcq71+33c5CEgeFOCtXskzRM8EDxKRpmkSw3QJbQsmpH5tHmV8JHSbJpDsakV2aSMALOMALhAjoLXAxNbiglI-SxWw1Vw0QNDw0Qfg9KQ7EJSxHHxApK2hQCyOAiAzVgDhMGoI9hX7FMEHSF8cWkelpHURCbBsb481xAEgT9BQJCmWQsiE-URPI8TG1gWBmzAVsyLATtuyRY9ILtWoKmlL82Kqd0tAVJ91LMHFZDKIkVlkNVZHMkiDzE-Adz3UjDx7GiRQHCKnheD53k+HSSkDDIwpBVTqQwuKKEssSDTAUhCAAI3qyg0DIrd8Fkk86MQUMnVM+RynoegTDJH48hGp0vR-FDRqqKqasgOqGua9AQjATAd1NSiul6fpXOtWi7Wy19cslD4vnG7IX3oVjVDUVYEJQqrksW8SdstLqPKy0wKgG1RhtMWogqKhoMjkWp6XxUyFBe3c3tAz70vco6fq+V8PTkGUFzdQqNnELEM2yClrwwzQ4ZShKQJqr7UYU98AS0W9pT4z5pHG0yXwMkNNTyGk3B1TB2AgOBBDXXBDsyhSFG9EovQqN5i1JeRcKqw4Bkl+ToMx8x0j+EaqQ9XMSkBURMgMkEwQWKro2NWNNdPFJAzN0lJGM4slDxhBEJfXyplBd03wW1KxIdnrBxBh4JAyW75C8rJpmDqmIGWkgmpasPjqUcaHooMLHA0uU1UkJOgKW1B6rT1bWor5At0zgcTAkK7hrz1irB0D8cW0UvRPLyv07WqgNq2qAG+l9SnXUz0UOXD5xuMs3Y4+DVJBX7UiKrV6Q8gcfoJO54rFefLLqfJYX1WKYNLxL4NO1NwgA */
  id: "connection",
  context: ({ input }) => ({
    id: input.id || `${input.name}-${v4_default()}`,
    buffer: [],
    channelId: `chn-${v4_default()}`,
    connectTo: input.connectTo,
    domain: input.domain ?? DOMAIN,
    heartbeat: input.heartbeat ?? false,
    name: input.name,
    requests: [],
    target: input.target,
    targetOrigin: input.targetOrigin
  }),
  on: {
    "target.set": {
      actions: "set target"
    },
    "request.success": {
      actions: "remove request"
    },
    "request.failed": {
      actions: "remove request"
    }
  },
  initial: "idle",
  states: {
    idle: {
      entry: [{ type: "emit status", params: { status: "idle" } }],
      on: {
        connect: {
          target: "handshaking",
          guard: "has target"
        },
        post: {
          actions: "buffer message"
        }
      }
    },
    handshaking: {
      id: "handshaking",
      entry: [{ type: "emit status", params: { status: "handshaking" } }],
      invoke: [
        {
          id: "send syn",
          src: "sendBackAtInterval",
          input: () => ({
            event: { type: "syn" },
            interval: HANDSHAKE_INTERVAL,
            immediate: true
          })
        },
        {
          id: "listen for handshake",
          src: "listen",
          input: (input) => listenInputFromContext({
            include: MSG_HANDSHAKE_SYN_ACK,
            count: 1
          })(input)
          /* Below would maybe be more readable than transitioning to
          'connected' on 'message', and 'ack' on exit but having onDone when
          using passing invocations currently breaks XState Editor */
          // onDone: {
          //   target: 'connected',
          //   actions: 'ack',
          // },
        }
      ],
      on: {
        syn: {
          actions: "send handshake syn"
        },
        request: {
          actions: "create request"
        },
        post: {
          actions: "buffer message"
        },
        "message.received": {
          target: "connected"
        },
        disconnect: {
          target: "disconnected"
        }
      },
      exit: "send handshake ack"
    },
    connected: {
      entry: ["send pending messages", { type: "emit status", params: { status: "connected" } }],
      invoke: {
        id: "listen for messages",
        src: "listen",
        input: listenInputFromContext({
          exclude: [MSG_RESPONSE, MSG_HEARTBEAT]
        })
      },
      on: {
        post: {
          actions: "post message"
        },
        request: {
          actions: "create request"
        },
        response: {
          actions: "respond"
        },
        "message.received": {
          actions: "emit received message"
        },
        disconnect: {
          target: "disconnected"
        }
      },
      initial: "heartbeat",
      states: {
        heartbeat: {
          initial: "checking",
          states: {
            checking: {
              always: {
                guard: "should send heartbeats",
                target: "sending"
              }
            },
            sending: {
              on: {
                "request.failed": {
                  target: "#handshaking"
                }
              },
              invoke: {
                id: "send heartbeat",
                src: "sendBackAtInterval",
                input: () => ({
                  event: { type: "post", data: { type: MSG_HEARTBEAT, data: void 0 } },
                  interval: 2e3,
                  immediate: false
                })
              }
            }
          }
        }
      }
    },
    disconnected: {
      id: "disconnected",
      entry: ["send disconnect", { type: "emit status", params: { status: "disconnected" } }],
      on: {
        request: {
          actions: "create request"
        },
        post: {
          actions: "buffer message"
        },
        connect: {
          target: "handshaking",
          guard: "has target"
        }
      }
    }
  }
});
var createConnection = (input, machine = createConnectionMachine()) => {
  const id = input.id || `${input.name}-${v4_default()}`, actor = createActor(machine, {
    input: { ...input, id }
  }), eventHandlers = /* @__PURE__ */ new Map(), unhandledMessages = /* @__PURE__ */ new Map(), on = (type, handler, options) => {
    const handlers = eventHandlers.get(type) || /* @__PURE__ */ new Set();
    eventHandlers.has(type) || eventHandlers.set(type, handlers), handlers.add(handler);
    const unhandledMessagesForType = unhandledMessages.get(type);
    if (unhandledMessagesForType) {
      const replayCount = (options == null ? void 0 : options.replay) ?? 1;
      Array.from(unhandledMessagesForType).slice(-replayCount).forEach(async ({ data, id: id2 }) => {
        const response = await handler(data);
        response && actor.send({
          type: "response",
          respondTo: id2,
          data: response
        });
      }), unhandledMessages.delete(type);
    }
    return () => {
      handlers.delete(handler);
    };
  }, connect = () => {
    actor.send({ type: "connect" });
  }, disconnect = () => {
    actor.send({ type: "disconnect" });
  }, onStatus = (handler, filter2) => {
    const { unsubscribe } = actor.on("status", (event) => {
      filter2 && event.status !== filter2 || handler(event.status);
    });
    return unsubscribe;
  }, setTarget = (target) => {
    actor.send({ type: "target.set", target });
  }, post = (type, data) => {
    const _data = { type, data };
    actor.send({ type: "post", data: _data });
  };
  actor.on("message", async ({ message }) => {
    const handlers = eventHandlers.get(message.type);
    if (handlers) {
      handlers.forEach(async (handler) => {
        const response = await handler(message.data);
        response && actor.send({ type: "response", respondTo: message.id, data: response });
      });
      return;
    }
    const unhandledMessagesForType = unhandledMessages.get(message.type);
    unhandledMessagesForType ? unhandledMessagesForType.add(message) : unhandledMessages.set(message.type, /* @__PURE__ */ new Set([message]));
  });
  const stop = () => {
    actor.stop();
  }, start = () => (actor.start(), stop);
  return {
    actor,
    connect,
    disconnect,
    id,
    name: input.name,
    machine,
    on,
    onStatus,
    post,
    setTarget,
    start,
    stop,
    get target() {
      return actor.getSnapshot().context.target;
    }
  };
};
var cleanupConnection = (connection) => {
  connection.disconnect(), setTimeout(() => {
    connection.stop();
  }, 0);
};
var noop = () => {
};
var createController = (input) => {
  const { targetOrigin } = input, targets = /* @__PURE__ */ new Set(), channels = /* @__PURE__ */ new Set();
  return {
    addTarget: (target) => {
      if (targets.has(target))
        return noop;
      if (!targets.size || !channels.size)
        return targets.add(target), channels.forEach((channel) => {
          channel.connections.forEach((connection) => {
            connection.setTarget(target), connection.connect();
          });
        }), () => {
          targets.delete(target), channels.forEach((channel) => {
            channel.connections.forEach((connection) => {
              connection.target === target && connection.disconnect();
            });
          });
        };
      targets.add(target);
      const targetConnections = /* @__PURE__ */ new Set();
      return channels.forEach((channel) => {
        const connection = createConnection(
          {
            ...channel.input,
            target,
            targetOrigin
          },
          channel.machine
        );
        targetConnections.add(connection), channel.connections.add(connection), channel.subscribers.forEach(({ type, handler, unsubscribers }) => {
          unsubscribers.push(connection.on(type, handler));
        }), channel.internalEventSubscribers.forEach(({ type, handler, unsubscribers }) => {
          unsubscribers.push(connection.actor.on(type, handler).unsubscribe);
        }), channel.statusSubscribers.forEach(({ handler, unsubscribers }) => {
          unsubscribers.push(
            connection.onStatus((status) => handler({ connection: connection.id, status }))
          );
        }), connection.start(), connection.connect();
      }), () => {
        targets.delete(target), targetConnections.forEach((connection) => {
          cleanupConnection(connection), channels.forEach((channel) => {
            channel.connections.delete(connection);
          });
        });
      };
    },
    createChannel: (input2, machine = createConnectionMachine()) => {
      const channel = {
        connections: /* @__PURE__ */ new Set(),
        input: input2,
        internalEventSubscribers: /* @__PURE__ */ new Set(),
        machine,
        statusSubscribers: /* @__PURE__ */ new Set(),
        subscribers: /* @__PURE__ */ new Set()
      };
      channels.add(channel);
      const { connections, internalEventSubscribers, statusSubscribers, subscribers } = channel;
      if (targets.size)
        targets.forEach((target) => {
          const connection = createConnection(
            {
              ...input2,
              target,
              targetOrigin
            },
            machine
          );
          connections.add(connection);
        });
      else {
        const connection = createConnection({ ...input2, targetOrigin }, machine);
        connections.add(connection);
      }
      const post = (...params) => {
        const [type, data] = params;
        connections.forEach((connection) => {
          connection.post(type, data);
        });
      }, on = (type, handler) => {
        const unsubscribers = [];
        connections.forEach((connection) => {
          unsubscribers.push(connection.on(type, handler));
        });
        const subscriber = { type, handler, unsubscribers };
        return subscribers.add(subscriber), () => {
          unsubscribers.forEach((unsub) => unsub()), subscribers.delete(subscriber);
        };
      }, onInternalEvent = (type, handler) => {
        const unsubscribers = [];
        connections.forEach((connection) => {
          unsubscribers.push(connection.actor.on(type, handler).unsubscribe);
        });
        const subscriber = { type, handler, unsubscribers };
        return internalEventSubscribers.add(subscriber), () => {
          unsubscribers.forEach((unsub) => unsub()), internalEventSubscribers.delete(subscriber);
        };
      }, onStatus = (handler) => {
        const unsubscribers = [];
        connections.forEach((connection) => {
          unsubscribers.push(
            connection.onStatus((status) => handler({ connection: connection.id, status }))
          );
        });
        const subscriber = { handler, unsubscribers };
        return statusSubscribers.add(subscriber), () => {
          unsubscribers.forEach((unsub) => unsub()), statusSubscribers.delete(subscriber);
        };
      }, stop = () => {
        const connections2 = channel.connections;
        connections2.forEach(cleanupConnection), connections2.clear(), channels.delete(channel);
      };
      return {
        on,
        onInternalEvent,
        onStatus,
        post,
        start: () => (connections.forEach((connection) => {
          connection.start(), connection.connect();
        }), stop),
        stop
      };
    },
    destroy: () => {
      channels.forEach(({ connections }) => {
        connections.forEach(cleanupConnection), connections.clear();
      }), channels.clear(), targets.clear();
    }
  };
};

// node_modules/@sanity/presentation-comlink/dist/index.js
var channelsToComlinkMap = {
  "handshake/syn": MSG_HANDSHAKE_SYN,
  "handshake/syn-ack": MSG_HANDSHAKE_SYN_ACK,
  "handshake/ack": MSG_HANDSHAKE_ACK,
  "channel/response": MSG_RESPONSE,
  "channel/heartbeat": MSG_HEARTBEAT,
  "channel/disconnect": MSG_DISCONNECT,
  "overlay/focus": "visual-editing/focus",
  "overlay/navigate": "visual-editing/navigate",
  "overlay/toggle": "visual-editing/toggle",
  "presentation/toggleOverlay": "presentation/toggle-overlay"
};
var comlinkToChannelsMap = {
  [MSG_HANDSHAKE_SYN]: "handshake/syn",
  [MSG_HANDSHAKE_SYN_ACK]: "handshake/syn-ack",
  [MSG_HANDSHAKE_ACK]: "handshake/ack",
  [MSG_RESPONSE]: "channel/response",
  [MSG_HEARTBEAT]: "channel/heartbeat",
  [MSG_DISCONNECT]: "channel/disconnect",
  "visual-editing/focus": "overlay/focus",
  "visual-editing/navigate": "overlay/navigate",
  "visual-editing/toggle": "overlay/toggle",
  "presentation/toggle-overlay": "presentation/toggleOverlay"
};
var convertToComlinkEvent = (event) => {
  const { data } = event;
  return data && typeof data == "object" && "domain" in data && "type" in data && "from" in data && "to" in data && (data.domain === "sanity/channels" && (data.domain = DOMAIN), data.to === "overlays" && (data.to = "visual-editing"), data.from === "overlays" && (data.from = "visual-editing"), data.channelId = data.connectionId, delete data.connectionId, data.type = channelsToComlinkMap[data.type] ?? data.type), event;
};
var convertToChannelsMessage = (comlinkMessage) => {
  const { channelId, ...rest } = comlinkMessage, message = { ...rest, connectionId: channelId };
  return message.domain === DOMAIN && (message.domain = "sanity/channels"), message.to === "visual-editing" && (message.to = "overlays"), message.from === "visual-editing" && (message.from = "overlays"), message.type = comlinkToChannelsMap[message.type] ?? message.type, message.type === "channel/response" && message.responseTo && !message.data && (message.data = { responseTo: message.responseTo }), (message.type === "handshake/syn" || message.type === "handshake/syn-ack" || message.type === "handshake/ack") && (message.data = { id: message.connectionId }), message;
};
var sendAsChannelsMessage = ({ context }, params) => {
  const { sources, targetOrigin } = context, message = convertToChannelsMessage(params.message);
  sources.forEach((source) => {
    source.postMessage(message, { targetOrigin });
  });
};
var createCompatibilityActors = () => ({
  listen: createListenLogic(convertToComlinkEvent),
  requestMachine: createRequestMachine().provide({
    actions: {
      "send message": sendAsChannelsMessage
    }
  })
});

export {
  studioPath,
  getPublishedId,
  applySourceDocuments,
  v4_default,
  createConnectionMachine,
  createController,
  createCompatibilityActors
};
//# sourceMappingURL=chunk-OT5SCF6H.js.map

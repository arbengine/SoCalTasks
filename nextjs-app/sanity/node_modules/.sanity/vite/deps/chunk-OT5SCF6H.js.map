{
  "version": 3,
  "sources": ["../../../@sanity/client/src/csm/studioPath.ts", "../../../@sanity/client/src/csm/draftUtils.ts", "../../../@sanity/client/src/csm/jsonPath.ts", "../../../@sanity/client/src/csm/resolveMapping.ts", "../../../@sanity/client/src/csm/isArray.ts", "../../../@sanity/client/src/csm/isRecord.ts", "../../../@sanity/client/src/csm/walkMap.ts", "../../../@sanity/client/src/csm/createEditUrl.ts", "../../../@sanity/client/src/csm/resolveEditInfo.ts", "../../../@sanity/client/src/generateHelpUrl.ts", "../../../@sanity/client/src/validators.ts", "../../../@sanity/client/src/util/once.ts", "../../../@sanity/client/src/warnings.ts", "../../../@sanity/client/src/config.ts", "../../../@sanity/client/src/csm/resolvePerspectives.ts", "../../../@sanity/client/src/csm/createSourceDocumentResolver.ts", "../../../@sanity/client/src/csm/applySourceDocuments.ts", "../../../@sanity/client/src/csm/resolvedKeyedSourcePath.ts", "../../../@sanity/client/src/csm/resolveEditUrl.ts", "../../../uuid/dist/esm-browser/native.js", "../../../uuid/dist/esm-browser/rng.js", "../../../uuid/dist/esm-browser/regex.js", "../../../uuid/dist/esm-browser/validate.js", "../../../uuid/dist/esm-browser/stringify.js", "../../../uuid/dist/esm-browser/v4.js", "../../../uuid/dist/esm-browser/parse.js", "../../../uuid/dist/esm-browser/md5.js", "../../../uuid/dist/esm-browser/v35.js", "../../../uuid/dist/esm-browser/v3.js", "../../../uuid/dist/esm-browser/sha1.js", "../../../uuid/dist/esm-browser/v5.js", "../../../@sanity/comlink/src/common.ts", "../../../@sanity/comlink/src/constants.ts", "../../../@sanity/comlink/src/request.ts", "../../../@sanity/comlink/src/connection.ts", "../../../@sanity/comlink/src/controller.ts", "../../../@sanity/comlink/src/node.ts", "../../../@sanity/presentation-comlink/src/comlinkCompatibility.ts", "../../../@sanity/presentation-comlink/src/isMaybePresentation.ts"],
  "sourcesContent": ["/** @alpha */\nexport type KeyedSegment = {_key: string}\n\n/** @alpha */\nexport type IndexTuple = [number | '', number | '']\n\n/** @alpha */\nexport type PathSegment = string | number | KeyedSegment | IndexTuple\n\n/** @alpha */\nexport type Path = PathSegment[]\n\nconst rePropName =\n  /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g\n/** @internal */\nexport const reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/\nconst reIndexTuple = /^\\d*:\\d*$/\n\n/** @internal */\nexport function isIndexSegment(segment: PathSegment): segment is number {\n  return typeof segment === 'number' || (typeof segment === 'string' && /^\\[\\d+\\]$/.test(segment))\n}\n\n/** @internal */\nexport function isKeySegment(segment: PathSegment): segment is KeyedSegment {\n  if (typeof segment === 'string') {\n    return reKeySegment.test(segment.trim())\n  }\n\n  return typeof segment === 'object' && '_key' in segment\n}\n\n/** @internal */\nexport function isIndexTuple(segment: PathSegment): segment is IndexTuple {\n  if (typeof segment === 'string' && reIndexTuple.test(segment)) {\n    return true\n  }\n\n  if (!Array.isArray(segment) || segment.length !== 2) {\n    return false\n  }\n\n  const [from, to] = segment\n  return (typeof from === 'number' || from === '') && (typeof to === 'number' || to === '')\n}\n\n/** @internal */\nexport function get<Result = unknown, Fallback = unknown>(\n  obj: unknown,\n  path: Path | string,\n  defaultVal?: Fallback,\n): Result | typeof defaultVal {\n  const select = typeof path === 'string' ? fromString(path) : path\n  if (!Array.isArray(select)) {\n    throw new Error('Path must be an array or a string')\n  }\n\n  let acc: unknown | undefined = obj\n  for (let i = 0; i < select.length; i++) {\n    const segment = select[i]\n    if (isIndexSegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc[segment]\n    }\n\n    if (isKeySegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc.find((item) => item._key === segment._key)\n    }\n\n    if (typeof segment === 'string') {\n      acc =\n        typeof acc === 'object' && acc !== null\n          ? ((acc as Record<string, unknown>)[segment] as Result)\n          : undefined\n    }\n\n    if (typeof acc === 'undefined') {\n      return defaultVal\n    }\n  }\n\n  return acc as Result\n}\n\n/** @alpha */\nexport function toString(path: Path): string {\n  if (!Array.isArray(path)) {\n    throw new Error('Path is not an array')\n  }\n\n  return path.reduce<string>((target, segment, i) => {\n    const segmentType = typeof segment\n    if (segmentType === 'number') {\n      return `${target}[${segment}]`\n    }\n\n    if (segmentType === 'string') {\n      const separator = i === 0 ? '' : '.'\n      return `${target}${separator}${segment}`\n    }\n\n    if (isKeySegment(segment) && segment._key) {\n      return `${target}[_key==\"${segment._key}\"]`\n    }\n\n    if (Array.isArray(segment)) {\n      const [from, to] = segment\n      return `${target}[${from}:${to}]`\n    }\n\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``)\n  }, '')\n}\n\n/** @alpha */\nexport function fromString(path: string): Path {\n  if (typeof path !== 'string') {\n    throw new Error('Path is not a string')\n  }\n\n  const segments = path.match(rePropName)\n  if (!segments) {\n    throw new Error('Invalid path string')\n  }\n\n  return segments.map(parsePathSegment)\n}\n\nfunction parsePathSegment(segment: string): PathSegment {\n  if (isIndexSegment(segment)) {\n    return parseIndexSegment(segment)\n  }\n\n  if (isKeySegment(segment)) {\n    return parseKeySegment(segment)\n  }\n\n  if (isIndexTuple(segment)) {\n    return parseIndexTupleSegment(segment)\n  }\n\n  return segment\n}\n\nfunction parseIndexSegment(segment: string): PathSegment {\n  return Number(segment.replace(/[^\\d]/g, ''))\n}\n\nfunction parseKeySegment(segment: string): KeyedSegment {\n  const segments = segment.match(reKeySegment)\n  return {_key: segments![1]}\n}\n\nfunction parseIndexTupleSegment(segment: string): IndexTuple {\n  const [from, to] = segment.split(':').map((seg) => (seg === '' ? seg : Number(seg)))\n  return [from, to]\n}\n", "// nominal/opaque type hack\ntype Opaque<T, K> = T & {__opaqueId__: K}\n\n/** @internal */\nexport type DraftId = Opaque<string, 'draftId'>\n\n/** @internal */\nexport type PublishedId = Opaque<string, 'publishedId'>\n\n/** @internal */\nexport const DRAFTS_FOLDER = 'drafts'\n\n/** @internal */\nexport const VERSION_FOLDER = 'versions'\n\nconst PATH_SEPARATOR = '.'\nconst DRAFTS_PREFIX = `${DRAFTS_FOLDER}${PATH_SEPARATOR}`\nconst VERSION_PREFIX = `${VERSION_FOLDER}${PATH_SEPARATOR}`\n\n/** @internal */\nexport function isDraftId(id: string): id is DraftId {\n  return id.startsWith(DRAFTS_PREFIX)\n}\n\n/** @internal */\nexport function isVersionId(id: string): boolean {\n  return id.startsWith(VERSION_PREFIX)\n}\n\n/** @internal */\nexport function isPublishedId(id: string): id is PublishedId {\n  return !isDraftId(id) && !isVersionId(id)\n}\n\n/** @internal */\nexport function getDraftId(id: string): DraftId {\n  if (isVersionId(id)) {\n    const publishedId = getPublishedId(id)\n    return (DRAFTS_PREFIX + publishedId) as DraftId\n  }\n\n  return isDraftId(id) ? id : ((DRAFTS_PREFIX + id) as DraftId)\n}\n\n/**  @internal */\nexport function getVersionId(id: string, version: string): string {\n  if (version === 'drafts' || version === 'published') {\n    throw new Error('Version can not be \"published\" or \"drafts\"')\n  }\n\n  return `${VERSION_PREFIX}${version}${PATH_SEPARATOR}${getPublishedId(id)}`\n}\n\n/**\n *  @internal\n *  Given an id, returns the versionId if it exists.\n *  e.g. `versions.summer-drop.foo` = `summer-drop`\n *  e.g. `drafts.foo` = `undefined`\n *  e.g. `foo` = `undefined`\n */\nexport function getVersionFromId(id: string): string | undefined {\n  if (!isVersionId(id)) return undefined\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const [_versionPrefix, versionId, ..._publishedId] = id.split(PATH_SEPARATOR)\n\n  return versionId\n}\n\n/** @internal */\nexport function getPublishedId(id: string): PublishedId {\n  if (isVersionId(id)) {\n    // make sure to only remove the versions prefix and the bundle name\n    return id.split(PATH_SEPARATOR).slice(2).join(PATH_SEPARATOR) as PublishedId as PublishedId\n  }\n\n  if (isDraftId(id)) {\n    return id.slice(DRAFTS_PREFIX.length) as PublishedId\n  }\n\n  return id as PublishedId\n}\n", "import * as studioPath from './studioPath'\nimport type {\n  ContentSourceMapParsedPath,\n  ContentSourceMapParsedPathKeyedSegment,\n  ContentSourceMapPaths,\n  Path,\n} from './types'\n\nconst ESCAPE: Record<string, string> = {\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  \"'\": \"\\\\'\",\n  '\\\\': '\\\\\\\\',\n}\n\nconst UNESCAPE: Record<string, string> = {\n  '\\\\f': '\\f',\n  '\\\\n': '\\n',\n  '\\\\r': '\\r',\n  '\\\\t': '\\t',\n  \"\\\\'\": \"'\",\n  '\\\\\\\\': '\\\\',\n}\n\n/**\n * @internal\n */\nexport function jsonPath(path: ContentSourceMapParsedPath): ContentSourceMapPaths[number] {\n  return `$${path\n    .map((segment) => {\n      if (typeof segment === 'string') {\n        const escapedKey = segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => {\n          return ESCAPE[match]\n        })\n        return `['${escapedKey}']`\n      }\n\n      if (typeof segment === 'number') {\n        return `[${segment}]`\n      }\n\n      if (segment._key !== '') {\n        const escapedKey = segment._key.replace(/['\\\\]/g, (match) => {\n          return ESCAPE[match]\n        })\n        return `[?(@._key=='${escapedKey}')]`\n      }\n\n      return `[${segment._index}]`\n    })\n    .join('')}`\n}\n\n/**\n * @internal\n */\nexport function parseJsonPath(path: ContentSourceMapPaths[number]): ContentSourceMapParsedPath {\n  const parsed: ContentSourceMapParsedPath = []\n\n  const parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g\n  let match: RegExpExecArray | null\n\n  while ((match = parseRe.exec(path)) !== null) {\n    if (match[1] !== undefined) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => {\n        return UNESCAPE[m]\n      })\n\n      parsed.push(key)\n      continue\n    }\n\n    if (match[2] !== undefined) {\n      parsed.push(parseInt(match[2], 10))\n      continue\n    }\n\n    if (match[3] !== undefined) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => {\n        return UNESCAPE[m]\n      })\n\n      parsed.push({\n        _key,\n        _index: -1,\n      })\n      continue\n    }\n  }\n\n  return parsed\n}\n\n/**\n * @internal\n */\nexport function jsonPathToStudioPath(path: ContentSourceMapParsedPath): Path {\n  return path.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (segment._key !== '') {\n      return {_key: segment._key}\n    }\n\n    if (segment._index !== -1) {\n      return segment._index\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n\n/**\n * @internal\n */\nexport function studioPathToJsonPath(path: Path | string): ContentSourceMapParsedPath {\n  const parsedPath = typeof path === 'string' ? studioPath.fromString(path) : path\n\n  return parsedPath.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (Array.isArray(segment)) {\n      throw new Error(`IndexTuple segments aren't supported:${JSON.stringify(segment)}`)\n    }\n\n    if (isContentSourceMapParsedPathKeyedSegment(segment)) {\n      return segment\n    }\n\n    if (segment._key) {\n      return {_key: segment._key, _index: -1}\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n\nfunction isContentSourceMapParsedPathKeyedSegment(\n  segment: studioPath.PathSegment | ContentSourceMapParsedPath[number],\n): segment is ContentSourceMapParsedPathKeyedSegment {\n  return typeof segment === 'object' && '_key' in segment && '_index' in segment\n}\n\n/**\n * @internal\n */\nexport function jsonPathToMappingPath(path: ContentSourceMapParsedPath): (string | number)[] {\n  return path.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (segment._index !== -1) {\n      return segment._index\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n", "import {jsonPath, jsonPathToMappingPath} from './jsonPath'\nimport type {ContentSourceMap, ContentSourceMapMapping, ContentSourceMapParsedPath} from './types'\n\n/**\n * @internal\n */\nexport function resolveMapping(\n  resultPath: ContentSourceMapParsedPath,\n  csm?: ContentSourceMap,\n):\n  | {\n      mapping: ContentSourceMapMapping\n      matchedPath: string\n      pathSuffix: string\n    }\n  | undefined {\n  if (!csm?.mappings) {\n    return undefined\n  }\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath))\n\n  if (csm.mappings[resultMappingPath] !== undefined) {\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: '',\n    }\n  }\n\n  const mappings = Object.entries(csm.mappings)\n    .filter(([key]) => resultMappingPath.startsWith(key))\n    .sort(([key1], [key2]) => key2.length - key1.length)\n\n  if (mappings.length == 0) {\n    return undefined\n  }\n\n  const [matchedPath, mapping] = mappings[0]\n  const pathSuffix = resultMappingPath.substring(matchedPath.length)\n  return {mapping, matchedPath, pathSuffix}\n}\n", "/** @internal */\nexport function isArray(value: unknown): value is Array<unknown> {\n  return value !== null && Array.isArray(value)\n}\n", "/** @internal */\nexport function isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null\n}\n", "import {isArray} from './isArray'\nimport {isRecord} from './isRecord'\nimport type {ContentSourceMapParsedPath, WalkMapFn} from './types'\n\n/**\n * generic way to walk a nested object or array and apply a mapping function to each value\n * @internal\n */\nexport function walkMap(\n  value: unknown,\n  mappingFn: WalkMapFn,\n  path: ContentSourceMapParsedPath = [],\n): unknown {\n  if (isArray(value)) {\n    return value.map((v, idx) => {\n      if (isRecord(v)) {\n        const _key = v['_key']\n        if (typeof _key === 'string') {\n          return walkMap(v, mappingFn, path.concat({_key, _index: idx}))\n        }\n      }\n\n      return walkMap(v, mappingFn, path.concat(idx))\n    })\n  }\n\n  if (isRecord(value)) {\n    // Handle Portable Text in a faster way\n    if (value._type === 'block' || value._type === 'span') {\n      const result = {...value}\n      if (value._type === 'block') {\n        result.children = walkMap(value.children, mappingFn, path.concat('children'))\n      } else if (value._type === 'span') {\n        result.text = walkMap(value.text, mappingFn, path.concat('text'))\n      }\n      return result\n    }\n\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))]),\n    )\n  }\n\n  return mappingFn(value, path)\n}\n", "import {getPublishedId, getVersionFromId, isPublishedId, isVersionId} from './draftUtils'\nimport {jsonPathToStudioPath} from './jsonPath'\nimport * as studioPath from './studioPath'\nimport type {CreateEditUrlOptions, EditIntentUrl, StudioBaseUrl} from './types'\n\n/** @internal */\nexport function createEditUrl(options: CreateEditUrlOptions): `${StudioBaseUrl}${EditIntentUrl}` {\n  const {\n    baseUrl,\n    workspace: _workspace = 'default',\n    tool: _tool = 'default',\n    id: _id,\n    type,\n    path,\n    projectId,\n    dataset,\n  } = options\n\n  if (!baseUrl) {\n    throw new Error('baseUrl is required')\n  }\n  if (!path) {\n    throw new Error('path is required')\n  }\n  if (!_id) {\n    throw new Error('id is required')\n  }\n  if (baseUrl !== '/' && baseUrl.endsWith('/')) {\n    throw new Error('baseUrl must not end with a slash')\n  }\n\n  const workspace = _workspace === 'default' ? undefined : _workspace\n  const tool = _tool === 'default' ? undefined : _tool\n  const id = getPublishedId(_id)\n  const stringifiedPath = Array.isArray(path)\n    ? studioPath.toString(jsonPathToStudioPath(path))\n    : path\n\n  // eslint-disable-next-line no-warning-comments\n  // @TODO Using searchParams as a temporary workaround until `@sanity/overlays` can decode state from the path reliably\n  const searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath,\n  })\n  if (workspace) {\n    searchParams.set('workspace', workspace)\n  }\n  if (tool) {\n    searchParams.set('tool', tool)\n  }\n  if (projectId) {\n    searchParams.set('projectId', projectId)\n  }\n  if (dataset) {\n    searchParams.set('dataset', dataset)\n  }\n  if (isPublishedId(_id)) {\n    searchParams.set('perspective', 'published')\n  } else if (isVersionId(_id)) {\n    const versionId = getVersionFromId(_id)!\n    searchParams.set('perspective', versionId)\n  }\n\n  const segments = [baseUrl === '/' ? '' : baseUrl]\n  if (workspace) {\n    segments.push(workspace)\n  }\n  const routerParams = [\n    'mode=presentation',\n    `id=${id}`,\n    `type=${type}`,\n    `path=${encodeURIComponent(stringifiedPath)}`,\n  ]\n  if (tool) {\n    routerParams.push(`tool=${tool}`)\n  }\n  segments.push('intent', 'edit', `${routerParams.join(';')}?${searchParams}`)\n  return segments.join('/') as unknown as `${StudioBaseUrl}${EditIntentUrl}`\n}\n", "import {parseJsonPath} from './jsonPath'\nimport {resolveMapping} from './resolveMapping'\nimport type {\n  CreateEditUrlOptions,\n  ResolveEditInfoOptions,\n  StudioBaseRoute,\n  StudioBaseUrl,\n  StudioUrl,\n} from './types'\n\n/** @internal */\nexport function resolveEditInfo(options: ResolveEditInfoOptions): CreateEditUrlOptions | undefined {\n  const {resultSourceMap: csm, resultPath} = options\n  const {mapping, pathSuffix} = resolveMapping(resultPath, csm) || {}\n\n  if (!mapping) {\n    // console.warn('no mapping for path', { path: resultPath, sourceMap: csm })\n    return undefined\n  }\n\n  if (mapping.source.type === 'literal') {\n    return undefined\n  }\n\n  if (mapping.source.type === 'unknown') {\n    return undefined\n  }\n\n  const sourceDoc = csm.documents[mapping.source.document]\n  const sourcePath = csm.paths[mapping.source.path]\n\n  if (sourceDoc && sourcePath) {\n    const {baseUrl, workspace, tool} = resolveStudioBaseRoute(\n      typeof options.studioUrl === 'function' ? options.studioUrl(sourceDoc) : options.studioUrl,\n    )\n    if (!baseUrl) return undefined\n    const {_id, _type, _projectId, _dataset} = sourceDoc\n    return {\n      baseUrl,\n      workspace,\n      tool,\n      id: _id,\n      type: _type,\n      path: parseJsonPath(sourcePath + pathSuffix),\n      projectId: _projectId,\n      dataset: _dataset,\n    } satisfies CreateEditUrlOptions\n  }\n\n  return undefined\n}\n\n/** @internal */\nexport function resolveStudioBaseRoute(studioUrl: StudioUrl): StudioBaseRoute {\n  let baseUrl: StudioBaseUrl = typeof studioUrl === 'string' ? studioUrl : studioUrl.baseUrl\n  if (baseUrl !== '/') {\n    baseUrl = baseUrl.replace(/\\/$/, '')\n  }\n  if (typeof studioUrl === 'string') {\n    return {baseUrl}\n  }\n  return {...studioUrl, baseUrl}\n}\n", "const BASE_URL = 'https://www.sanity.io/help/'\n\nexport function generateHelpUrl(slug: string) {\n  return BASE_URL + slug\n}\n", "import type {Any, InitializedClientConfig} from './types'\n\nconst VALID_ASSET_TYPES = ['image', 'file']\nconst VALID_INSERT_LOCATIONS = ['before', 'after', 'replace']\n\nexport const dataset = (name: string) => {\n  if (!/^(~[a-z0-9]{1}[-\\w]{0,63}|[a-z0-9]{1}[-\\w]{0,63})$/.test(name)) {\n    throw new Error(\n      'Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 64 characters',\n    )\n  }\n}\n\nexport const projectId = (id: string) => {\n  if (!/^[-a-z0-9]+$/i.test(id)) {\n    throw new Error('`projectId` can only contain only a-z, 0-9 and dashes')\n  }\n}\n\nexport const validateAssetType = (type: string) => {\n  if (VALID_ASSET_TYPES.indexOf(type) === -1) {\n    throw new Error(`Invalid asset type: ${type}. Must be one of ${VALID_ASSET_TYPES.join(', ')}`)\n  }\n}\n\nexport const validateObject = (op: string, val: Any) => {\n  if (val === null || typeof val !== 'object' || Array.isArray(val)) {\n    throw new Error(`${op}() takes an object of properties`)\n  }\n}\n\nexport const validateDocumentId = (op: string, id: string) => {\n  if (typeof id !== 'string' || !/^[a-z0-9_][a-z0-9_.-]{0,127}$/i.test(id) || id.includes('..')) {\n    throw new Error(`${op}(): \"${id}\" is not a valid document ID`)\n  }\n}\n\nexport const requireDocumentId = (op: string, doc: Record<string, Any>) => {\n  if (!doc._id) {\n    throw new Error(`${op}() requires that the document contains an ID (\"_id\" property)`)\n  }\n\n  validateDocumentId(op, doc._id)\n}\n\nexport const validateInsert = (at: string, selector: string, items: Any[]) => {\n  const signature = 'insert(at, selector, items)'\n  if (VALID_INSERT_LOCATIONS.indexOf(at) === -1) {\n    const valid = VALID_INSERT_LOCATIONS.map((loc) => `\"${loc}\"`).join(', ')\n    throw new Error(`${signature} takes an \"at\"-argument which is one of: ${valid}`)\n  }\n\n  if (typeof selector !== 'string') {\n    throw new Error(`${signature} takes a \"selector\"-argument which must be a string`)\n  }\n\n  if (!Array.isArray(items)) {\n    throw new Error(`${signature} takes an \"items\"-argument which must be an array`)\n  }\n}\n\nexport const hasDataset = (config: InitializedClientConfig): string => {\n  if (!config.dataset) {\n    throw new Error('`dataset` must be provided to perform queries')\n  }\n\n  return config.dataset || ''\n}\n\nexport const requestTag = (tag: string) => {\n  if (typeof tag !== 'string' || !/^[a-z0-9._-]{1,75}$/i.test(tag)) {\n    throw new Error(\n      `Tag can only contain alphanumeric characters, underscores, dashes and dots, and be between one and 75 characters long.`,\n    )\n  }\n\n  return tag\n}\n", "import type {Any} from '../types'\n\nexport function once(fn: Any) {\n  let didCall = false\n  let returnValue: Any\n  return (...args: Any[]) => {\n    if (didCall) {\n      return returnValue\n    }\n    returnValue = fn(...args)\n    didCall = true\n    return returnValue\n  }\n}\n", "import {generateHelpUrl} from './generateHelpUrl'\nimport {type Any} from './types'\nimport {once} from './util/once'\n\nconst createWarningPrinter = (message: string[]) =>\n  // eslint-disable-next-line no-console\n  once((...args: Any[]) => console.warn(message.join(' '), ...args))\n\nexport const printCdnAndWithCredentialsWarning = createWarningPrinter([\n  `Because you set \\`withCredentials\\` to true, we will override your \\`useCdn\\``,\n  `setting to be false since (cookie-based) credentials are never set on the CDN`,\n])\n\nexport const printCdnWarning = createWarningPrinter([\n  `Since you haven't set a value for \\`useCdn\\`, we will deliver content using our`,\n  `global, edge-cached API-CDN. If you wish to have content delivered faster, set`,\n  `\\`useCdn: false\\` to use the Live API. Note: You may incur higher costs using the live API.`,\n])\n\nexport const printCdnPreviewDraftsWarning = createWarningPrinter([\n  `The Sanity client is configured with the \\`perspective\\` set to \\`previewDrafts\\`, which doesn't support the API-CDN.`,\n  `The Live API will be used instead. Set \\`useCdn: false\\` in your configuration to hide this warning.`,\n])\n\nexport const printBrowserTokenWarning = createWarningPrinter([\n  'You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.',\n  `See ${generateHelpUrl(\n    'js-client-browser-token',\n  )} for more information and how to hide this warning.`,\n])\n\nexport const printNoApiVersionSpecifiedWarning = createWarningPrinter([\n  'Using the Sanity client without specifying an API version is deprecated.',\n  `See ${generateHelpUrl('js-client-api-version')}`,\n])\n\nexport const printNoDefaultExport = createWarningPrinter([\n  'The default export of @sanity/client has been deprecated. Use the named export `createClient` instead.',\n])\n", "import {generateHelpUrl} from './generateHelpUrl'\nimport type {ClientConfig, ClientPerspective, InitializedClientConfig} from './types'\nimport * as validate from './validators'\nimport * as warnings from './warnings'\n\nconst defaultCdnHost = 'apicdn.sanity.io'\nexport const defaultConfig = {\n  apiHost: 'https://api.sanity.io',\n  apiVersion: '1',\n  useProjectHostname: true,\n  stega: {enabled: false},\n} satisfies ClientConfig\n\nconst LOCALHOSTS = ['localhost', '127.0.0.1', '0.0.0.0']\nconst isLocal = (host: string) => LOCALHOSTS.indexOf(host) !== -1\n\nfunction validateApiVersion(apiVersion: string) {\n  if (apiVersion === '1' || apiVersion === 'X') {\n    return\n  }\n\n  const apiDate = new Date(apiVersion)\n  const apiVersionValid =\n    /^\\d{4}-\\d{2}-\\d{2}$/.test(apiVersion) && apiDate instanceof Date && apiDate.getTime() > 0\n\n  if (!apiVersionValid) {\n    throw new Error('Invalid API version string, expected `1` or date in format `YYYY-MM-DD`')\n  }\n}\n\n/**\n * @internal - it may have breaking changes in any release\n */\nexport function validateApiPerspective(\n  perspective: unknown,\n): asserts perspective is ClientPerspective {\n  if (Array.isArray(perspective)) {\n    for (const perspectiveValue of perspective) {\n      if (perspectiveValue === 'published') {\n        continue\n      }\n      if (perspectiveValue === 'drafts') {\n        continue\n      }\n      if (\n        typeof perspectiveValue === 'string' &&\n        perspectiveValue.startsWith('r') &&\n        perspectiveValue !== 'raw'\n      ) {\n        continue\n      }\n      throw new TypeError(\n        'Invalid API perspective value, expected `published`, `drafts` or a valid release identifier string',\n      )\n    }\n    return\n  }\n  switch (perspective as ClientPerspective) {\n    case 'previewDrafts':\n    case 'drafts':\n    case 'published':\n    case 'raw':\n      return\n    default:\n      throw new TypeError(\n        'Invalid API perspective string, expected `published`, `previewDrafts` or `raw`',\n      )\n  }\n}\n\nexport const initConfig = (\n  config: Partial<ClientConfig>,\n  prevConfig: Partial<ClientConfig>,\n): InitializedClientConfig => {\n  const specifiedConfig = {\n    ...prevConfig,\n    ...config,\n    stega: {\n      ...(typeof prevConfig.stega === 'boolean'\n        ? {enabled: prevConfig.stega}\n        : prevConfig.stega || defaultConfig.stega),\n      ...(typeof config.stega === 'boolean' ? {enabled: config.stega} : config.stega || {}),\n    },\n  }\n  if (!specifiedConfig.apiVersion) {\n    warnings.printNoApiVersionSpecifiedWarning()\n  }\n\n  const newConfig = {\n    ...defaultConfig,\n    ...specifiedConfig,\n  } as InitializedClientConfig\n  const projectBased = newConfig.useProjectHostname\n\n  if (typeof Promise === 'undefined') {\n    const helpUrl = generateHelpUrl('js-client-promise-polyfill')\n    throw new Error(`No native Promise-implementation found, polyfill needed - see ${helpUrl}`)\n  }\n\n  if (projectBased && !newConfig.projectId) {\n    throw new Error('Configuration must contain `projectId`')\n  }\n\n  if (typeof newConfig.perspective !== 'undefined') {\n    validateApiPerspective(newConfig.perspective)\n  }\n\n  if ('encodeSourceMap' in newConfig) {\n    throw new Error(\n      `It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMap' is not supported in '@sanity/client'. Did you mean 'stega.enabled'?`,\n    )\n  }\n  if ('encodeSourceMapAtPath' in newConfig) {\n    throw new Error(\n      `It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMapAtPath' is not supported in '@sanity/client'. Did you mean 'stega.filter'?`,\n    )\n  }\n  if (typeof newConfig.stega.enabled !== 'boolean') {\n    throw new Error(`stega.enabled must be a boolean, received ${newConfig.stega.enabled}`)\n  }\n  if (newConfig.stega.enabled && newConfig.stega.studioUrl === undefined) {\n    throw new Error(`stega.studioUrl must be defined when stega.enabled is true`)\n  }\n  if (\n    newConfig.stega.enabled &&\n    typeof newConfig.stega.studioUrl !== 'string' &&\n    typeof newConfig.stega.studioUrl !== 'function'\n  ) {\n    throw new Error(\n      `stega.studioUrl must be a string or a function, received ${newConfig.stega.studioUrl}`,\n    )\n  }\n\n  const isBrowser = typeof window !== 'undefined' && window.location && window.location.hostname\n  const isLocalhost = isBrowser && isLocal(window.location.hostname)\n\n  if (isBrowser && isLocalhost && newConfig.token && newConfig.ignoreBrowserTokenWarning !== true) {\n    warnings.printBrowserTokenWarning()\n  } else if (typeof newConfig.useCdn === 'undefined') {\n    warnings.printCdnWarning()\n  }\n\n  if (projectBased) {\n    validate.projectId(newConfig.projectId!)\n  }\n\n  if (newConfig.dataset) {\n    validate.dataset(newConfig.dataset)\n  }\n\n  if ('requestTagPrefix' in newConfig) {\n    // Allow setting and unsetting request tag prefix\n    newConfig.requestTagPrefix = newConfig.requestTagPrefix\n      ? validate.requestTag(newConfig.requestTagPrefix).replace(/\\.+$/, '')\n      : undefined\n  }\n\n  newConfig.apiVersion = `${newConfig.apiVersion}`.replace(/^v/, '')\n  newConfig.isDefaultApi = newConfig.apiHost === defaultConfig.apiHost\n\n  if (newConfig.useCdn === true && newConfig.withCredentials) {\n    warnings.printCdnAndWithCredentialsWarning()\n  }\n\n  // If `useCdn` is undefined, we treat it as `true`\n  newConfig.useCdn = newConfig.useCdn !== false && !newConfig.withCredentials\n\n  validateApiVersion(newConfig.apiVersion)\n\n  const hostParts = newConfig.apiHost.split('://', 2)\n  const protocol = hostParts[0]\n  const host = hostParts[1]\n  const cdnHost = newConfig.isDefaultApi ? defaultCdnHost : host\n\n  if (newConfig.useProjectHostname) {\n    newConfig.url = `${protocol}://${newConfig.projectId}.${host}/v${newConfig.apiVersion}`\n    newConfig.cdnUrl = `${protocol}://${newConfig.projectId}.${cdnHost}/v${newConfig.apiVersion}`\n  } else {\n    newConfig.url = `${newConfig.apiHost}/v${newConfig.apiVersion}`\n    newConfig.cdnUrl = newConfig.url\n  }\n\n  return newConfig\n}\n", "import {validateApiPerspective} from '../config'\nimport type {ReleaseId} from '../types'\nimport type {ClientPerspective} from './types'\n\n/**\n * This resolves the perspectives to how documents should be resolved when applying optimistic updates,\n * like in `applySourceDocuments`.\n * @internal\n */\nexport function resolvePerspectives(\n  perspective: Exclude<ClientPerspective, 'raw'>,\n): ('published' | 'drafts' | ReleaseId)[] {\n  validateApiPerspective(perspective)\n\n  if (Array.isArray(perspective)) {\n    if (!perspective.includes('published')) {\n      return [...perspective, 'published']\n    }\n    return perspective\n  }\n  switch (perspective) {\n    case 'previewDrafts':\n    case 'drafts':\n      return ['drafts', 'published']\n    case 'published':\n    default:\n      return ['published']\n  }\n}\n", "import {getDraftId, getPublishedId, getVersionId} from './draftUtils'\nimport {resolvePerspectives} from './resolvePerspectives'\nimport type {ClientPerspective, ContentSourceMapDocuments, SanityDocument} from './types'\n\n/** @internal */\nexport type ResolvedDocument = Partial<SanityDocument> &\n  Required<Pick<SanityDocument, '_id' | '_type'>>\n\n/** @internal */\nexport type MatchedDocument = Partial<SanityDocument> &\n  Required<Pick<SanityDocument, '_id' | '_type' | '_originalId'>>\n\n/** @internal */\nexport function createSourceDocumentResolver(\n  getCachedDocument: (\n    sourceDocument: ContentSourceMapDocuments[number],\n  ) => ResolvedDocument | null | undefined,\n  _perspective: Exclude<ClientPerspective, 'raw'>,\n) {\n  const perspectives = resolvePerspectives(_perspective)\n  function findDocument(sourceDocument: ContentSourceMapDocuments[number]) {\n    for (const perspective of perspectives) {\n      let match: ReturnType<typeof getCachedDocument> = null\n      if (perspective.startsWith('r')) {\n        match = getCachedDocument({\n          ...sourceDocument,\n          _id: getVersionId(sourceDocument._id, perspective),\n        })\n      }\n      if (perspective === 'drafts') {\n        match = getCachedDocument({\n          ...sourceDocument,\n          _id: getDraftId(sourceDocument._id),\n        })\n      }\n      if (perspective === 'published') {\n        match = getCachedDocument({\n          ...sourceDocument,\n          _id: getPublishedId(sourceDocument._id),\n        })\n      }\n      if (match) {\n        return {...match, _id: getPublishedId(match._id), _originalId: match._id}\n      }\n    }\n    return null\n  }\n  // define resolver that loops over source documents and perspectives\n  return function resolveSourceDocument(\n    sourceDocument: ContentSourceMapDocuments[number],\n  ): MatchedDocument | null {\n    return findDocument(sourceDocument)\n  }\n}\n", "import {createSourceDocumentResolver} from './createSourceDocumentResolver'\nimport {parseJsonPath} from './jsonPath'\nimport {resolveMapping} from './resolveMapping'\nimport * as paths from './studioPath'\nimport type {\n  Any,\n  ApplySourceDocumentsUpdateFunction,\n  ClientPerspective,\n  ContentSourceMap,\n  ContentSourceMapDocuments,\n  Path,\n  SanityDocument,\n} from './types'\nimport {walkMap} from './walkMap'\n\n/**\n * Optimistically applies source documents to a result, using the content source map to trace fields.\n * Can be used to apply mutations to documents being edited in a Studio, or any mutation on Content Lake, to a result with extremely low latency.\n * @alpha\n */\nexport function applySourceDocuments<Result = unknown>(\n  result: Result,\n  resultSourceMap: ContentSourceMap | undefined,\n  getCachedDocument: (\n    sourceDocument: ContentSourceMapDocuments[number],\n  ) =>\n    | (Partial<SanityDocument> & Required<Pick<SanityDocument, '_id' | '_type'>>)\n    | null\n    | undefined,\n  updateFn: ApplySourceDocumentsUpdateFunction,\n  perspective: Exclude<ClientPerspective, 'raw'>,\n): Result {\n  if (!resultSourceMap) return result\n\n  const resolveDocument = createSourceDocumentResolver(getCachedDocument, perspective)\n  const cachedDocuments = resultSourceMap.documents?.map?.(resolveDocument) || []\n\n  return walkMap(JSON.parse(JSON.stringify(result)), (value, path) => {\n    const resolveMappingResult = resolveMapping(path, resultSourceMap)\n    if (!resolveMappingResult) {\n      return value\n    }\n\n    const {mapping, pathSuffix} = resolveMappingResult\n    if (mapping.type !== 'value') {\n      return value\n    }\n\n    if (mapping.source.type !== 'documentValue') {\n      return value\n    }\n\n    const sourceDocument = resultSourceMap.documents[mapping.source.document]\n    const sourcePath = resultSourceMap.paths[mapping.source.path]\n\n    if (sourceDocument) {\n      const parsedPath = parseJsonPath(sourcePath + pathSuffix)\n      const stringifiedPath = paths.toString(parsedPath as Path)\n      const cachedDocument = cachedDocuments[mapping.source.document]\n\n      if (!cachedDocument) {\n        return value\n      }\n\n      const changedValue = cachedDocument\n        ? paths.get<Result[keyof Result]>(cachedDocument, stringifiedPath, value)\n        : value\n      return value === changedValue\n        ? value\n        : updateFn<Result[keyof Result]>(changedValue as Any, {\n            cachedDocument,\n            previousValue: value as Result[keyof Result],\n            sourceDocument,\n            sourcePath: parsedPath,\n          })\n    }\n\n    return value\n  }) as Result\n}\n", "import {jsonPath, parseJsonPath} from './jsonPath'\nimport type {ContentSourceMapParsedPath} from './types'\n\n/**\n * @internal\n */\nexport function resolvedKeyedSourcePath(options: {\n  keyedResultPath: ContentSourceMapParsedPath\n  pathSuffix?: string\n  sourceBasePath: string\n}): ContentSourceMapParsedPath {\n  const {keyedResultPath, pathSuffix, sourceBasePath} = options\n\n  const inferredResultPath = pathSuffix === undefined ? [] : parseJsonPath(pathSuffix)\n\n  const inferredPath = keyedResultPath.slice(keyedResultPath.length - inferredResultPath.length)\n\n  const inferredPathSuffix = inferredPath.length ? jsonPath(inferredPath).slice(1) : ''\n\n  return parseJsonPath(sourceBasePath + inferredPathSuffix)\n}\n", "import {createEditUrl} from './createEditUrl'\nimport {studioPathToJsonPath} from './jsonPath'\nimport {resolveEditInfo} from './resolveEditInfo'\nimport type {ResolveEditUrlOptions} from './types'\n\n/** @alpha */\nexport function resolveEditUrl(\n  options: ResolveEditUrlOptions,\n): ReturnType<typeof createEditUrl> | undefined {\n  const {resultSourceMap, studioUrl} = options\n  const resultPath = studioPathToJsonPath(options.resultPath)\n\n  const editInfo = resolveEditInfo({\n    resultPath,\n    resultSourceMap,\n    studioUrl,\n  })\n  if (!editInfo) {\n    return undefined\n  }\n\n  return createEditUrl(editInfo)\n}\n", "const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n", "let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n", "export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;\n", "import REGEX from './regex.js';\nfunction validate(uuid) {\n    return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;\n", "import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nexport default v4;\n", "import validate from './validate.js';\nfunction parse(uuid) {\n    if (!validate(uuid)) {\n        throw TypeError('Invalid UUID');\n    }\n    let v;\n    return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 0xff, ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff, (v / 0x100000000) & 0xff, (v >>> 24) & 0xff, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff);\n}\nexport default parse;\n", "function md5(bytes) {\n    const words = uint8ToUint32(bytes);\n    const md5Bytes = wordsToMd5(words, bytes.length * 8);\n    return uint32ToUint8(md5Bytes);\n}\nfunction uint32ToUint8(input) {\n    const bytes = new Uint8Array(input.length * 4);\n    for (let i = 0; i < input.length * 4; i++) {\n        bytes[i] = (input[i >> 2] >>> ((i % 4) * 8)) & 0xff;\n    }\n    return bytes;\n}\nfunction getOutputLength(inputLength8) {\n    return (((inputLength8 + 64) >>> 9) << 4) + 14 + 1;\n}\nfunction wordsToMd5(x, len) {\n    const xpad = new Uint32Array(getOutputLength(len)).fill(0);\n    xpad.set(x);\n    xpad[len >> 5] |= 0x80 << len % 32;\n    xpad[xpad.length - 1] = len;\n    x = xpad;\n    let a = 1732584193;\n    let b = -271733879;\n    let c = -1732584194;\n    let d = 271733878;\n    for (let i = 0; i < x.length; i += 16) {\n        const olda = a;\n        const oldb = b;\n        const oldc = c;\n        const oldd = d;\n        a = md5ff(a, b, c, d, x[i], 7, -680876936);\n        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n        b = md5gg(b, c, d, a, x[i], 20, -373897302);\n        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n        d = md5hh(d, a, b, c, x[i], 11, -358537222);\n        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n        a = md5ii(a, b, c, d, x[i], 6, -198630844);\n        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n        a = safeAdd(a, olda);\n        b = safeAdd(b, oldb);\n        c = safeAdd(c, oldc);\n        d = safeAdd(d, oldd);\n    }\n    return Uint32Array.of(a, b, c, d);\n}\nfunction uint8ToUint32(input) {\n    if (input.length === 0) {\n        return new Uint32Array();\n    }\n    const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);\n    for (let i = 0; i < input.length; i++) {\n        output[i >> 2] |= (input[i] & 0xff) << ((i % 4) * 8);\n    }\n    return output;\n}\nfunction safeAdd(x, y) {\n    const lsw = (x & 0xffff) + (y & 0xffff);\n    const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return (msw << 16) | (lsw & 0xffff);\n}\nfunction bitRotateLeft(num, cnt) {\n    return (num << cnt) | (num >>> (32 - cnt));\n}\nfunction md5cmn(q, a, b, x, s, t) {\n    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\nfunction md5ff(a, b, c, d, x, s, t) {\n    return md5cmn((b & c) | (~b & d), a, b, x, s, t);\n}\nfunction md5gg(a, b, c, d, x, s, t) {\n    return md5cmn((b & d) | (c & ~d), a, b, x, s, t);\n}\nfunction md5hh(a, b, c, d, x, s, t) {\n    return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\nfunction md5ii(a, b, c, d, x, s, t) {\n    return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\nexport default md5;\n", "import parse from './parse.js';\nimport { unsafeStringify } from './stringify.js';\nexport function stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    const bytes = new Uint8Array(str.length);\n    for (let i = 0; i < str.length; ++i) {\n        bytes[i] = str.charCodeAt(i);\n    }\n    return bytes;\n}\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function v35(version, hash, value, namespace, buf, offset) {\n    const valueBytes = typeof value === 'string' ? stringToBytes(value) : value;\n    const namespaceBytes = typeof namespace === 'string' ? parse(namespace) : namespace;\n    if (typeof namespace === 'string') {\n        namespace = parse(namespace);\n    }\n    if (namespace?.length !== 16) {\n        throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n    let bytes = new Uint8Array(16 + valueBytes.length);\n    bytes.set(namespaceBytes);\n    bytes.set(valueBytes, namespaceBytes.length);\n    bytes = hash(bytes);\n    bytes[6] = (bytes[6] & 0x0f) | version;\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = bytes[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(bytes);\n}\n", "import md5 from './md5.js';\nimport v35, { DNS, URL } from './v35.js';\nexport { DNS, URL } from './v35.js';\nfunction v3(value, namespace, buf, offset) {\n    return v35(0x30, md5, value, namespace, buf, offset);\n}\nv3.DNS = DNS;\nv3.URL = URL;\nexport default v3;\n", "function f(s, x, y, z) {\n    switch (s) {\n        case 0:\n            return (x & y) ^ (~x & z);\n        case 1:\n            return x ^ y ^ z;\n        case 2:\n            return (x & y) ^ (x & z) ^ (y & z);\n        case 3:\n            return x ^ y ^ z;\n    }\n}\nfunction ROTL(x, n) {\n    return (x << n) | (x >>> (32 - n));\n}\nfunction sha1(bytes) {\n    const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n    const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n    const newBytes = new Uint8Array(bytes.length + 1);\n    newBytes.set(bytes);\n    newBytes[bytes.length] = 0x80;\n    bytes = newBytes;\n    const l = bytes.length / 4 + 2;\n    const N = Math.ceil(l / 16);\n    const M = new Array(N);\n    for (let i = 0; i < N; ++i) {\n        const arr = new Uint32Array(16);\n        for (let j = 0; j < 16; ++j) {\n            arr[j] =\n                (bytes[i * 64 + j * 4] << 24) |\n                    (bytes[i * 64 + j * 4 + 1] << 16) |\n                    (bytes[i * 64 + j * 4 + 2] << 8) |\n                    bytes[i * 64 + j * 4 + 3];\n        }\n        M[i] = arr;\n    }\n    M[N - 1][14] = ((bytes.length - 1) * 8) / Math.pow(2, 32);\n    M[N - 1][14] = Math.floor(M[N - 1][14]);\n    M[N - 1][15] = ((bytes.length - 1) * 8) & 0xffffffff;\n    for (let i = 0; i < N; ++i) {\n        const W = new Uint32Array(80);\n        for (let t = 0; t < 16; ++t) {\n            W[t] = M[i][t];\n        }\n        for (let t = 16; t < 80; ++t) {\n            W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n        }\n        let a = H[0];\n        let b = H[1];\n        let c = H[2];\n        let d = H[3];\n        let e = H[4];\n        for (let t = 0; t < 80; ++t) {\n            const s = Math.floor(t / 20);\n            const T = (ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t]) >>> 0;\n            e = d;\n            d = c;\n            c = ROTL(b, 30) >>> 0;\n            b = a;\n            a = T;\n        }\n        H[0] = (H[0] + a) >>> 0;\n        H[1] = (H[1] + b) >>> 0;\n        H[2] = (H[2] + c) >>> 0;\n        H[3] = (H[3] + d) >>> 0;\n        H[4] = (H[4] + e) >>> 0;\n    }\n    return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);\n}\nexport default sha1;\n", "import sha1 from './sha1.js';\nimport v35, { DNS, URL } from './v35.js';\nexport { DNS, URL } from './v35.js';\nfunction v5(value, namespace, buf, offset) {\n    return v35(0x50, sha1, value, namespace, buf, offset);\n}\nv5.DNS = DNS;\nv5.URL = URL;\nexport default v5;\n", "import {bufferCount, concatMap, defer, filter, fromEvent, map, pipe, take} from 'rxjs'\nimport {fromEventObservable} from 'xstate'\nimport type {ListenInput, ProtocolMessage} from './types'\n\nexport const listenInputFromContext =\n  (\n    config: (\n      | {\n          include: string | string[]\n          exclude?: string | string[]\n        }\n      | {\n          include?: string | string[]\n          exclude: string | string[]\n        }\n    ) & {\n      matches?: boolean\n      count?: number\n      responseType?: string\n    },\n  ) =>\n  <\n    TContext extends {\n      domain: string\n      connectTo: string\n      name: string\n      target: MessageEventSource | undefined\n    },\n  >({\n    context,\n  }: {\n    context: TContext\n  }): ListenInput => {\n    const {count, include, exclude, responseType = 'message.received'} = config\n    return {\n      count,\n      domain: context.domain,\n      from: context.connectTo,\n      include: include ? (Array.isArray(include) ? include : [include]) : [],\n      exclude: exclude ? (Array.isArray(exclude) ? exclude : [exclude]) : [],\n      responseType,\n      target: context.target,\n      to: context.name,\n    }\n  }\n\nexport const listenFilter =\n  (input: ListenInput) =>\n  (event: MessageEvent<ProtocolMessage>): boolean => {\n    const {data} = event\n    return (\n      (input.include.length ? input.include.includes(data.type) : true) &&\n      (input.exclude.length ? !input.exclude.includes(data.type) : true) &&\n      data.domain === input.domain &&\n      data.from === input.from &&\n      data.to === input.to &&\n      (!input.target || event.source === input.target)\n    )\n  }\n\nexport const eventToMessage =\n  <TType>(type: TType) =>\n  (\n    event: MessageEvent<ProtocolMessage>,\n  ): {type: TType; message: MessageEvent<ProtocolMessage>} => ({\n    type,\n    message: event,\n  })\n\nexport const messageEvents$ = defer(() =>\n  fromEvent<MessageEvent<ProtocolMessage>>(window, 'message'),\n)\n\n/**\n * @public\n */\nexport const createListenLogic = (\n  compatMap?: (event: MessageEvent<ProtocolMessage>) => MessageEvent<ProtocolMessage>,\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n) =>\n  fromEventObservable(({input}: {input: ListenInput}) => {\n    return messageEvents$.pipe(\n      compatMap ? map(compatMap) : pipe(),\n      filter(listenFilter(input)),\n      map(eventToMessage(input.responseType)),\n      input.count\n        ? pipe(\n            bufferCount(input.count),\n            concatMap((arr) => arr),\n            take(input.count),\n          )\n        : pipe(),\n    )\n  })\n", "import type {MessageType} from './types'\n\n/** @internal */\nexport const DOMAIN = 'sanity/comlink'\n\n/** @internal */\nexport const RESPONSE_TIMEOUT_DEFAULT = 3_000\n\n/** @internal */\nexport const FETCH_TIMEOUT_DEFAULT = 10_000\n\n/** @internal */\nexport const HEARTBEAT_INTERVAL = 1000\n\n/** @internal */\nexport const HANDSHAKE_INTERVAL = 500\n\n/**\n * @public\n */\nexport const MSG_RESPONSE = 'comlink/response'\n\n/**\n * @public\n */\nexport const MSG_HEARTBEAT = 'comlink/heartbeat'\n\n/** @internal */\nexport const MSG_DISCONNECT = 'comlink/disconnect'\n\n/** @internal */\nexport const MSG_HANDSHAKE_SYN = 'comlink/handshake/syn'\n\n/** @internal */\nexport const MSG_HANDSHAKE_SYN_ACK = 'comlink/handshake/syn-ack'\n\n/** @internal */\nexport const MSG_HANDSHAKE_ACK = 'comlink/handshake/ack'\n\n/** @internal */\nexport const HANDSHAKE_MSG_TYPES = [\n  MSG_HANDSHAKE_SYN,\n  MSG_HANDSHAKE_SYN_ACK,\n  MSG_HANDSHAKE_ACK,\n] satisfies MessageType[]\n\n/** @internal */\nexport const INTERNAL_MSG_TYPES = [\n  MSG_RESPONSE,\n  MSG_DISCONNECT,\n  MSG_HEARTBEAT,\n  ...HANDSHAKE_MSG_TYPES,\n] satisfies MessageType[]\n", "import {EMPTY, filter, fromEvent, map, take, takeUntil, type Observable} from 'rxjs'\nimport {v4 as uuid} from 'uuid'\nimport {\n  assign,\n  fromEventObservable,\n  sendTo,\n  setup,\n  type ActorRefFrom,\n  type AnyActorRef,\n} from 'xstate'\nimport {MSG_RESPONSE, RESPONSE_TIMEOUT_DEFAULT} from './constants'\nimport type {Message, MessageData, MessageType, ProtocolMessage, ResponseMessage} from './types'\n\nconst throwOnEvent =\n  <T>(message?: string) =>\n  (source: Observable<T>) =>\n    source.pipe(\n      take(1),\n      map(() => {\n        throw new Error(message)\n      }),\n    )\n\n/**\n * @public\n */\nexport interface RequestMachineContext<TSends extends Message> {\n  channelId: string\n  data: MessageData | undefined\n  domain: string\n  expectResponse: boolean\n  from: string\n  id: string\n  parentRef: AnyActorRef\n  resolvable: PromiseWithResolvers<TSends['response']> | undefined\n  response: TSends['response'] | null\n  responseTimeout: number | undefined\n  responseTo: string | undefined\n  signal: AbortSignal | undefined\n  suppressWarnings: boolean | undefined\n  sources: Set<MessageEventSource>\n  targetOrigin: string\n  to: string\n  type: MessageType\n}\n\n/**\n * @public\n */\nexport type RequestActorRef<TSends extends Message> = ActorRefFrom<\n  ReturnType<typeof createRequestMachine<TSends>>\n>\n\n/**\n * @public\n */\nexport const createRequestMachine = <\n  TSends extends Message,\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n>() => {\n  return setup({\n    types: {} as {\n      children: {\n        'listen for response': 'listen'\n      }\n      context: RequestMachineContext<TSends>\n      // @todo Should response types be specified?\n      events: {type: 'message'; data: ProtocolMessage<ResponseMessage>} | {type: 'abort'}\n      emitted:\n        | {type: 'request.failed'; requestId: string}\n        | {type: 'request.aborted'; requestId: string}\n        | {\n            type: 'request.success'\n            requestId: string\n            response: MessageData | null\n            responseTo: string | undefined\n          }\n      input: {\n        channelId: string\n        data?: TSends['data']\n        domain: string\n        expectResponse?: boolean\n        from: string\n        parentRef: AnyActorRef\n        resolvable?: PromiseWithResolvers<TSends['response']>\n        responseTimeout?: number\n        responseTo?: string\n        signal?: AbortSignal\n        sources: Set<MessageEventSource> | MessageEventSource\n        suppressWarnings?: boolean\n        targetOrigin: string\n        to: string\n        type: TSends['type']\n      }\n      output: {\n        requestId: string\n        response: TSends['response'] | null\n        responseTo: string | undefined\n      }\n    },\n    actors: {\n      listen: fromEventObservable(\n        ({\n          input,\n        }: {\n          input: {\n            requestId: string\n            sources: Set<MessageEventSource>\n            signal?: AbortSignal\n          }\n        }) => {\n          const abortSignal$ = input.signal\n            ? fromEvent(input.signal, 'abort').pipe(\n                throwOnEvent(`Request ${input.requestId} aborted`),\n              )\n            : EMPTY\n\n          const messageFilter = (event: MessageEvent<ProtocolMessage<ResponseMessage>>) =>\n            event.data?.type === MSG_RESPONSE &&\n            event.data?.responseTo === input.requestId &&\n            !!event.source &&\n            input.sources.has(event.source)\n\n          return fromEvent<MessageEvent<ProtocolMessage<ResponseMessage>>>(window, 'message').pipe(\n            filter(messageFilter),\n            take(input.sources.size),\n            takeUntil(abortSignal$),\n          )\n        },\n      ),\n    },\n    actions: {\n      'send message': ({context}, params: {message: ProtocolMessage}) => {\n        const {sources, targetOrigin} = context\n        const {message} = params\n\n        sources.forEach((source) => {\n          source.postMessage(message, {targetOrigin})\n        })\n      },\n      'on success': sendTo(\n        ({context}) => context.parentRef,\n        ({context, self}) => {\n          if (context.response) {\n            context.resolvable?.resolve(context.response)\n          }\n          return {\n            type: 'request.success',\n            requestId: self.id,\n            response: context.response,\n            responseTo: context.responseTo,\n          }\n        },\n      ),\n      'on fail': sendTo(\n        ({context}) => context.parentRef,\n        ({context, self}) => {\n          if (!context.suppressWarnings) {\n            // eslint-disable-next-line no-console\n            console.warn(\n              `[@sanity/comlink] Received no response to message '${context.type}' on client '${context.from}' (ID: '${context.id}').`,\n            )\n          }\n          context.resolvable?.reject(new Error('No response received'))\n          return {type: 'request.failed', requestId: self.id}\n        },\n      ),\n      'on abort': sendTo(\n        ({context}) => context.parentRef,\n        ({context, self}) => {\n          context.resolvable?.reject(new Error('Request aborted'))\n          return {type: 'request.aborted', requestId: self.id}\n        },\n      ),\n    },\n    guards: {\n      expectsResponse: ({context}) => context.expectResponse,\n    },\n    delays: {\n      initialTimeout: 0,\n      responseTimeout: ({context}) => context.responseTimeout ?? RESPONSE_TIMEOUT_DEFAULT,\n    },\n  }).createMachine({\n    /** @xstate-layout N4IgpgJg5mDOIC5QAoC2BDAxgCwJYDswBKAOlwgBswBiAD1gBd0GwT0AzFgJ2QNwdzoKAFVyowAewCuDItTRY8hUuSoBtAAwBdRKAAOE2P1wT8ukLUQBGAEwBWEgBYAnK+eOAzB7sB2DzY8rABoQAE9rDQc3V0cNTw8fAA4NHwBfVJCFHAJiElgwfAgCKGpNHSQQAyMBU3NLBDsrDxI7DTaAjQA2OOcNDxDwhHsNJx9Ou0TOq2cJxP9HdMyMbOU8gqL8ErUrcv1DY1qK+sbm1vaPLp6+gcRnGydo9wDGycWQLKVc9AB3dGNN6jiWCwdAwMrmKoHMxHRCJRKOEiJHwuZKBZwXKzBMKIGyYkhtAkXOweTqOHw2RJvD45Ug-P4CAH0JgsNicMA8LhwAz4fKicTSWTyZafWm-f5QcEVSE1aGgepwhFIlF9aYYrGDC4+JzEppjGzOUkeGbpDIgfASCBwczU5QQ-YyuqIAC0nRuCBd+IJXu9KSpwppZEoYDt1RMsosiEcNjdVjiJEeGisiSTHkcVgWpptuXyhWKIahjqGzi1BqRJINnVcdkcbuTLS9VYC8ISfsUAbp4vzDphCHJIyjBvJNlxNmRNexQ3sJGH43GPj8jWJrZWuXYfyoEC7YcLsbrgRsjkcvkmdgNbopVhIPhVfnsh8ClMz-tWsCkmEwcHgUvt257u8v+6Hse4xnhOdZnImVidPqCRNB4JqpEAA */\n    context: ({input}) => {\n      return {\n        channelId: input.channelId,\n        data: input.data,\n        domain: input.domain,\n        expectResponse: input.expectResponse ?? false,\n        from: input.from,\n        id: `msg-${uuid()}`,\n        parentRef: input.parentRef,\n        resolvable: input.resolvable,\n        response: null,\n        responseTimeout: input.responseTimeout,\n        responseTo: input.responseTo,\n        signal: input.signal,\n        sources: input.sources instanceof Set ? input.sources : new Set([input.sources]),\n        suppressWarnings: input.suppressWarnings,\n        targetOrigin: input.targetOrigin,\n        to: input.to,\n        type: input.type,\n      }\n    },\n    initial: 'idle',\n    on: {\n      abort: '.aborted',\n    },\n    states: {\n      idle: {\n        after: {\n          initialTimeout: [\n            {\n              target: 'sending',\n            },\n          ],\n        },\n      },\n      sending: {\n        entry: {\n          type: 'send message',\n          params: ({context}) => {\n            const {channelId, data, domain, from, id, responseTo, to, type} = context\n            const message = {\n              channelId,\n              data,\n              domain,\n              from,\n              id,\n              to,\n              type,\n              responseTo,\n            }\n            return {message}\n          },\n        },\n        always: [\n          {\n            guard: 'expectsResponse',\n            target: 'awaiting',\n          },\n          'success',\n        ],\n      },\n      awaiting: {\n        invoke: {\n          id: 'listen for response',\n          src: 'listen',\n          input: ({context}) => ({\n            requestId: context.id,\n            sources: context.sources,\n            signal: context.signal,\n          }),\n          onError: 'aborted',\n        },\n        after: {\n          responseTimeout: 'failed',\n        },\n        on: {\n          message: {\n            actions: assign({\n              response: ({event}) => event.data.data,\n              responseTo: ({event}) => event.data.responseTo,\n            }),\n            target: 'success',\n          },\n        },\n      },\n      failed: {\n        type: 'final',\n        entry: 'on fail',\n      },\n      success: {\n        type: 'final',\n        entry: 'on success',\n      },\n      aborted: {\n        type: 'final',\n        entry: 'on abort',\n      },\n    },\n    output: ({context, self}) => {\n      const output = {\n        requestId: self.id,\n        response: context.response,\n        responseTo: context.responseTo,\n      }\n      return output\n    },\n  })\n}\n\n// export const delayedRequestMachine = requestMachine.provide({\n//   delays: {\n//     initialTimeout: 500,\n//   },\n// })\n", "import {v4 as uuid} from 'uuid'\nimport {\n  assertEvent,\n  assign,\n  createActor,\n  emit,\n  enqueueActions,\n  fromCallback,\n  raise,\n  setup,\n  stopChild,\n  type ActorRefFrom,\n  type EventObject,\n} from 'xstate'\nimport {createListenLogic, listenInputFromContext} from './common'\nimport {\n  DOMAIN,\n  HANDSHAKE_INTERVAL,\n  MSG_DISCONNECT,\n  MSG_HANDSHAKE_ACK,\n  MSG_HANDSHAKE_SYN,\n  MSG_HANDSHAKE_SYN_ACK,\n  MSG_HEARTBEAT,\n  MSG_RESPONSE,\n} from './constants'\nimport {createRequestMachine, type RequestActorRef} from './request'\nimport type {\n  BufferAddedEmitEvent,\n  BufferFlushedEmitEvent,\n  Message,\n  MessageEmitEvent,\n  ProtocolMessage,\n  RequestData,\n  Status,\n  StatusEmitEvent,\n  WithoutResponse,\n} from './types'\n\n/**\n * @public\n */\nexport type ConnectionActorLogic<TSends extends Message, TReceives extends Message> = ReturnType<\n  typeof createConnectionMachine<TSends, TReceives>\n>\n/**\n * @public\n */\nexport type ConnectionActor<TSends extends Message, TReceives extends Message> = ActorRefFrom<\n  ReturnType<typeof createConnectionMachine<TSends, TReceives>>\n>\n\n/**\n * @public\n */\nexport type Connection<TSends extends Message = Message, TReceives extends Message = Message> = {\n  actor: ConnectionActor<TSends, TReceives>\n  connect: () => void\n  disconnect: () => void\n  id: string\n  name: string\n  machine: ReturnType<typeof createConnectionMachine<TSends, TReceives>>\n  on: <TType extends TReceives['type'], TMessage extends Extract<TReceives, {type: TType}>>(\n    type: TType,\n    handler: (data: TMessage['data']) => Promise<TMessage['response']> | TMessage['response'],\n  ) => () => void\n  onStatus: (handler: (status: Status) => void, filter?: Status) => () => void\n  post: <TType extends TSends['type'], TMessage extends Extract<TSends, {type: TType}>>(\n    ...params: (TMessage['data'] extends undefined ? [TType] : never) | [TType, TMessage['data']]\n  ) => void\n  setTarget: (target: MessageEventSource) => void\n  start: () => () => void\n  stop: () => void\n  target: MessageEventSource | undefined\n}\n\n/**\n * @public\n */\nexport interface ConnectionInput {\n  connectTo: string\n  domain?: string\n  heartbeat?: boolean\n  name: string\n  id?: string\n  target?: MessageEventSource\n  targetOrigin: string\n}\n\nconst sendBackAtInterval = fromCallback<\n  EventObject,\n  {event: EventObject; immediate?: boolean; interval: number}\n>(({sendBack, input}) => {\n  const send = () => {\n    sendBack(input.event)\n  }\n\n  if (input.immediate) {\n    send()\n  }\n\n  const interval = setInterval(send, input.interval)\n\n  return () => {\n    clearInterval(interval)\n  }\n})\n\n/**\n * @public\n */\nexport const createConnectionMachine = <\n  TSends extends Message, // Sends\n  TReceives extends Message, // Receives\n  TSendsWithoutResponse extends WithoutResponse<TSends> = WithoutResponse<TSends>,\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n>() => {\n  const connectionMachine = setup({\n    types: {} as {\n      children: {\n        'listen for handshake': 'listen'\n        'listen for messages': 'listen'\n        'send heartbeat': 'sendBackAtInterval'\n        'send syn': 'sendBackAtInterval'\n      }\n      context: {\n        buffer: Array<TSendsWithoutResponse>\n        channelId: string\n        connectTo: string\n        domain: string\n        heartbeat: boolean\n        id: string\n        name: string\n        requests: Array<RequestActorRef<TSends>>\n        target: MessageEventSource | undefined\n        targetOrigin: string\n      }\n      emitted:\n        | BufferAddedEmitEvent<TSendsWithoutResponse>\n        | BufferFlushedEmitEvent<TSendsWithoutResponse>\n        | MessageEmitEvent<TReceives>\n        | StatusEmitEvent\n      events:\n        | {type: 'connect'}\n        | {type: 'disconnect'}\n        | {type: 'message.received'; message: MessageEvent<ProtocolMessage<TReceives>>}\n        | {type: 'post'; data: TSendsWithoutResponse}\n        | {type: 'response'; respondTo: string; data: Pick<TSends, 'response'>}\n        | {type: 'request.aborted'; requestId: string}\n        | {type: 'request.failed'; requestId: string}\n        | {\n            type: 'request.success'\n            requestId: string\n            response: TSends['response'] | null\n            responseTo: string | undefined\n          }\n        | {type: 'request'; data: RequestData<TSends> | RequestData<TSends>[]}\n        | {type: 'syn'}\n        | {type: 'target.set'; target: MessageEventSource}\n      input: ConnectionInput\n    },\n    actors: {\n      requestMachine: createRequestMachine<TSends>(),\n      listen: createListenLogic(),\n      sendBackAtInterval,\n    },\n    actions: {\n      'buffer message': enqueueActions(({enqueue}) => {\n        enqueue.assign({\n          buffer: ({event, context}) => {\n            assertEvent(event, 'post')\n            return [...context.buffer, event.data]\n          },\n        })\n        enqueue.emit(({event}) => {\n          assertEvent(event, 'post')\n          return {\n            type: 'buffer.added',\n            message: event.data,\n          } satisfies BufferAddedEmitEvent<TSendsWithoutResponse>\n        })\n      }),\n      'create request': assign({\n        requests: ({context, event, self, spawn}) => {\n          assertEvent(event, 'request')\n          const arr = Array.isArray(event.data) ? event.data : [event.data]\n          const requests = arr.map((request) => {\n            const id = `req-${uuid()}`\n            return spawn('requestMachine', {\n              id,\n              input: {\n                channelId: context.channelId,\n                data: request.data,\n                domain: context.domain,\n                expectResponse: request.expectResponse,\n                from: context.name,\n                parentRef: self,\n                responseTo: request.responseTo,\n                sources: context.target!,\n                targetOrigin: context.targetOrigin,\n                to: context.connectTo,\n                type: request.type,\n              },\n            })\n          })\n          return [...context.requests, ...requests]\n        },\n      }),\n      'emit received message': enqueueActions(({enqueue}) => {\n        enqueue.emit(({event}) => {\n          assertEvent(event, 'message.received')\n          return {\n            type: 'message',\n            message: event.message.data,\n          }\n        })\n      }),\n      'emit status': emit((_, params: {status: Status}) => {\n        return {\n          type: 'status',\n          status: params.status,\n        } satisfies StatusEmitEvent\n      }),\n      'post message': raise(({event}) => {\n        assertEvent(event, 'post')\n        return {\n          type: 'request' as const,\n          data: {\n            data: event.data.data,\n            expectResponse: true,\n            type: event.data.type,\n          },\n        }\n      }),\n      'remove request': enqueueActions(({context, enqueue, event}) => {\n        assertEvent(event, ['request.success', 'request.failed', 'request.aborted'])\n        stopChild(event.requestId)\n        enqueue.assign({requests: context.requests.filter(({id}) => id !== event.requestId)})\n      }),\n      'respond': raise(({event}) => {\n        assertEvent(event, 'response')\n        return {\n          type: 'request' as const,\n          data: {\n            data: event.data,\n            type: MSG_RESPONSE,\n            responseTo: event.respondTo,\n          },\n        }\n      }),\n\n      'send handshake ack': raise({\n        type: 'request',\n        data: {type: MSG_HANDSHAKE_ACK},\n      }),\n      'send disconnect': raise(() => {\n        return {\n          type: 'request' as const,\n          data: {type: MSG_DISCONNECT},\n        }\n      }),\n      'send handshake syn': raise({\n        type: 'request',\n        data: {type: MSG_HANDSHAKE_SYN},\n      }),\n      'send pending messages': enqueueActions(({enqueue}) => {\n        enqueue.raise(({context}) => ({\n          type: 'request',\n          data: context.buffer.map(({data, type}) => ({data, type})),\n        }))\n        enqueue.emit(({context}) => {\n          return {\n            type: 'buffer.flushed',\n            messages: context.buffer,\n          } satisfies BufferFlushedEmitEvent<TSendsWithoutResponse>\n        })\n        enqueue.assign({\n          buffer: [],\n        })\n      }),\n      'set target': assign({\n        target: ({event}) => {\n          assertEvent(event, 'target.set')\n          return event.target\n        },\n      }),\n    },\n    guards: {\n      'has target': ({context}) => !!context.target,\n      'should send heartbeats': ({context}) => context.heartbeat,\n    },\n  }).createMachine({\n    /** @xstate-layout N4IgpgJg5mDOIC5QGMAWBDAdpsAbAxAC7oBOMhAdLGIQNoAMAuoqAA4D2sAloV+5ixAAPRAHZRAJgoAWABz0ArHICMy2QGZZCgJwAaEAE9EE+tIrb6ANgkLl46fTuj1AXxf60WHARJgAjgCucJSwAcjIcLAMzEggHNy8-IIiCKLS2hQS6qb2yurisrL6RgjK9LIyCuqq0g7WstZuHhjYePi+gcEUAGboXLiQ0YLxPHwCsSmiCgoykpayDtqS6trqxYjKEk0gnq24FFwQA-jI-DjIdEzDnKNJExuOZpZ12eq29OrSCuupypYUojUaTKCnm5Wk2123gORzA+HilxibBuiXGoBSGnUAIU4gU9FWamUtR+lmUM1EllBEkslMUEnpkJa0JaEFgGAA1lxMFB8LADJghrERqjkhtshk3mTtNo5OpqpYfqCKhTptoqpY1WUtu4dky8BQWWz0Jzue1-EFYIjrgkxqLSupqRRPpoPqJtLI0hIioZENJJE7NnJ8ZYHVk1YyvPrDRyuTyEYLkTa7uixVlMh81KGFhS1j6EPkZlpVjTphr8mkI3sDVhWTHTQBbSLoGAUXwRLgAN0GVyFKNt91KimUFEKXvKC2s9R+6X+jipnzJeSqEJ1UKjNaNJp5EC4sFOrQuCbifeTwg2cgoym0RPxDtqkj0eaB9Ao8zSolMEivZVcq71+33c5CEgeFOCtXskzRM8EDxKRpmkSw3QJbQsmpH5tHmV8JHSbJpDsakV2aSMALOMALhAjoLXAxNbiglI-SxWw1Vw0QNDw0Qfg9KQ7EJSxHHxApK2hQCyOAiAzVgDhMGoI9hX7FMEHSF8cWkelpHURCbBsb481xAEgT9BQJCmWQsiE-URPI8TG1gWBmzAVsyLATtuyRY9ILtWoKmlL82Kqd0tAVJ91LMHFZDKIkVlkNVZHMkiDzE-Adz3UjDx7GiRQHCKnheD53k+HSSkDDIwpBVTqQwuKKEssSDTAUhCAAI3qyg0DIrd8Fkk86MQUMnVM+RynoegTDJH48hGp0vR-FDRqqKqasgOqGua9AQjATAd1NSiul6fpXOtWi7Wy19cslD4vnG7IX3oVjVDUVYEJQqrksW8SdstLqPKy0wKgG1RhtMWogqKhoMjkWp6XxUyFBe3c3tAz70vco6fq+V8PTkGUFzdQqNnELEM2yClrwwzQ4ZShKQJqr7UYU98AS0W9pT4z5pHG0yXwMkNNTyGk3B1TB2AgOBBDXXBDsyhSFG9EovQqN5i1JeRcKqw4Bkl+ToMx8x0j+EaqQ9XMSkBURMgMkEwQWKro2NWNNdPFJAzN0lJGM4slDxhBEJfXyplBd03wW1KxIdnrBxBh4JAyW75C8rJpmDqmIGWkgmpasPjqUcaHooMLHA0uU1UkJOgKW1B6rT1bWor5At0zgcTAkK7hrz1irB0D8cW0UvRPLyv07WqgNq2qAG+l9SnXUz0UOXD5xuMs3Y4+DVJBX7UiKrV6Q8gcfoJO54rFefLLqfJYX1WKYNLxL4NO1NwgA */\n    id: 'connection',\n    context: ({input}) => ({\n      id: input.id || `${input.name}-${uuid()}`,\n      buffer: [],\n      channelId: `chn-${uuid()}`,\n      connectTo: input.connectTo,\n      domain: input.domain ?? DOMAIN,\n      heartbeat: input.heartbeat ?? false,\n      name: input.name,\n      requests: [],\n      target: input.target,\n      targetOrigin: input.targetOrigin,\n    }),\n    on: {\n      'target.set': {\n        actions: 'set target',\n      },\n      'request.success': {\n        actions: 'remove request',\n      },\n      'request.failed': {\n        actions: 'remove request',\n      },\n    },\n    initial: 'idle',\n    states: {\n      idle: {\n        entry: [{type: 'emit status', params: {status: 'idle'}}],\n        on: {\n          connect: {\n            target: 'handshaking',\n            guard: 'has target',\n          },\n          post: {\n            actions: 'buffer message',\n          },\n        },\n      },\n      handshaking: {\n        id: 'handshaking',\n        entry: [{type: 'emit status', params: {status: 'handshaking'}}],\n        invoke: [\n          {\n            id: 'send syn',\n            src: 'sendBackAtInterval',\n            input: () => ({\n              event: {type: 'syn'},\n              interval: HANDSHAKE_INTERVAL,\n              immediate: true,\n            }),\n          },\n          {\n            id: 'listen for handshake',\n            src: 'listen',\n            input: (input) =>\n              listenInputFromContext({\n                include: MSG_HANDSHAKE_SYN_ACK,\n                count: 1,\n              })(input),\n            /* Below would maybe be more readable than transitioning to\n          'connected' on 'message', and 'ack' on exit but having onDone when\n          using passing invocations currently breaks XState Editor */\n            // onDone: {\n            //   target: 'connected',\n            //   actions: 'ack',\n            // },\n          },\n        ],\n        on: {\n          'syn': {\n            actions: 'send handshake syn',\n          },\n          'request': {\n            actions: 'create request',\n          },\n          'post': {\n            actions: 'buffer message',\n          },\n          'message.received': {\n            target: 'connected',\n          },\n          'disconnect': {\n            target: 'disconnected',\n          },\n        },\n        exit: 'send handshake ack',\n      },\n      connected: {\n        entry: ['send pending messages', {type: 'emit status', params: {status: 'connected'}}],\n        invoke: {\n          id: 'listen for messages',\n          src: 'listen',\n          input: listenInputFromContext({\n            exclude: [MSG_RESPONSE, MSG_HEARTBEAT],\n          }),\n        },\n        on: {\n          'post': {\n            actions: 'post message',\n          },\n          'request': {\n            actions: 'create request',\n          },\n          'response': {\n            actions: 'respond',\n          },\n          'message.received': {\n            actions: 'emit received message',\n          },\n          'disconnect': {\n            target: 'disconnected',\n          },\n        },\n        initial: 'heartbeat',\n        states: {\n          heartbeat: {\n            initial: 'checking',\n            states: {\n              checking: {\n                always: {\n                  guard: 'should send heartbeats',\n                  target: 'sending',\n                },\n              },\n              sending: {\n                on: {\n                  'request.failed': {\n                    target: '#handshaking',\n                  },\n                },\n                invoke: {\n                  id: 'send heartbeat',\n                  src: 'sendBackAtInterval',\n                  input: () => ({\n                    event: {type: 'post', data: {type: MSG_HEARTBEAT, data: undefined}},\n                    interval: 2000,\n                    immediate: false,\n                  }),\n                },\n              },\n            },\n          },\n        },\n      },\n      disconnected: {\n        id: 'disconnected',\n        entry: ['send disconnect', {type: 'emit status', params: {status: 'disconnected'}}],\n        on: {\n          request: {\n            actions: 'create request',\n          },\n          post: {\n            actions: 'buffer message',\n          },\n          connect: {\n            target: 'handshaking',\n            guard: 'has target',\n          },\n        },\n      },\n    },\n  })\n\n  return connectionMachine\n}\n\n/**\n * @public\n */\nexport const createConnection = <TSends extends Message, TReceives extends Message>(\n  input: ConnectionInput,\n  machine: ConnectionActorLogic<TSends, TReceives> = createConnectionMachine<TSends, TReceives>(),\n): Connection<TSends, TReceives> => {\n  const id = input.id || `${input.name}-${uuid()}`\n  const actor = createActor(machine, {\n    input: {...input, id},\n  })\n\n  const eventHandlers: Map<\n    string,\n    Set<(event: TReceives['data']) => Promise<TReceives['response']> | TReceives['response']>\n  > = new Map()\n\n  const unhandledMessages: Map<string, Set<ProtocolMessage<Message>>> = new Map()\n\n  const on = <TType extends TReceives['type'], TMessage extends Extract<TReceives, {type: TType}>>(\n    type: TType,\n    handler: (data: TMessage['data']) => Promise<TMessage['response']> | TMessage['response'],\n    options?: {replay?: number},\n  ) => {\n    const handlers = eventHandlers.get(type) || new Set()\n\n    if (!eventHandlers.has(type)) {\n      eventHandlers.set(type, handlers)\n    }\n\n    // Register the new handler\n    handlers.add(handler)\n\n    // Process any unhandled messages for this type\n    const unhandledMessagesForType = unhandledMessages.get(type)\n    if (unhandledMessagesForType) {\n      const replayCount = options?.replay ?? 1\n      const messagesToReplay = Array.from(unhandledMessagesForType).slice(-replayCount)\n\n      // Replay messages to the new handler\n      messagesToReplay.forEach(async ({data, id}) => {\n        const response = await handler(data)\n        if (response) {\n          actor.send({\n            type: 'response',\n            respondTo: id,\n            data: response,\n          })\n        }\n      })\n\n      // Clear the unhandled messages for this type\n      unhandledMessages.delete(type)\n    }\n\n    return () => {\n      handlers.delete(handler)\n    }\n  }\n\n  const connect = () => {\n    actor.send({type: 'connect'})\n  }\n\n  const disconnect = () => {\n    actor.send({type: 'disconnect'})\n  }\n\n  const onStatus = (handler: (status: Status) => void, filter?: Status) => {\n    const {unsubscribe} = actor.on('status', (event: StatusEmitEvent & {status: Status}) => {\n      if (filter && event.status !== filter) {\n        return\n      }\n\n      handler(event.status)\n    })\n\n    return unsubscribe\n  }\n\n  const setTarget = (target: MessageEventSource) => {\n    actor.send({type: 'target.set', target})\n  }\n\n  const post = <TType extends TSends['type'], TMessage extends Extract<TSends, {type: TType}>>(\n    type: TType,\n    data?: TMessage['data'],\n  ) => {\n    const _data = {type, data} as WithoutResponse<TMessage>\n    actor.send({type: 'post', data: _data})\n  }\n\n  actor.on('message', async ({message}) => {\n    const handlers = eventHandlers.get(message.type)\n\n    if (handlers) {\n      // Execute all registered handlers for this message type\n      handlers.forEach(async (handler) => {\n        const response = await handler(message.data)\n        if (response) {\n          actor.send({type: 'response', respondTo: message.id, data: response})\n        }\n      })\n      return\n    }\n\n    // Store unhandled messages for potential replay\n    const unhandledMessagesForType = unhandledMessages.get(message.type)\n    if (unhandledMessagesForType) {\n      unhandledMessagesForType.add(message)\n    } else {\n      unhandledMessages.set(message.type, new Set([message]))\n    }\n  })\n\n  const stop = () => {\n    actor.stop()\n  }\n\n  const start = () => {\n    actor.start()\n    return stop\n  }\n\n  return {\n    actor,\n    connect,\n    disconnect,\n    id,\n    name: input.name,\n    machine,\n    on,\n    onStatus,\n    post,\n    setTarget,\n    start,\n    stop,\n    get target() {\n      return actor.getSnapshot().context.target\n    },\n  }\n}\n\n// Helper function to cleanup a connection\nexport const cleanupConnection: (connection: Connection<Message, Message>) => void = (\n  connection,\n) => {\n  connection.disconnect()\n  // Necessary to allow disconnect messages to be sent before the connection\n  // actor is stopped\n  setTimeout(() => {\n    connection.stop()\n  }, 0)\n}\n", "import {\n  cleanupConnection,\n  createConnection,\n  createConnectionMachine,\n  type Connection,\n  type ConnectionActorLogic,\n  type ConnectionInput,\n} from './connection'\nimport {type InternalEmitEvent, type Message, type StatusEvent} from './types'\n\n/**\n * @public\n */\nexport type ChannelInput = Omit<ConnectionInput, 'target' | 'targetOrigin'>\n\n/**\n * @public\n */\nexport interface ChannelInstance<TSends extends Message, TReceives extends Message> {\n  on: <TType extends TReceives['type'], TMessage extends Extract<TReceives, {type: TType}>>(\n    type: TType,\n    handler: (data: TMessage['data']) => Promise<TMessage['response']> | TMessage['response'],\n  ) => () => void\n  onInternalEvent: <\n    TType extends InternalEmitEvent<TSends, TReceives>['type'],\n    TEvent extends Extract<InternalEmitEvent<TSends, TReceives>, {type: TType}>,\n  >(\n    type: TType,\n    handler: (event: TEvent) => void,\n  ) => () => void\n  onStatus: (handler: (event: StatusEvent) => void) => void\n  post: <TType extends TSends['type'], TMessage extends Extract<TSends, {type: TType}>>(\n    ...params: (TMessage['data'] extends undefined ? [TType] : never) | [TType, TMessage['data']]\n  ) => void\n  start: () => () => void\n  stop: () => void\n}\n\n/**\n * @public\n */\nexport interface Controller {\n  addTarget: (target: MessageEventSource) => () => void\n  createChannel: <TSends extends Message, TReceives extends Message>(\n    input: ChannelInput,\n    machine?: ConnectionActorLogic<TSends, TReceives>,\n  ) => ChannelInstance<TSends, TReceives>\n  destroy: () => void\n}\n\ninterface Channel<\n  TSends extends Message = Message,\n  TReceives extends Message = Message,\n  TType extends InternalEmitEvent<TSends, TReceives>['type'] = InternalEmitEvent<\n    TSends,\n    TReceives\n  >['type'],\n> {\n  input: ChannelInput\n  connections: Set<Connection<TSends, TReceives>>\n  internalEventSubscribers: Set<{\n    type: TType\n    handler: (event: Extract<InternalEmitEvent<TSends, TReceives>, {type: TType}>) => void\n    unsubscribers: Array<() => void>\n  }>\n  machine: ConnectionActorLogic<TSends, TReceives>\n  statusSubscribers: Set<{\n    handler: (event: StatusEvent) => void\n    unsubscribers: Array<() => void>\n  }>\n  subscribers: Set<{\n    type: TReceives['type']\n    handler: (event: TReceives['data']) => Promise<TReceives['response']> | TReceives['response']\n    unsubscribers: Array<() => void>\n  }>\n}\n\nconst noop = () => {}\n\n/**\n * @public\n */\nexport const createController = (input: {targetOrigin: string}): Controller => {\n  const {targetOrigin} = input\n  const targets = new Set<MessageEventSource>()\n  const channels = new Set<Channel>()\n\n  const addTarget = (target: MessageEventSource) => {\n    // If the target has already been added, return just a noop cleanup\n    if (targets.has(target)) {\n      return noop\n    }\n\n    if (!targets.size || !channels.size) {\n      targets.add(target)\n\n      // If there are existing channels, set the target on all existing\n      // connections, and trigger a connection event\n      channels.forEach((channel) => {\n        channel.connections.forEach((connection) => {\n          connection.setTarget(target)\n          connection.connect()\n        })\n      })\n      // We perform a 'soft' cleanup here: disconnect only as we want to\n      // maintain at least one live connection per channel\n      return () => {\n        targets.delete(target)\n        channels.forEach((channel) => {\n          channel.connections.forEach((connection) => {\n            if (connection.target === target) {\n              connection.disconnect()\n            }\n          })\n        })\n      }\n    }\n\n    targets.add(target)\n\n    // Maintain a list of connections to cleanup\n    const targetConnections = new Set<Connection<Message, Message>>()\n\n    // If we already have targets and channels, we need to create new\n    // connections for each source with all the associated subscribers.\n    channels.forEach((channel) => {\n      const connection = createConnection(\n        {\n          ...channel.input,\n          target,\n          targetOrigin,\n        },\n        channel.machine,\n      )\n\n      targetConnections.add(connection)\n      channel.connections.add(connection)\n\n      channel.subscribers.forEach(({type, handler, unsubscribers}) => {\n        unsubscribers.push(connection.on(type, handler))\n      })\n      channel.internalEventSubscribers.forEach(({type, handler, unsubscribers}) => {\n        unsubscribers.push(connection.actor.on(type, handler).unsubscribe)\n      })\n      channel.statusSubscribers.forEach(({handler, unsubscribers}) => {\n        unsubscribers.push(\n          connection.onStatus((status) => handler({connection: connection.id, status})),\n        )\n      })\n\n      connection.start()\n      connection.connect()\n    })\n\n    // We perform a more 'aggressive' cleanup here as we do not need to maintain\n    // these 'duplicate' connections: disconnect, stop, and remove the connections from\n    // all channels\n    return () => {\n      targets.delete(target)\n      targetConnections.forEach((connection) => {\n        cleanupConnection(connection)\n        channels.forEach((channel) => {\n          channel.connections.delete(connection)\n        })\n      })\n    }\n  }\n\n  const createChannel = <TSends extends Message, TReceives extends Message>(\n    input: ChannelInput,\n    machine: ConnectionActorLogic<TSends, TReceives> = createConnectionMachine<TSends, TReceives>(),\n  ): ChannelInstance<TSends, TReceives> => {\n    const channel: Channel<TSends, TReceives> = {\n      connections: new Set(),\n      input,\n      internalEventSubscribers: new Set(),\n      machine,\n      statusSubscribers: new Set(),\n      subscribers: new Set(),\n    }\n\n    channels.add(channel as unknown as Channel)\n\n    const {connections, internalEventSubscribers, statusSubscribers, subscribers} = channel\n\n    if (targets.size) {\n      // If targets have already been added, create a connection for each target\n      targets.forEach((target) => {\n        const connection = createConnection<TSends, TReceives>(\n          {\n            ...input,\n            target,\n            targetOrigin,\n          },\n          machine,\n        )\n        connections.add(connection)\n      })\n    } else {\n      // If targets have not been added yet, create a connection without a target\n      const connection = createConnection<TSends, TReceives>({...input, targetOrigin}, machine)\n      connections.add(connection)\n    }\n\n    const post: ChannelInstance<TSends, TReceives>['post'] = (...params) => {\n      const [type, data] = params\n      connections.forEach((connection) => {\n        connection.post(type, data)\n      })\n    }\n\n    const on: ChannelInstance<TSends, TReceives>['on'] = (type, handler) => {\n      const unsubscribers: Array<() => void> = []\n      connections.forEach((connection) => {\n        unsubscribers.push(connection.on(type, handler))\n      })\n      const subscriber = {type, handler, unsubscribers}\n      subscribers.add(subscriber)\n      return () => {\n        unsubscribers.forEach((unsub) => unsub())\n        subscribers.delete(subscriber)\n      }\n    }\n\n    const onInternalEvent = <\n      TType extends InternalEmitEvent<TSends, TReceives>['type'],\n      TEvent extends Extract<InternalEmitEvent<TSends, TReceives>, {type: TType}>,\n    >(\n      type: TType,\n      handler: (event: TEvent) => void,\n    ) => {\n      const unsubscribers: Array<() => void> = []\n      connections.forEach((connection) => {\n        // @ts-expect-error @todo @help\n        unsubscribers.push(connection.actor.on(type, handler).unsubscribe)\n      })\n      const subscriber = {type, handler, unsubscribers}\n      // @ts-expect-error @todo @help\n      internalEventSubscribers.add(subscriber)\n      return () => {\n        unsubscribers.forEach((unsub) => unsub())\n        // @ts-expect-error @todo @help\n        internalEventSubscribers.delete(subscriber)\n      }\n    }\n\n    const onStatus = (handler: (event: StatusEvent) => void) => {\n      const unsubscribers: Array<() => void> = []\n      connections.forEach((connection) => {\n        unsubscribers.push(\n          connection.onStatus((status) => handler({connection: connection.id, status})),\n        )\n      })\n      const subscriber = {handler, unsubscribers}\n      statusSubscribers.add(subscriber)\n      return () => {\n        unsubscribers.forEach((unsub) => unsub())\n        statusSubscribers.delete(subscriber)\n      }\n    }\n\n    // Stop a connection, cleanup all connections and remove the connection itself\n    // from the controller\n    // @todo Remove casting\n    const stop = () => {\n      const connections = channel.connections as unknown as Set<Connection>\n      connections.forEach(cleanupConnection)\n      connections.clear()\n      channels.delete(channel as unknown as Channel)\n    }\n\n    const start = () => {\n      connections.forEach((connection) => {\n        connection.start()\n        connection.connect()\n      })\n\n      return stop\n    }\n\n    return {\n      on,\n      onInternalEvent,\n      onStatus,\n      post,\n      start,\n      stop,\n    }\n  }\n\n  // Destroy the controller, cleanup all connections in all channels\n  const destroy = () => {\n    channels.forEach(({connections}) => {\n      connections.forEach(cleanupConnection)\n      connections.clear()\n    })\n    channels.clear()\n    targets.clear()\n  }\n\n  return {\n    addTarget,\n    createChannel,\n    destroy,\n  }\n}\n", "import {v4 as uuid} from 'uuid'\nimport {\n  assertEvent,\n  assign,\n  createActor,\n  emit,\n  enqueueActions,\n  raise,\n  setup,\n  stopChild,\n  type ActorRefFrom,\n} from 'xstate'\nimport {createListenLogic, listenInputFromContext} from './common'\nimport {\n  DOMAIN,\n  FETCH_TIMEOUT_DEFAULT,\n  MSG_DISCONNECT,\n  MSG_HANDSHAKE_ACK,\n  MSG_HANDSHAKE_SYN,\n  MSG_HANDSHAKE_SYN_ACK,\n  MSG_HEARTBEAT,\n  MSG_RESPONSE,\n} from './constants'\nimport {createRequestMachine, type RequestActorRef} from './request'\nimport type {\n  BufferAddedEmitEvent,\n  BufferFlushedEmitEvent,\n  HeartbeatEmitEvent,\n  HeartbeatMessage,\n  Message,\n  MessageEmitEvent,\n  ProtocolMessage,\n  RequestData,\n  Status,\n  StatusEmitEvent,\n  WithoutResponse,\n} from './types'\n\n/**\n * @public\n */\nexport interface NodeInput {\n  name: string\n  connectTo: string\n  domain?: string\n}\n\n/**\n * @public\n */\nexport type NodeActorLogic<TSends extends Message, TReceives extends Message> = ReturnType<\n  typeof createNodeMachine<TSends, TReceives>\n>\n\n/**\n * @public\n */\nexport type NodeActor<TSends extends Message, TReceives extends Message> = ActorRefFrom<\n  NodeActorLogic<TSends, TReceives>\n>\n\n/**\n * @public\n */\nexport type Node<TSends extends Message, TReceives extends Message> = {\n  actor: NodeActor<TSends, TReceives>\n  fetch: <TType extends TSends['type'], TMessage extends Extract<TSends, {type: TType}>>(\n    ...params:\n      | (TMessage['data'] extends undefined ? [TType] : never)\n      | [TType, TMessage['data']]\n      | [TType, TMessage['data'], {signal?: AbortSignal; suppressWarnings?: boolean}]\n  ) => TSends extends TMessage\n    ? TSends['type'] extends TType\n      ? Promise<TSends['response']>\n      : never\n    : never\n  machine: NodeActorLogic<TSends, TReceives>\n  on: <TType extends TReceives['type'], TMessage extends Extract<TReceives, {type: TType}>>(\n    type: TType,\n    handler: (event: TMessage['data']) => TMessage['response'],\n  ) => () => void\n  onStatus: (\n    handler: (status: Exclude<Status, 'disconnected'>) => void,\n    filter?: Exclude<Status, 'disconnected'>,\n  ) => () => void\n  post: <TType extends TSends['type'], TMessage extends Extract<TSends, {type: TType}>>(\n    ...params: (TMessage['data'] extends undefined ? [TType] : never) | [TType, TMessage['data']]\n  ) => void\n  start: () => () => void\n  stop: () => void\n}\n\n/**\n * @public\n */\nexport const createNodeMachine = <\n  TSends extends Message, // Sends\n  TReceives extends Message, // Receives\n  TSendsWithoutResponse extends WithoutResponse<TSends> = WithoutResponse<TSends>,\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n>() => {\n  const nodeMachine = setup({\n    types: {} as {\n      children: {\n        'listen for disconnect': 'listen'\n        'listen for handshake ack': 'listen'\n        'listen for handshake syn': 'listen'\n        'listen for heartbeat': 'listen'\n        'listen for messages': 'listen'\n      }\n      context: {\n        buffer: Array<{\n          data: TSendsWithoutResponse\n          resolvable?: PromiseWithResolvers<TSends['response']>\n          options?: {\n            signal?: AbortSignal\n            suppressWarnings?: boolean\n          }\n        }>\n        channelId: string | null\n        connectTo: string\n        domain: string\n        // The handshake buffer is a workaround to maintain backwards\n        // compatibility with the Sanity channels package, which may incorrectly\n        // send buffered messages _before_ it completes the handshake (i.e.\n        // sends an ack message). It should be removed in the next major.\n        handshakeBuffer: Array<{\n          type: 'message.received'\n          message: MessageEvent<ProtocolMessage<TReceives>>\n        }>\n        name: string\n        requests: Array<RequestActorRef<TSends>>\n        target: MessageEventSource | undefined\n        targetOrigin: string | null\n      }\n      emitted:\n        | BufferAddedEmitEvent<TSendsWithoutResponse>\n        | BufferFlushedEmitEvent<TSendsWithoutResponse>\n        | HeartbeatEmitEvent\n        | MessageEmitEvent<TReceives>\n        | (StatusEmitEvent & {status: Exclude<Status, 'disconnected'>})\n      events:\n        | {type: 'heartbeat.received'; message: MessageEvent<ProtocolMessage<HeartbeatMessage>>}\n        | {type: 'message.received'; message: MessageEvent<ProtocolMessage<TReceives>>}\n        | {type: 'handshake.syn'; message: MessageEvent<ProtocolMessage<TReceives>>}\n        | {\n            type: 'post'\n            data: TSendsWithoutResponse\n            resolvable?: PromiseWithResolvers<TSends['response']>\n            options?: {\n              responseTimeout?: number\n              signal?: AbortSignal\n              suppressWarnings?: boolean\n            }\n          }\n        | {type: 'request.aborted'; requestId: string}\n        | {type: 'request.failed'; requestId: string}\n        | {\n            type: 'request.success'\n            requestId: string\n            response: TSends['response'] | null\n            responseTo: string | undefined\n          }\n        | {type: 'request'; data: RequestData<TSends> | RequestData<TSends>[]} // @todo align with 'post' type\n      input: NodeInput\n    },\n    actors: {\n      requestMachine: createRequestMachine<TSends>(),\n      listen: createListenLogic(),\n    },\n    actions: {\n      'buffer handshake': assign({\n        handshakeBuffer: ({event, context}) => {\n          assertEvent(event, 'message.received')\n          return [...context.handshakeBuffer, event]\n        },\n      }),\n      'buffer message': enqueueActions(({enqueue}) => {\n        enqueue.assign({\n          buffer: ({event, context}) => {\n            assertEvent(event, 'post')\n            return [\n              ...context.buffer,\n              {\n                data: event.data,\n                resolvable: event.resolvable,\n                options: event.options,\n              },\n            ]\n          },\n        })\n        enqueue.emit(({event}) => {\n          assertEvent(event, 'post')\n          return {\n            type: 'buffer.added',\n            message: event.data,\n          } satisfies BufferAddedEmitEvent<TSendsWithoutResponse>\n        })\n      }),\n      'create request': assign({\n        requests: ({context, event, self, spawn}) => {\n          assertEvent(event, 'request')\n          const arr = Array.isArray(event.data) ? event.data : [event.data]\n          const requests = arr.map((request) => {\n            const id = `req-${uuid()}`\n            return spawn('requestMachine', {\n              id,\n              input: {\n                channelId: context.channelId!,\n                data: request.data,\n                domain: context.domain!,\n                expectResponse: request.expectResponse,\n                from: context.name,\n                parentRef: self,\n                resolvable: request.resolvable,\n                responseTimeout: request.options?.responseTimeout,\n                responseTo: request.responseTo,\n                signal: request.options?.signal,\n                sources: context.target!,\n                suppressWarnings: request.options?.suppressWarnings,\n                targetOrigin: context.targetOrigin!,\n                to: context.connectTo,\n                type: request.type,\n              },\n            })\n          })\n          return [...context.requests, ...requests]\n        },\n      }),\n      'emit heartbeat': emit(() => {\n        return {\n          type: 'heartbeat',\n        } satisfies HeartbeatEmitEvent\n      }),\n      'emit received message': enqueueActions(({enqueue}) => {\n        enqueue.emit(({event}) => {\n          assertEvent(event, 'message.received')\n          return {\n            type: 'message',\n            message: event.message.data,\n          }\n        })\n      }),\n      'emit status': emit((_, params: {status: Exclude<Status, 'disconnected'>}) => {\n        return {\n          type: 'status',\n          status: params.status,\n        } satisfies StatusEmitEvent & {status: Exclude<Status, 'disconnected'>}\n      }),\n      'post message': raise(({event}) => {\n        assertEvent(event, 'post')\n        return {\n          type: 'request' as const,\n          data: {\n            data: event.data.data,\n            expectResponse: event.resolvable ? true : false,\n            type: event.data.type,\n            resolvable: event.resolvable,\n            options: event.options,\n          },\n        }\n      }),\n      'process pending handshakes': enqueueActions(({context, enqueue}) => {\n        context.handshakeBuffer.forEach((event) => enqueue.raise(event))\n        enqueue.assign({\n          handshakeBuffer: [],\n        })\n      }),\n      'remove request': enqueueActions(({context, enqueue, event}) => {\n        assertEvent(event, ['request.success', 'request.failed', 'request.aborted'])\n        stopChild(event.requestId)\n        enqueue.assign({requests: context.requests.filter(({id}) => id !== event.requestId)})\n      }),\n      'send response': raise(({event}) => {\n        assertEvent(event, ['message.received', 'heartbeat.received'])\n        return {\n          type: 'request' as const,\n          data: {\n            type: MSG_RESPONSE,\n            responseTo: event.message.data.id,\n            data: undefined,\n          },\n        }\n      }),\n      'send handshake syn ack': raise({\n        type: 'request',\n        data: {type: MSG_HANDSHAKE_SYN_ACK},\n      }),\n      'send pending messages': enqueueActions(({enqueue}) => {\n        enqueue.raise(({context}) => ({\n          type: 'request',\n          data: context.buffer.map(({data, resolvable, options}) => ({\n            data: data.data,\n            type: data.type,\n            expectResponse: resolvable ? true : false,\n            resolvable,\n            options,\n          })),\n        }))\n        enqueue.emit(({context}) => {\n          return {\n            type: 'buffer.flushed',\n            messages: context.buffer.map(({data}) => data),\n          } satisfies BufferFlushedEmitEvent<TSendsWithoutResponse>\n        })\n        enqueue.assign({\n          buffer: [],\n        })\n      }),\n      'set connection config': assign({\n        channelId: ({event}) => {\n          assertEvent(event, 'handshake.syn')\n          return event.message.data.channelId\n        },\n        target: ({event}) => {\n          assertEvent(event, 'handshake.syn')\n          return event.message.source || undefined\n        },\n        targetOrigin: ({event}) => {\n          assertEvent(event, 'handshake.syn')\n          return event.message.origin\n        },\n      }),\n    },\n    guards: {\n      hasSource: ({context}) => context.target !== null,\n    },\n  }).createMachine({\n    /** @xstate-layout N4IgpgJg5mDOIC5QDsD2EwGIBOYCOArnAC4B0sBAxpXLANoAMAuoqAA6qwCWxXqyrEAA9EAVgYAWUgEYJDUQA4JAZmUSJC0coDsAGhABPRNIYLSErdOkBOAGzbx227YUBfV-rQYc+IrDIAZgCGXAA2kIwsSCAc3Lz8giIIoiakqgBMDKbp2tYS0srp+kYI0ununuhgpFwQ4ZgQ-NVcyABuqADW1V7NdWAILe2UQfHIkZGCsTx8AtFJ6aKipAzWOtrpC7Z5BUWGiNoK6aS26RLW2tLaqkqqFSA9NX2YALa0QTCkuDRcrRHMk5xpgk5ogJLZSNZIVDoVCFLZiohbIVSLkXLZRHZDgxbHcHrV6rFiBNolNRolEVJbCsdGUzsoyhiEcllOC1DowelVmVrOUPPcqqQABZBZAQWDCjotKANJo1NqdboC4Wi8VBSXIKADeXDUbjf4kwFkkEILbg8RZMHKOzWKzKJkHJa086Xa4qZS4pUisUSqU+QgkYnsQ0zcnJaRLDbpZwKNQSBYspm2MEyC5KTnaDSSd18h7K71q32EwMxYPA0BJFLKY5yZxIrKSURM0RnFHSBTrQqQ9babQejBCr2q9XSiBcWCUfjIMCUIn6oNxEPGtTWFFR0RUy7iGzt+3Ip0XURXVZKPvVCfIKczyB+vyzqLzoGzcuIG0MGTyCztjRtjaJjbHVMNAUTdu1PUhz0vYhryLOcSwXMthBfK0ZGsLQGBZekCi0Jso1IdI23WG04zOE4wIg6coIgBox3Imdi1JRdnxNOxSHNSQkWtW0mTjMxMQ7fDzgcbNKn7WjKJeN4Pi+MAfj+e84MfUMFHbZZwxOHZNDyO09gQOQjmAhZJCM9IMjIycKOvQUwCCbBiAAI2sshpNkiB6NLJ9EIQBQbWOdJlMhYCUjbJkchXGsFmsJQMVsWl3BzKp4GiHoAXgjykgAWmkZZ6xy3LZF2EobCy6xsQWJQ42kE4FjA-EwBSxTjSRUhDgqkzgO2BxdykU4AvXFQ-KjMC8yHKV6qNJi6WOdcypcZsXGxe0JG0XySKjM5lKsMyLwsiAxsYzylDfONznUEqrmi+1ThkHqXDONbULi1wgA */\n    id: 'node',\n    context: ({input}) => ({\n      buffer: [],\n      channelId: null,\n      connectTo: input.connectTo,\n      domain: input.domain ?? DOMAIN,\n      handshakeBuffer: [],\n      name: input.name,\n      requests: [],\n      target: undefined,\n      targetOrigin: null,\n    }),\n    // Always listen for handshake syn messages. The channel could have\n    // disconnected without being able to notify the node, and so need to\n    // re-establish the connection.\n    invoke: {\n      id: 'listen for handshake syn',\n      src: 'listen',\n      input: listenInputFromContext({\n        include: MSG_HANDSHAKE_SYN,\n        responseType: 'handshake.syn',\n      }),\n    },\n    on: {\n      'request.success': {\n        actions: 'remove request',\n      },\n      'request.failed': {\n        actions: 'remove request',\n      },\n      'request.aborted': {\n        actions: 'remove request',\n      },\n      'handshake.syn': {\n        actions: 'set connection config',\n        target: '.handshaking',\n      },\n    },\n    initial: 'idle',\n    states: {\n      idle: {\n        entry: [{type: 'emit status', params: {status: 'idle'}}],\n        on: {\n          post: {\n            actions: 'buffer message',\n          },\n        },\n      },\n      handshaking: {\n        guard: 'hasSource',\n        entry: ['send handshake syn ack', {type: 'emit status', params: {status: 'handshaking'}}],\n        invoke: [\n          {\n            id: 'listen for handshake ack',\n            src: 'listen',\n            input: listenInputFromContext({\n              include: MSG_HANDSHAKE_ACK,\n              count: 1,\n              // Override the default `message.received` responseType to prevent\n              // buffering the ack message. We transition to the connected state\n              // using onDone instead of listening to this event using `on`\n              responseType: 'handshake.complete',\n            }),\n            onDone: 'connected',\n          },\n          {\n            id: 'listen for disconnect',\n            src: 'listen',\n            input: listenInputFromContext({\n              include: MSG_DISCONNECT,\n              count: 1,\n              responseType: 'disconnect',\n            }),\n          },\n          {\n            id: 'listen for messages',\n            src: 'listen',\n            input: listenInputFromContext({\n              exclude: [\n                MSG_DISCONNECT,\n                MSG_HANDSHAKE_SYN,\n                MSG_HANDSHAKE_ACK,\n                MSG_HEARTBEAT,\n                MSG_RESPONSE,\n              ],\n            }),\n          },\n        ],\n        on: {\n          'request': {\n            actions: 'create request',\n          },\n          'post': {\n            actions: 'buffer message',\n          },\n          'message.received': {\n            actions: 'buffer handshake',\n          },\n          'disconnect': {\n            target: 'idle',\n          },\n        },\n      },\n      connected: {\n        entry: [\n          'process pending handshakes',\n          'send pending messages',\n          {type: 'emit status', params: {status: 'connected'}},\n        ],\n        invoke: [\n          {\n            id: 'listen for messages',\n            src: 'listen',\n            input: listenInputFromContext({\n              exclude: [\n                MSG_DISCONNECT,\n                MSG_HANDSHAKE_SYN,\n                MSG_HANDSHAKE_ACK,\n                MSG_HEARTBEAT,\n                MSG_RESPONSE,\n              ],\n            }),\n          },\n          {\n            id: 'listen for heartbeat',\n            src: 'listen',\n            input: listenInputFromContext({\n              include: MSG_HEARTBEAT,\n              responseType: 'heartbeat.received',\n            }),\n          },\n          {\n            id: 'listen for disconnect',\n            src: 'listen',\n            input: listenInputFromContext({\n              include: MSG_DISCONNECT,\n              count: 1,\n              responseType: 'disconnect',\n            }),\n          },\n        ],\n        on: {\n          'request': {\n            actions: 'create request',\n          },\n          'post': {\n            actions: 'post message',\n          },\n          'disconnect': {\n            target: 'idle',\n          },\n          'message.received': {\n            actions: ['send response', 'emit received message'],\n          },\n          'heartbeat.received': {\n            actions: ['send response', 'emit heartbeat'],\n          },\n        },\n      },\n    },\n  })\n  return nodeMachine\n}\n\n/**\n * @public\n */\nexport const createNode = <TSends extends Message, TReceives extends Message>(\n  input: NodeInput,\n  machine: NodeActorLogic<TSends, TReceives> = createNodeMachine<TSends, TReceives>(),\n): Node<TSends, TReceives> => {\n  const actor = createActor(machine, {\n    input,\n  })\n\n  const eventHandlers: Map<\n    string,\n    Set<(event: TReceives['data']) => TReceives['response']>\n  > = new Map()\n\n  const unhandledMessages: Map<string, Set<ProtocolMessage<Message>>> = new Map()\n\n  const on = <TType extends TReceives['type'], TMessage extends Extract<TReceives, {type: TType}>>(\n    type: TType,\n    handler: (event: TMessage['data']) => TMessage['response'],\n    options?: {replay?: number},\n  ) => {\n    const handlers = eventHandlers.get(type) || new Set()\n\n    if (!eventHandlers.has(type)) {\n      eventHandlers.set(type, handlers)\n    }\n\n    // Register the new handler\n    handlers.add(handler)\n\n    // Process any unhandled messages for this type\n    const unhandledMessagesForType = unhandledMessages.get(type)\n    if (unhandledMessagesForType) {\n      const replayCount = options?.replay ?? 1\n      const messagesToReplay = Array.from(unhandledMessagesForType).slice(-replayCount)\n\n      // Replay messages to the new handler\n      messagesToReplay.forEach(({data}) => handler(data))\n\n      // Clear the unhandled messages for this type\n      unhandledMessages.delete(type)\n    }\n\n    return () => {\n      handlers.delete(handler)\n    }\n  }\n\n  let cachedStatus: Exclude<Status, 'disconnected'>\n  const onStatus = (\n    handler: (status: Exclude<Status, 'disconnected'>) => void,\n    filter?: Exclude<Status, 'disconnected'>,\n  ) => {\n    const {unsubscribe} = actor.on(\n      'status',\n      (event: StatusEmitEvent & {status: Exclude<Status, 'disconnected'>}) => {\n        cachedStatus = event.status\n        if (filter && event.status !== filter) {\n          return\n        }\n\n        handler(event.status)\n      },\n    )\n\n    // Call the handler immediately with the current status, if we have one\n    if (cachedStatus) {\n      handler(cachedStatus)\n    }\n\n    return unsubscribe\n  }\n\n  const post = <TType extends TSends['type'], TMessage extends Extract<TSends, {type: TType}>>(\n    type: TType,\n    data?: TMessage['data'],\n  ) => {\n    const _data = {type, data} as WithoutResponse<TMessage>\n    actor.send({type: 'post', data: _data})\n  }\n\n  const fetch = <TType extends TSends['type'], TMessage extends Extract<TSends, {type: TType}>>(\n    type: TType,\n    data?: TMessage['data'],\n    options?: {\n      responseTimeout?: number\n      signal?: AbortSignal\n      suppressWarnings?: boolean\n    },\n  ) => {\n    const {responseTimeout = FETCH_TIMEOUT_DEFAULT, signal, suppressWarnings} = options || {}\n\n    const resolvable = Promise.withResolvers<TSends['response']>()\n    const _data = {type, data} as WithoutResponse<TMessage>\n\n    actor.send({\n      type: 'post',\n      data: _data,\n      resolvable,\n      options: {responseTimeout, signal, suppressWarnings},\n    })\n    return resolvable.promise as never\n  }\n\n  actor.on('message', ({message}) => {\n    const handlers = eventHandlers.get(message.type)\n\n    if (handlers) {\n      // Execute all registered handlers for this message type\n      handlers.forEach((handler) => handler(message.data))\n      return\n    }\n\n    // Store unhandled messages for potential replay\n    const unhandledMessagesForType = unhandledMessages.get(message.type)\n    if (unhandledMessagesForType) {\n      unhandledMessagesForType.add(message)\n    } else {\n      unhandledMessages.set(message.type, new Set([message]))\n    }\n  })\n\n  const stop = () => {\n    actor.stop()\n  }\n\n  const start = () => {\n    actor.start()\n    return stop\n  }\n\n  return {\n    actor,\n    fetch,\n    machine,\n    on,\n    onStatus,\n    post,\n    start,\n    stop,\n  }\n}\n", "import {\n  createListenLogic,\n  createRequestMachine,\n  DOMAIN,\n  MSG_DISCONNECT,\n  MSG_HANDSHAKE_ACK,\n  MSG_HANDSHAKE_SYN,\n  MSG_HANDSHAKE_SYN_ACK,\n  MSG_HEARTBEAT,\n  MSG_RESPONSE,\n  type InternalMessageType,\n  type Message,\n  type ProtocolMessage,\n  type RequestMachineContext,\n} from '@sanity/comlink'\nimport type {\n  LoaderControllerMsg,\n  LoaderNodeMsg,\n  PreviewKitNodeMsg,\n  VisualEditingControllerMsg,\n  VisualEditingNodeMsg,\n} from './types'\n\ntype ComlinkMessageType =\n  | InternalMessageType\n  | (\n      | LoaderControllerMsg\n      | LoaderNodeMsg\n      | PreviewKitNodeMsg\n      | VisualEditingControllerMsg\n      | VisualEditingNodeMsg\n    )['type']\n\ntype ChannelsMessageType =\n  | 'handshake/syn'\n  | 'handshake/syn-ack'\n  | 'handshake/ack'\n  | 'channel/response'\n  | 'channel/heartbeat'\n  | 'channel/disconnect'\n  | 'overlay/focus'\n  | 'overlay/navigate'\n  | 'overlay/toggle'\n  | 'presentation/toggleOverlay'\n\nconst channelsToComlinkMap: {[key in ChannelsMessageType]: ComlinkMessageType} = {\n  'handshake/syn': MSG_HANDSHAKE_SYN,\n  'handshake/syn-ack': MSG_HANDSHAKE_SYN_ACK,\n  'handshake/ack': MSG_HANDSHAKE_ACK,\n  'channel/response': MSG_RESPONSE,\n  'channel/heartbeat': MSG_HEARTBEAT,\n  'channel/disconnect': MSG_DISCONNECT,\n  'overlay/focus': 'visual-editing/focus',\n  'overlay/navigate': 'visual-editing/navigate',\n  'overlay/toggle': 'visual-editing/toggle',\n  'presentation/toggleOverlay': 'presentation/toggle-overlay',\n}\n\nconst comlinkToChannelsMap: {[key in ComlinkMessageType]?: ChannelsMessageType} = {\n  [MSG_HANDSHAKE_SYN]: 'handshake/syn',\n  [MSG_HANDSHAKE_SYN_ACK]: 'handshake/syn-ack',\n  [MSG_HANDSHAKE_ACK]: 'handshake/ack',\n  [MSG_RESPONSE]: 'channel/response',\n  [MSG_HEARTBEAT]: 'channel/heartbeat',\n  [MSG_DISCONNECT]: 'channel/disconnect',\n  'visual-editing/focus': 'overlay/focus',\n  'visual-editing/navigate': 'overlay/navigate',\n  'visual-editing/toggle': 'overlay/toggle',\n  'presentation/toggle-overlay': 'presentation/toggleOverlay',\n}\n\ntype ChannelMsg = Omit<ProtocolMessage, 'channelId'> & {connectionId: string}\n\nconst convertToComlinkEvent = (event: MessageEvent): MessageEvent<ProtocolMessage> => {\n  const {data} = event\n\n  if (\n    data &&\n    typeof data === 'object' &&\n    'domain' in data &&\n    'type' in data &&\n    'from' in data &&\n    'to' in data\n  ) {\n    if (data.domain === 'sanity/channels') {\n      data.domain = DOMAIN\n    }\n\n    if (data.to === 'overlays') {\n      data.to = 'visual-editing'\n    }\n\n    if (data.from === 'overlays') {\n      data.from = 'visual-editing'\n    }\n\n    data.channelId = data.connectionId\n    delete data.connectionId\n\n    data.type = channelsToComlinkMap[data.type as ChannelsMessageType] ?? data.type\n  }\n\n  return event\n}\n\nconst convertToChannelsMessage = (comlinkMessage: ProtocolMessage): ChannelMsg => {\n  const {channelId, ...rest} = comlinkMessage\n  const message = {...rest, connectionId: channelId} as ChannelMsg\n\n  if (message.domain === DOMAIN) {\n    message.domain = 'sanity/channels'\n  }\n\n  if (message.to === 'visual-editing') {\n    message.to = 'overlays'\n  }\n\n  if (message.from === 'visual-editing') {\n    message.from = 'overlays'\n  }\n\n  message.type = comlinkToChannelsMap[message.type as ComlinkMessageType] ?? message.type\n\n  if (message.type === 'channel/response' && message.responseTo && !message.data) {\n    message.data = {responseTo: message.responseTo}\n  }\n\n  if (\n    message.type === 'handshake/syn' ||\n    message.type === 'handshake/syn-ack' ||\n    message.type === 'handshake/ack'\n  ) {\n    message.data = {id: message.connectionId}\n  }\n\n  return message\n}\n\nconst sendAsChannelsMessage = <S extends Message>(\n  {context}: {context: RequestMachineContext<S>},\n  params: {message: ProtocolMessage},\n): void => {\n  const {sources, targetOrigin} = context\n\n  const message = convertToChannelsMessage(params.message)\n\n  sources.forEach((source) => {\n    source.postMessage(message, {targetOrigin})\n  })\n}\n\nexport {\n  type ListenInput,\n  type Message,\n  type MessageData,\n  type MessageType,\n  MSG_RESPONSE,\n  type ProtocolMessage,\n  type RequestMachineContext,\n  type ResponseMessage,\n} from '@sanity/comlink'\n\nexport const createCompatibilityActors = <\n  T extends Message,\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n>() => ({\n  listen: createListenLogic(convertToComlinkEvent),\n  requestMachine: createRequestMachine<T>().provide({\n    actions: {\n      'send message': sendAsChannelsMessage,\n    },\n  }),\n})\n", "export function isMaybePreviewIframe(): boolean {\n  return window.self !== window.top\n}\nexport function isMaybePreviewWindow(): boolean {\n  return Boolean(window.opener)\n}\nexport function isMaybePresentation(): boolean {\n  return isMaybePreviewIframe() || isMaybePreviewWindow()\n}\n"],
  "mappings": "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",
  "names": ["paths.toString", "paths.get", "uuid", "id", "filter", "input", "connections"]
}

import {
  require_fast_deep_equal
} from "./chunk-BYBS5BTA.js";
import {
  mapChangedValue,
  useQueryParams,
  useRevalidate
} from "./chunk-SYLZZAXR.js";
import {
  applySourceDocuments,
  createCompatibilityActors,
  createConnectionMachine,
  getPublishedId
} from "./chunk-OT5SCF6H.js";
import {
  MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL
} from "./chunk-2DGZHVMN.js";
import {
  createClient,
  useClient,
  useDataset,
  useProjectId
} from "./chunk-ZOF6MRAE.js";
import "./chunk-IQQ4CL35.js";
import "./chunk-G47GRGQE.js";
import "./chunk-DG3JXI3H.js";
import {
  useEffectEvent
} from "./chunk-4EOQ4HF4.js";
import {
  require_dist
} from "./chunk-B6QUAMBD.js";
import "./chunk-ZXM66L7O.js";
import "./chunk-ZMOHUIBO.js";
import {
  require_jsx_runtime
} from "./chunk-4UOXVWM6.js";
import {
  require_react
} from "./chunk-U3RAP3IQ.js";
import {
  __toESM
} from "./chunk-5IKWDFCZ.js";

// node_modules/sanity/lib/_chunks-es/LiveQueries.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react_compiler_runtime = __toESM(require_dist(), 1);
var import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);
var import_react = __toESM(require_react(), 1);
function LoaderQueries(props) {
  const {
    liveDocument: _liveDocument,
    controller,
    perspective: activePerspective,
    onLoadersConnection,
    onDocumentsOnPage
  } = props, [comlink, setComlink] = (0, import_react.useState)(), [liveQueries, setLiveQueries] = (0, import_react.useState)({}), projectId = useProjectId(), dataset = useDataset();
  (0, import_react.useEffect)(() => {
    const interval = setInterval(() => setLiveQueries((liveQueries_0) => {
      if (Object.keys(liveQueries_0).length < 1)
        return liveQueries_0;
      const now = Date.now();
      if (!Object.values(liveQueries_0).some(
        // eslint-disable-next-line max-nested-callbacks
        (liveQuery) => liveQuery.heartbeat !== false && now > liveQuery.receivedAt + liveQuery.heartbeat
      ))
        return liveQueries_0;
      const next = {};
      for (const [key, value] of Object.entries(liveQueries_0))
        value.heartbeat !== false && now > value.receivedAt + value.heartbeat || (next[key] = value);
      return next;
    }), MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL);
    return () => clearInterval(interval);
  }, []), (0, import_react.useEffect)(() => {
    if (controller) {
      const comlink_0 = controller.createChannel({
        name: "presentation",
        connectTo: "loaders",
        heartbeat: true
      }, createConnectionMachine().provide({
        actors: createCompatibilityActors()
      }));
      return setComlink(comlink_0), comlink_0.onStatus(onLoadersConnection), comlink_0.on("loader/documents", (data) => {
        data.projectId === projectId && data.dataset === dataset && onDocumentsOnPage(
          "loaders",
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          data.perspective,
          data.documents
        );
      }), comlink_0.on("loader/query-listen", (data_0) => {
        if (data_0.projectId === projectId && data_0.dataset === dataset) {
          if (typeof data_0.heartbeat == "number" && data_0.heartbeat < MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL)
            throw new Error(`Loader query listen heartbeat interval must be at least ${MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL}ms`);
          setLiveQueries((prev) => ({
            ...prev,
            [getQueryCacheKey(data_0.query, data_0.params)]: {
              perspective: data_0.perspective,
              query: data_0.query,
              params: data_0.params,
              receivedAt: Date.now(),
              heartbeat: data_0.heartbeat ?? false
            }
          }));
        }
      }), comlink_0.start();
    }
  }, [controller, dataset, onDocumentsOnPage, onLoadersConnection, projectId]);
  const [syncTagsInUse] = (0, import_react.useState)(() => /* @__PURE__ */ new Set()), [lastLiveEventId, setLastLiveEventId] = (0, import_react.useState)(null), studioClient = useClient({
    apiVersion: "2023-10-16"
  }), clientConfig = (0, import_react.useMemo)(() => studioClient.config(), [studioClient]), client = (0, import_react.useMemo)(() => studioClient.withConfig({
    resultSourceMap: "withKeyArraySelector"
  }), [studioClient]);
  (0, import_react.useEffect)(() => {
    if (comlink) {
      const {
        projectId: projectId_0,
        dataset: dataset_0
      } = clientConfig;
      comlink.post("loader/perspective", {
        projectId: projectId_0,
        dataset: dataset_0,
        perspective: activePerspective
      });
    }
  }, [comlink, clientConfig, activePerspective]);
  const handleSyncTags = useEffectEvent((event) => {
    const flattenedSyncTags = Array.from(syncTagsInUse).flat();
    event.tags.some((tag) => flattenedSyncTags.includes(tag)) ? setLastLiveEventId(event.id) : console.log("No matching tags found", event.tags, {
      flattenedSyncTags
    });
  });
  (0, import_react.useEffect)(() => {
    const subscription = createClient(client.config()).withConfig({
      // Necessary for the live drafts to work
      apiVersion: "vX"
    }).live.events({
      includeDrafts: true,
      tag: "presentation-loader"
    }).subscribe({
      next: (event_0) => {
        event_0.type === "message" ? handleSyncTags(event_0) : event_0.type === "restart" ? setLastLiveEventId(event_0.id) : event_0.type === "reconnect" && setLastLiveEventId(null);
      },
      // eslint-disable-next-line no-console
      error: (err) => console.error("Error validating EventSource URL:", err)
    });
    return () => subscription.unsubscribe();
  }, [client, handleSyncTags]);
  const liveDocument = (0, import_react.useDeferredValue)(_liveDocument);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: Object.entries(liveQueries).map(([key_0, {
    query,
    params,
    perspective
  }]) => (0, import_jsx_runtime.jsx)(QuerySubscription, { projectId: clientConfig.projectId, dataset: clientConfig.dataset, perspective, query, params, comlink, client, liveDocument, lastLiveEventId, syncTagsInUse }, `${key_0}${perspective}`)) });
}
function QuerySubscriptionComponent(props) {
  const $ = (0, import_react_compiler_runtime.c)(14), {
    projectId,
    dataset,
    perspective,
    query,
    client,
    liveDocument,
    comlink,
    lastLiveEventId,
    syncTagsInUse
  } = props, params = useQueryParams(props.params), {
    result,
    resultSourceMap,
    syncTags: tags
  } = useQuerySubscription({
    client,
    liveDocument,
    params,
    perspective,
    query,
    lastLiveEventId
  }) || {};
  let t0;
  $[0] !== dataset || $[1] !== projectId ? (t0 = (comlink_0, perspective_0, query_0, params_0, result_0, resultSourceMap_0, tags_0) => {
    comlink_0 == null ? void 0 : comlink_0.post("loader/query-change", {
      projectId,
      dataset,
      perspective: perspective_0,
      query: query_0,
      params: params_0,
      result: result_0,
      resultSourceMap: resultSourceMap_0,
      tags: tags_0
    });
  }, $[0] = dataset, $[1] = projectId, $[2] = t0) : t0 = $[2];
  const handleQueryChange = useEffectEvent(t0);
  let t1, t2;
  return $[3] !== comlink || $[4] !== handleQueryChange || $[5] !== params || $[6] !== perspective || $[7] !== query || $[8] !== result || $[9] !== resultSourceMap || $[10] !== syncTagsInUse || $[11] !== tags ? (t1 = () => {
    if (resultSourceMap && handleQueryChange(comlink, perspective, query, params, result, resultSourceMap, tags), Array.isArray(tags))
      return syncTagsInUse.add(tags), () => {
        syncTagsInUse.delete(tags);
      };
  }, t2 = [comlink, handleQueryChange, params, perspective, query, result, resultSourceMap, syncTagsInUse, tags], $[3] = comlink, $[4] = handleQueryChange, $[5] = params, $[6] = perspective, $[7] = query, $[8] = result, $[9] = resultSourceMap, $[10] = syncTagsInUse, $[11] = tags, $[12] = t1, $[13] = t2) : (t1 = $[12], t2 = $[13]), (0, import_react.useEffect)(t1, t2), null;
}
var QuerySubscription = (0, import_react.memo)(QuerySubscriptionComponent);
QuerySubscription.displayName = "Memo(QuerySubscription)";
function useQuerySubscription(props) {
  const $ = (0, import_react_compiler_runtime.c)(25), {
    liveDocument,
    client,
    query,
    params,
    perspective,
    lastLiveEventId
  } = props, [snapshot, setSnapshot] = (0, import_react.useState)(null), [error, setError] = (0, import_react.useState)(null);
  if (error)
    throw error;
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    refreshInterval: 0
  }, $[0] = t0) : t0 = $[0];
  const [revalidate, startRefresh] = useRevalidate(t0), shouldRefetch = revalidate === "refresh" || revalidate === "inflight" || lastLiveEventId !== (snapshot == null ? void 0 : snapshot.lastLiveEventId);
  let t1, t2;
  $[1] !== client || $[2] !== lastLiveEventId || $[3] !== params || $[4] !== perspective || $[5] !== query || $[6] !== shouldRefetch || $[7] !== startRefresh ? (t1 = () => {
    if (!shouldRefetch)
      return;
    let fulfilled;
    fulfilled = false;
    let fetching;
    fetching = false;
    const controller = new AbortController(), effect = async function() {
      const {
        signal
      } = controller;
      fetching = true;
      const {
        result,
        resultSourceMap,
        syncTags
      } = await client.fetch(query, params, {
        lastLiveEventId,
        tag: "presentation-loader",
        signal,
        perspective,
        filterResponse: false,
        returnQuery: false
      });
      fetching = false, signal.aborted || (setSnapshot((prev) => ({
        result: (0, import_fast_deep_equal.default)(prev == null ? void 0 : prev.result, result) ? prev == null ? void 0 : prev.result : result,
        resultSourceMap: (0, import_fast_deep_equal.default)(prev == null ? void 0 : prev.resultSourceMap, resultSourceMap) ? prev == null ? void 0 : prev.resultSourceMap : resultSourceMap,
        syncTags: (0, import_fast_deep_equal.default)(prev == null ? void 0 : prev.syncTags, syncTags) ? prev == null ? void 0 : prev.syncTags : syncTags,
        lastLiveEventId
      })), fulfilled = true);
    }, onFinally = startRefresh();
    return effect().catch((error_0) => {
      fetching = false, error_0.name !== "AbortError" && setError(error_0);
    }).finally(onFinally), () => {
      !fulfilled && !fetching && controller.abort();
    };
  }, t2 = [client, lastLiveEventId, params, perspective, query, shouldRefetch, startRefresh], $[1] = client, $[2] = lastLiveEventId, $[3] = params, $[4] = perspective, $[5] = query, $[6] = shouldRefetch, $[7] = startRefresh, $[8] = t1, $[9] = t2) : (t1 = $[8], t2 = $[9]), (0, import_react.useEffect)(t1, t2);
  let t3;
  $[10] !== snapshot ? (t3 = snapshot ?? {}, $[10] = snapshot, $[11] = t3) : t3 = $[11];
  const {
    result: result_0,
    resultSourceMap: resultSourceMap_0,
    syncTags: syncTags_0
  } = t3;
  let t4;
  bb0: {
    if (liveDocument && resultSourceMap_0) {
      let t52;
      $[12] !== liveDocument || $[13] !== perspective || $[14] !== resultSourceMap_0 || $[15] !== result_0 ? (t52 = turboChargeResultIfSourceMap(liveDocument, result_0, perspective, resultSourceMap_0), $[12] = liveDocument, $[13] = perspective, $[14] = resultSourceMap_0, $[15] = result_0, $[16] = t52) : t52 = $[16];
      let t6;
      $[17] !== resultSourceMap_0 || $[18] !== syncTags_0 || $[19] !== t52 ? (t6 = {
        result: t52,
        resultSourceMap: resultSourceMap_0,
        syncTags: syncTags_0
      }, $[17] = resultSourceMap_0, $[18] = syncTags_0, $[19] = t52, $[20] = t6) : t6 = $[20], t4 = t6;
      break bb0;
    }
    let t5;
    $[21] !== resultSourceMap_0 || $[22] !== result_0 || $[23] !== syncTags_0 ? (t5 = {
      result: result_0,
      resultSourceMap: resultSourceMap_0,
      syncTags: syncTags_0
    }, $[21] = resultSourceMap_0, $[22] = result_0, $[23] = syncTags_0, $[24] = t5) : t5 = $[24], t4 = t5;
  }
  return t4;
}
function turboChargeResultIfSourceMap(liveDocument, result, perspective, resultSourceMap) {
  if (perspective === "raw")
    throw new Error("turboChargeResultIfSourceMap does not support raw perspective");
  return applySourceDocuments(result, resultSourceMap, (sourceDocument) => (
    // If _projectId is set, it's a cross dataset reference and we should skip it
    !sourceDocument._projectId && (liveDocument == null ? void 0 : liveDocument._id) && getPublishedId(liveDocument._id) === getPublishedId(sourceDocument._id) ? typeof liveDocument._id == "string" && typeof sourceDocument._type == "string" ? liveDocument : {
      ...liveDocument,
      _id: liveDocument._id || sourceDocument._id,
      _type: liveDocument._type || sourceDocument._type
    } : null
  ), mapChangedValue, perspective);
}
function getQueryCacheKey(query, params) {
  return `${query}-${typeof params == "string" ? params : JSON.stringify(params)}`;
}
export {
  LoaderQueries as default,
  turboChargeResultIfSourceMap
};
//# sourceMappingURL=LiveQueries-BXVECMZ3.js.map

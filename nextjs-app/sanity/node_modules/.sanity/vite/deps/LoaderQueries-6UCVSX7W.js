import {
  mapChangedValue,
  useQueryParams,
  useRevalidate
} from "./chunk-SYLZZAXR.js";
import {
  applySourceDocuments,
  createCompatibilityActors,
  createConnectionMachine,
  getPublishedId
} from "./chunk-OT5SCF6H.js";
import {
  LIVE_QUERY_CACHE_BATCH_SIZE,
  LIVE_QUERY_CACHE_SIZE,
  MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL
} from "./chunk-2DGZHVMN.js";
import {
  applyPatch,
  useClient,
  useDataset,
  useProjectId
} from "./chunk-ZOF6MRAE.js";
import "./chunk-IQQ4CL35.js";
import "./chunk-G47GRGQE.js";
import "./chunk-DG3JXI3H.js";
import "./chunk-4EOQ4HF4.js";
import {
  require_dist
} from "./chunk-B6QUAMBD.js";
import "./chunk-ZXM66L7O.js";
import "./chunk-ZMOHUIBO.js";
import {
  require_jsx_runtime
} from "./chunk-4UOXVWM6.js";
import {
  require_react
} from "./chunk-U3RAP3IQ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5IKWDFCZ.js";

// node_modules/obliterator/iterator.js
var require_iterator = __commonJS({
  "node_modules/obliterator/iterator.js"(exports, module) {
    function Iterator(next) {
      if (typeof next !== "function")
        throw new Error("obliterator/iterator: expecting a function!");
      this.next = next;
    }
    if (typeof Symbol !== "undefined")
      Iterator.prototype[Symbol.iterator] = function() {
        return this;
      };
    Iterator.of = function() {
      var args = arguments, l = args.length, i = 0;
      return new Iterator(function() {
        if (i >= l) return { done: true };
        return { done: false, value: args[i++] };
      });
    };
    Iterator.empty = function() {
      var iterator = new Iterator(function() {
        return { done: true };
      });
      return iterator;
    };
    Iterator.fromSequence = function(sequence) {
      var i = 0, l = sequence.length;
      return new Iterator(function() {
        if (i >= l) return { done: true };
        return { done: false, value: sequence[i++] };
      });
    };
    Iterator.is = function(value) {
      if (value instanceof Iterator) return true;
      return typeof value === "object" && value !== null && typeof value.next === "function";
    };
    module.exports = Iterator;
  }
});

// node_modules/obliterator/support.js
var require_support = __commonJS({
  "node_modules/obliterator/support.js"(exports) {
    exports.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== "undefined";
    exports.SYMBOL_SUPPORT = typeof Symbol !== "undefined";
  }
});

// node_modules/obliterator/foreach.js
var require_foreach = __commonJS({
  "node_modules/obliterator/foreach.js"(exports, module) {
    var support = require_support();
    var ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;
    var SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;
    module.exports = function forEach(iterable, callback) {
      var iterator, k, i, l, s;
      if (!iterable) throw new Error("obliterator/forEach: invalid iterable.");
      if (typeof callback !== "function")
        throw new Error("obliterator/forEach: expecting a callback.");
      if (Array.isArray(iterable) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable) || typeof iterable === "string" || iterable.toString() === "[object Arguments]") {
        for (i = 0, l = iterable.length; i < l; i++) callback(iterable[i], i);
        return;
      }
      if (typeof iterable.forEach === "function") {
        iterable.forEach(callback);
        return;
      }
      if (SYMBOL_SUPPORT && Symbol.iterator in iterable && typeof iterable.next !== "function") {
        iterable = iterable[Symbol.iterator]();
      }
      if (typeof iterable.next === "function") {
        iterator = iterable;
        i = 0;
        while (s = iterator.next(), s.done !== true) {
          callback(s.value, i);
          i++;
        }
        return;
      }
      for (k in iterable) {
        if (iterable.hasOwnProperty(k)) {
          callback(iterable[k], k);
        }
      }
      return;
    };
  }
});

// node_modules/mnemonist/utils/typed-arrays.js
var require_typed_arrays = __commonJS({
  "node_modules/mnemonist/utils/typed-arrays.js"(exports) {
    var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1;
    var MAX_16BIT_INTEGER = Math.pow(2, 16) - 1;
    var MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;
    var MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1;
    var MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1;
    var MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;
    exports.getPointerArray = function(size) {
      var maxIndex = size - 1;
      if (maxIndex <= MAX_8BIT_INTEGER)
        return Uint8Array;
      if (maxIndex <= MAX_16BIT_INTEGER)
        return Uint16Array;
      if (maxIndex <= MAX_32BIT_INTEGER)
        return Uint32Array;
      throw new Error("mnemonist: Pointer Array of size > 4294967295 is not supported.");
    };
    exports.getSignedPointerArray = function(size) {
      var maxIndex = size - 1;
      if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)
        return Int8Array;
      if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)
        return Int16Array;
      if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)
        return Int32Array;
      return Float64Array;
    };
    exports.getNumberType = function(value) {
      if (value === (value | 0)) {
        if (Math.sign(value) === -1) {
          if (value <= 127 && value >= -128)
            return Int8Array;
          if (value <= 32767 && value >= -32768)
            return Int16Array;
          return Int32Array;
        } else {
          if (value <= 255)
            return Uint8Array;
          if (value <= 65535)
            return Uint16Array;
          return Uint32Array;
        }
      }
      return Float64Array;
    };
    var TYPE_PRIORITY = {
      Uint8Array: 1,
      Int8Array: 2,
      Uint16Array: 3,
      Int16Array: 4,
      Uint32Array: 5,
      Int32Array: 6,
      Float32Array: 7,
      Float64Array: 8
    };
    exports.getMinimalRepresentation = function(array, getter) {
      var maxType = null, maxPriority = 0, p, t, v, i, l;
      for (i = 0, l = array.length; i < l; i++) {
        v = getter ? getter(array[i]) : array[i];
        t = exports.getNumberType(v);
        p = TYPE_PRIORITY[t.name];
        if (p > maxPriority) {
          maxPriority = p;
          maxType = t;
        }
      }
      return maxType;
    };
    exports.isTypedArray = function(value) {
      return typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(value);
    };
    exports.concat = function() {
      var length = 0, i, o, l;
      for (i = 0, l = arguments.length; i < l; i++)
        length += arguments[i].length;
      var array = new arguments[0].constructor(length);
      for (i = 0, o = 0; i < l; i++) {
        array.set(arguments[i], o);
        o += arguments[i].length;
      }
      return array;
    };
    exports.indices = function(length) {
      var PointerArray = exports.getPointerArray(length);
      var array = new PointerArray(length);
      for (var i = 0; i < length; i++)
        array[i] = i;
      return array;
    };
  }
});

// node_modules/mnemonist/utils/iterables.js
var require_iterables = __commonJS({
  "node_modules/mnemonist/utils/iterables.js"(exports) {
    var forEach = require_foreach();
    var typed = require_typed_arrays();
    function isArrayLike(target) {
      return Array.isArray(target) || typed.isTypedArray(target);
    }
    function guessLength(target) {
      if (typeof target.length === "number")
        return target.length;
      if (typeof target.size === "number")
        return target.size;
      return;
    }
    function toArray(target) {
      var l = guessLength(target);
      var array = typeof l === "number" ? new Array(l) : [];
      var i = 0;
      forEach(target, function(value) {
        array[i++] = value;
      });
      return array;
    }
    function toArrayWithIndices(target) {
      var l = guessLength(target);
      var IndexArray = typeof l === "number" ? typed.getPointerArray(l) : Array;
      var array = typeof l === "number" ? new Array(l) : [];
      var indices = typeof l === "number" ? new IndexArray(l) : [];
      var i = 0;
      forEach(target, function(value) {
        array[i] = value;
        indices[i] = i++;
      });
      return [array, indices];
    }
    exports.isArrayLike = isArrayLike;
    exports.guessLength = guessLength;
    exports.toArray = toArray;
    exports.toArrayWithIndices = toArrayWithIndices;
  }
});

// node_modules/mnemonist/lru-cache.js
var require_lru_cache = __commonJS({
  "node_modules/mnemonist/lru-cache.js"(exports, module) {
    var Iterator = require_iterator();
    var forEach = require_foreach();
    var typed = require_typed_arrays();
    var iterables = require_iterables();
    function LRUCache2(Keys, Values, capacity) {
      if (arguments.length < 2) {
        capacity = Keys;
        Keys = null;
        Values = null;
      }
      this.capacity = capacity;
      if (typeof this.capacity !== "number" || this.capacity <= 0)
        throw new Error("mnemonist/lru-cache: capacity should be positive number.");
      else if (!isFinite(this.capacity) || Math.floor(this.capacity) !== this.capacity)
        throw new Error("mnemonist/lru-cache: capacity should be a finite positive integer.");
      var PointerArray = typed.getPointerArray(capacity);
      this.forward = new PointerArray(capacity);
      this.backward = new PointerArray(capacity);
      this.K = typeof Keys === "function" ? new Keys(capacity) : new Array(capacity);
      this.V = typeof Values === "function" ? new Values(capacity) : new Array(capacity);
      this.size = 0;
      this.head = 0;
      this.tail = 0;
      this.items = {};
    }
    LRUCache2.prototype.clear = function() {
      this.size = 0;
      this.head = 0;
      this.tail = 0;
      this.items = {};
    };
    LRUCache2.prototype.splayOnTop = function(pointer) {
      var oldHead = this.head;
      if (this.head === pointer)
        return this;
      var previous = this.backward[pointer], next = this.forward[pointer];
      if (this.tail === pointer) {
        this.tail = previous;
      } else {
        this.backward[next] = previous;
      }
      this.forward[previous] = next;
      this.backward[oldHead] = pointer;
      this.head = pointer;
      this.forward[pointer] = oldHead;
      return this;
    };
    LRUCache2.prototype.set = function(key, value) {
      var pointer = this.items[key];
      if (typeof pointer !== "undefined") {
        this.splayOnTop(pointer);
        this.V[pointer] = value;
        return;
      }
      if (this.size < this.capacity) {
        pointer = this.size++;
      } else {
        pointer = this.tail;
        this.tail = this.backward[pointer];
        delete this.items[this.K[pointer]];
      }
      this.items[key] = pointer;
      this.K[pointer] = key;
      this.V[pointer] = value;
      this.forward[pointer] = this.head;
      this.backward[this.head] = pointer;
      this.head = pointer;
    };
    LRUCache2.prototype.setpop = function(key, value) {
      var oldValue = null;
      var oldKey = null;
      var pointer = this.items[key];
      if (typeof pointer !== "undefined") {
        this.splayOnTop(pointer);
        oldValue = this.V[pointer];
        this.V[pointer] = value;
        return { evicted: false, key, value: oldValue };
      }
      if (this.size < this.capacity) {
        pointer = this.size++;
      } else {
        pointer = this.tail;
        this.tail = this.backward[pointer];
        oldValue = this.V[pointer];
        oldKey = this.K[pointer];
        delete this.items[oldKey];
      }
      this.items[key] = pointer;
      this.K[pointer] = key;
      this.V[pointer] = value;
      this.forward[pointer] = this.head;
      this.backward[this.head] = pointer;
      this.head = pointer;
      if (oldKey) {
        return { evicted: true, key: oldKey, value: oldValue };
      } else {
        return null;
      }
    };
    LRUCache2.prototype.has = function(key) {
      return key in this.items;
    };
    LRUCache2.prototype.get = function(key) {
      var pointer = this.items[key];
      if (typeof pointer === "undefined")
        return;
      this.splayOnTop(pointer);
      return this.V[pointer];
    };
    LRUCache2.prototype.peek = function(key) {
      var pointer = this.items[key];
      if (typeof pointer === "undefined")
        return;
      return this.V[pointer];
    };
    LRUCache2.prototype.forEach = function(callback, scope) {
      scope = arguments.length > 1 ? scope : this;
      var i = 0, l = this.size;
      var pointer = this.head, keys = this.K, values = this.V, forward = this.forward;
      while (i < l) {
        callback.call(scope, values[pointer], keys[pointer], this);
        pointer = forward[pointer];
        i++;
      }
    };
    LRUCache2.prototype.keys = function() {
      var i = 0, l = this.size;
      var pointer = this.head, keys = this.K, forward = this.forward;
      return new Iterator(function() {
        if (i >= l)
          return { done: true };
        var key = keys[pointer];
        i++;
        if (i < l)
          pointer = forward[pointer];
        return {
          done: false,
          value: key
        };
      });
    };
    LRUCache2.prototype.values = function() {
      var i = 0, l = this.size;
      var pointer = this.head, values = this.V, forward = this.forward;
      return new Iterator(function() {
        if (i >= l)
          return { done: true };
        var value = values[pointer];
        i++;
        if (i < l)
          pointer = forward[pointer];
        return {
          done: false,
          value
        };
      });
    };
    LRUCache2.prototype.entries = function() {
      var i = 0, l = this.size;
      var pointer = this.head, keys = this.K, values = this.V, forward = this.forward;
      return new Iterator(function() {
        if (i >= l)
          return { done: true };
        var key = keys[pointer], value = values[pointer];
        i++;
        if (i < l)
          pointer = forward[pointer];
        return {
          done: false,
          value: [key, value]
        };
      });
    };
    if (typeof Symbol !== "undefined")
      LRUCache2.prototype[Symbol.iterator] = LRUCache2.prototype.entries;
    LRUCache2.prototype.inspect = function() {
      var proxy = /* @__PURE__ */ new Map();
      var iterator = this.entries(), step;
      while (step = iterator.next(), !step.done)
        proxy.set(step.value[0], step.value[1]);
      Object.defineProperty(proxy, "constructor", {
        value: LRUCache2,
        enumerable: false
      });
      return proxy;
    };
    if (typeof Symbol !== "undefined")
      LRUCache2.prototype[Symbol.for("nodejs.util.inspect.custom")] = LRUCache2.prototype.inspect;
    LRUCache2.from = function(iterable, Keys, Values, capacity) {
      if (arguments.length < 2) {
        capacity = iterables.guessLength(iterable);
        if (typeof capacity !== "number")
          throw new Error("mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.");
      } else if (arguments.length === 2) {
        capacity = Keys;
        Keys = null;
        Values = null;
      }
      var cache = new LRUCache2(Keys, Values, capacity);
      forEach(iterable, function(value, key) {
        cache.set(key, value);
      });
      return cache;
    };
    module.exports = LRUCache2;
  }
});

// node_modules/mnemonist/lru-cache-with-delete.js
var require_lru_cache_with_delete = __commonJS({
  "node_modules/mnemonist/lru-cache-with-delete.js"(exports, module) {
    var LRUCache2 = require_lru_cache();
    var forEach = require_foreach();
    var typed = require_typed_arrays();
    var iterables = require_iterables();
    function LRUCacheWithDelete(Keys, Values, capacity) {
      if (arguments.length < 2) {
        LRUCache2.call(this, Keys);
      } else {
        LRUCache2.call(this, Keys, Values, capacity);
      }
      var PointerArray = typed.getPointerArray(this.capacity);
      this.deleted = new PointerArray(this.capacity);
      this.deletedSize = 0;
    }
    for (k in LRUCache2.prototype)
      LRUCacheWithDelete.prototype[k] = LRUCache2.prototype[k];
    var k;
    if (typeof Symbol !== "undefined")
      LRUCacheWithDelete.prototype[Symbol.iterator] = LRUCache2.prototype[Symbol.iterator];
    LRUCacheWithDelete.prototype.clear = function() {
      LRUCache2.prototype.clear.call(this);
      this.deletedSize = 0;
    };
    LRUCacheWithDelete.prototype.set = function(key, value) {
      var pointer = this.items[key];
      if (typeof pointer !== "undefined") {
        this.splayOnTop(pointer);
        this.V[pointer] = value;
        return;
      }
      if (this.size < this.capacity) {
        if (this.deletedSize > 0) {
          pointer = this.deleted[--this.deletedSize];
        } else {
          pointer = this.size;
        }
        this.size++;
      } else {
        pointer = this.tail;
        this.tail = this.backward[pointer];
        delete this.items[this.K[pointer]];
      }
      this.items[key] = pointer;
      this.K[pointer] = key;
      this.V[pointer] = value;
      this.forward[pointer] = this.head;
      this.backward[this.head] = pointer;
      this.head = pointer;
    };
    LRUCacheWithDelete.prototype.setpop = function(key, value) {
      var oldValue = null;
      var oldKey = null;
      var pointer = this.items[key];
      if (typeof pointer !== "undefined") {
        this.splayOnTop(pointer);
        oldValue = this.V[pointer];
        this.V[pointer] = value;
        return { evicted: false, key, value: oldValue };
      }
      if (this.size < this.capacity) {
        if (this.deletedSize > 0) {
          pointer = this.deleted[--this.deletedSize];
        } else {
          pointer = this.size;
        }
        this.size++;
      } else {
        pointer = this.tail;
        this.tail = this.backward[pointer];
        oldValue = this.V[pointer];
        oldKey = this.K[pointer];
        delete this.items[oldKey];
      }
      this.items[key] = pointer;
      this.K[pointer] = key;
      this.V[pointer] = value;
      this.forward[pointer] = this.head;
      this.backward[this.head] = pointer;
      this.head = pointer;
      if (oldKey) {
        return { evicted: true, key: oldKey, value: oldValue };
      } else {
        return null;
      }
    };
    LRUCacheWithDelete.prototype.delete = function(key) {
      var pointer = this.items[key];
      if (typeof pointer === "undefined") {
        return false;
      }
      delete this.items[key];
      if (this.size === 1) {
        this.size = 0;
        this.head = 0;
        this.tail = 0;
        this.deletedSize = 0;
        return true;
      }
      var previous = this.backward[pointer], next = this.forward[pointer];
      if (this.head === pointer) {
        this.head = next;
      }
      if (this.tail === pointer) {
        this.tail = previous;
      }
      this.forward[previous] = next;
      this.backward[next] = previous;
      this.size--;
      this.deleted[this.deletedSize++] = pointer;
      return true;
    };
    LRUCacheWithDelete.prototype.remove = function(key, missing = void 0) {
      var pointer = this.items[key];
      if (typeof pointer === "undefined") {
        return missing;
      }
      var dead = this.V[pointer];
      delete this.items[key];
      if (this.size === 1) {
        this.size = 0;
        this.head = 0;
        this.tail = 0;
        this.deletedSize = 0;
        return dead;
      }
      var previous = this.backward[pointer], next = this.forward[pointer];
      if (this.head === pointer) {
        this.head = next;
      }
      if (this.tail === pointer) {
        this.tail = previous;
      }
      this.forward[previous] = next;
      this.backward[next] = previous;
      this.size--;
      this.deleted[this.deletedSize++] = pointer;
      return dead;
    };
    LRUCacheWithDelete.from = function(iterable, Keys, Values, capacity) {
      if (arguments.length < 2) {
        capacity = iterables.guessLength(iterable);
        if (typeof capacity !== "number")
          throw new Error("mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.");
      } else if (arguments.length === 2) {
        capacity = Keys;
        Keys = null;
        Values = null;
      }
      var cache = new LRUCacheWithDelete(Keys, Values, capacity);
      forEach(iterable, function(value, key) {
        cache.set(key, value);
      });
      return cache;
    };
    module.exports = LRUCacheWithDelete;
  }
});

// node_modules/sanity/lib/_chunks-es/LoaderQueries.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react_compiler_runtime = __toESM(require_dist(), 1);
var import_lru_cache_with_delete = __toESM(require_lru_cache_with_delete(), 1);
var import_react = __toESM(require_react(), 1);
function LoaderQueries(props) {
  const {
    liveDocument,
    controller,
    perspective: activePerspective,
    documentsOnPage,
    onLoadersConnection,
    onDocumentsOnPage
  } = props, [comlink, setComlink] = (0, import_react.useState)(), [liveQueries, setLiveQueries] = (0, import_react.useState)({}), projectId = useProjectId(), dataset = useDataset();
  (0, import_react.useEffect)(() => {
    const interval = setInterval(() => (
      // eslint-disable-next-line @typescript-eslint/no-shadow
      setLiveQueries((liveQueries_0) => {
        if (Object.keys(liveQueries_0).length < 1)
          return liveQueries_0;
        const now = Date.now();
        if (!Object.values(liveQueries_0).some(
          // eslint-disable-next-line max-nested-callbacks
          (liveQuery) => liveQuery.heartbeat !== false && now > liveQuery.receivedAt + liveQuery.heartbeat
        ))
          return liveQueries_0;
        const next = {};
        for (const [key, value] of Object.entries(liveQueries_0))
          value.heartbeat !== false && now > value.receivedAt + value.heartbeat || (next[key] = value);
        return next;
      })
    ), MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL);
    return () => clearInterval(interval);
  }, []), (0, import_react.useEffect)(() => {
    if (controller) {
      const comlink_0 = controller.createChannel({
        name: "presentation",
        connectTo: "loaders",
        heartbeat: true
      }, createConnectionMachine().provide({
        actors: createCompatibilityActors()
      }));
      return setComlink(comlink_0), comlink_0.onStatus(onLoadersConnection), comlink_0.on("loader/documents", (data) => {
        data.projectId === projectId && data.dataset === dataset && onDocumentsOnPage(
          "loaders",
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          data.perspective,
          data.documents
        );
      }), comlink_0.on("loader/query-listen", (data_0) => {
        if (data_0.projectId === projectId && data_0.dataset === dataset) {
          if (typeof data_0.heartbeat == "number" && data_0.heartbeat < MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL)
            throw new Error(`Loader query listen heartbeat interval must be at least ${MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL}ms`);
          setLiveQueries((prev) => ({
            ...prev,
            [getQueryCacheKey(data_0.query, data_0.params)]: {
              perspective: data_0.perspective,
              query: data_0.query,
              params: data_0.params,
              receivedAt: Date.now(),
              heartbeat: data_0.heartbeat ?? false
            }
          }));
        }
      }), comlink_0.start();
    }
  }, [controller, dataset, onDocumentsOnPage, onLoadersConnection, projectId]);
  const [cache] = (0, import_react.useState)(() => new import_lru_cache_with_delete.default(LIVE_QUERY_CACHE_SIZE)), studioClient = useClient({
    apiVersion: "2023-10-16"
  }), clientConfig = (0, import_react.useMemo)(() => studioClient.config(), [studioClient]), client = (0, import_react.useMemo)(() => studioClient.withConfig({
    resultSourceMap: "withKeyArraySelector"
  }), [studioClient]);
  (0, import_react.useEffect)(() => {
    if (comlink) {
      const {
        projectId: projectId_0,
        dataset: dataset_0
      } = clientConfig;
      comlink.post("loader/perspective", {
        projectId: projectId_0,
        dataset: dataset_0,
        perspective: activePerspective
      });
    }
  }, [comlink, clientConfig, activePerspective]);
  const turboIds = (0, import_react.useMemo)(() => {
    const documentsActuallyInUse = documentsOnPage.map(({
      _id
    }) => _id), ids = [...new Set(documentsActuallyInUse)], max = cache.capacity;
    return ids.length >= max && (ids.length = max), ids;
  }, [cache.capacity, documentsOnPage]), [documentsCacheLastUpdated, setDocumentsCacheLastUpdated] = (0, import_react.useState)(0);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsx)(Turbo, { cache, client, turboIds, setDocumentsCacheLastUpdated }),
    Object.entries(liveQueries).map(([key_0, {
      query,
      params,
      perspective
    }]) => (0, import_jsx_runtime.jsx)(QuerySubscription, { cache, projectId: clientConfig.projectId, dataset: clientConfig.dataset, perspective, query, params, comlink, client, refreshInterval: activePerspective ? 2e3 : 0, liveDocument, documentsCacheLastUpdated }, `${key_0}${perspective}`))
  ] });
}
var Turbo = (0, import_react.memo)(function(props) {
  const {
    cache,
    client,
    turboIds,
    setDocumentsCacheLastUpdated
  } = props, [batch, setBatch] = (0, import_react.useState)([]);
  return (0, import_react.useEffect)(() => {
    const batchSet = new Set(batch.flat()), nextBatch = /* @__PURE__ */ new Set();
    for (const turboId of turboIds)
      !batchSet.has(turboId) && !cache.has(turboId) && nextBatch.add(turboId);
    const nextBatchSlice = [...nextBatch].slice(0, LIVE_QUERY_CACHE_BATCH_SIZE);
    if (nextBatchSlice.length === 0) return;
    const raf = requestAnimationFrame(() => (
      // eslint-disable-next-line max-nested-callbacks
      setBatch((prevBatch) => [...prevBatch.slice(-100), nextBatchSlice])
    ));
    return () => cancelAnimationFrame(raf);
  }, [batch, cache, turboIds]), (0, import_react.useEffect)(() => {
    const subscription = client.listen("*", {}, {
      events: ["mutation"],
      effectFormat: "mendoza",
      includePreviousRevision: false,
      includeResult: false,
      tag: "presentation-loader"
    }).subscribe((update) => {
      var _a, _b;
      if (update.type === "mutation" && update.transition === "disappear" && cache.delete(update.documentId) && setDocumentsCacheLastUpdated(Date.now()), update.type !== "mutation" || !((_b = (_a = update.effects) == null ? void 0 : _a.apply) == null ? void 0 : _b.length)) return;
      const cachedDocument = cache.peek(update.documentId);
      if (cachedDocument) {
        const patchDoc = {
          ...cachedDocument
        };
        delete patchDoc._rev;
        const patchedDocument = applyPatch(patchDoc, update.effects.apply);
        cache.set(update.documentId, patchedDocument), setDocumentsCacheLastUpdated(Date.now());
      }
    });
    return () => subscription.unsubscribe();
  }, [cache, client, setDocumentsCacheLastUpdated]), (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: batch.map((ids) => (0, import_jsx_runtime.jsx)(GetDocuments, { cache, client, ids, setDocumentsCacheLastUpdated }, JSON.stringify(ids))) });
});
var GetDocuments = (0, import_react.memo)(function(props) {
  const {
    client,
    cache,
    ids,
    setDocumentsCacheLastUpdated
  } = props;
  return (0, import_react.useEffect)(() => {
    const missingIds = ids.filter((id) => !cache.has(id));
    missingIds.length !== 0 && client.getDocuments(missingIds).then((documents) => {
      for (const doc of documents)
        doc && (doc == null ? void 0 : doc._id) && (cache.set(doc._id, doc), setDocumentsCacheLastUpdated(Date.now()));
    }, console.error);
  }, [cache, client, ids, setDocumentsCacheLastUpdated]), null;
});
GetDocuments.displayName = "GetDocuments";
function QuerySubscription(props) {
  const $ = (0, import_react_compiler_runtime.c)(20), {
    cache,
    projectId,
    dataset,
    perspective,
    query,
    client,
    refreshInterval,
    liveDocument,
    comlink,
    documentsCacheLastUpdated
  } = props, params = useQueryParams(props.params);
  let t0;
  $[0] !== cache || $[1] !== client || $[2] !== documentsCacheLastUpdated || $[3] !== liveDocument || $[4] !== params || $[5] !== perspective || $[6] !== query || $[7] !== refreshInterval ? (t0 = {
    cache,
    client,
    liveDocument,
    params,
    perspective,
    query,
    refreshInterval,
    documentsCacheLastUpdated
  }, $[0] = cache, $[1] = client, $[2] = documentsCacheLastUpdated, $[3] = liveDocument, $[4] = params, $[5] = perspective, $[6] = query, $[7] = refreshInterval, $[8] = t0) : t0 = $[8];
  const data = useQuerySubscription(t0), result = data == null ? void 0 : data.result, resultSourceMap = data == null ? void 0 : data.resultSourceMap, tags = data == null ? void 0 : data.tags;
  let t1, t2;
  return $[9] !== comlink || $[10] !== dataset || $[11] !== params || $[12] !== perspective || $[13] !== projectId || $[14] !== query || $[15] !== result || $[16] !== resultSourceMap || $[17] !== tags ? (t1 = () => {
    resultSourceMap && (comlink == null ? void 0 : comlink.post("loader/query-change", {
      projectId,
      dataset,
      perspective,
      query,
      params,
      result,
      resultSourceMap,
      tags
    }));
  }, t2 = [comlink, dataset, params, perspective, projectId, query, result, resultSourceMap, tags], $[9] = comlink, $[10] = dataset, $[11] = params, $[12] = perspective, $[13] = projectId, $[14] = query, $[15] = result, $[16] = resultSourceMap, $[17] = tags, $[18] = t1, $[19] = t2) : (t1 = $[18], t2 = $[19]), (0, import_react.useEffect)(t1, t2), null;
}
function useQuerySubscription(props) {
  const {
    cache,
    liveDocument,
    client,
    refreshInterval,
    query,
    params,
    perspective,
    documentsCacheLastUpdated
  } = props, [snapshot, setSnapshot] = (0, import_react.useState)(null), {
    projectId: projectId_0,
    dataset: dataset_0
  } = (0, import_react.useMemo)(() => {
    const {
      projectId,
      dataset
    } = client.config();
    return {
      projectId,
      dataset
    };
  }, [client]), [error, setError] = (0, import_react.useState)(null);
  if (error) throw error;
  const [revalidate, startRefresh] = useRevalidate({
    refreshInterval
  }), shouldRefetch = revalidate === "refresh" || revalidate === "inflight";
  return (0, import_react.useEffect)(() => {
    if (!shouldRefetch)
      return;
    let fulfilled = false, fetching = false;
    const controller = new AbortController();
    async function effect() {
      const {
        signal
      } = controller;
      fetching = true;
      const {
        result,
        resultSourceMap,
        syncTags
      } = await client.fetch(query, params, {
        tag: "presentation-loader",
        signal,
        perspective,
        filterResponse: false
      });
      fetching = false, signal.aborted || (setSnapshot({
        result,
        resultSourceMap,
        tags: syncTags
      }), fulfilled = true);
    }
    const onFinally = startRefresh();
    return effect().catch((error_0) => {
      fetching = false, error_0.name !== "AbortError" && setError(error_0);
    }).finally(onFinally), () => {
      !fulfilled && !fetching && controller.abort();
    };
  }, [client, dataset_0, liveDocument, params, perspective, projectId_0, query, shouldRefetch, startRefresh]), (0, import_react.useMemo)(() => documentsCacheLastUpdated && (snapshot == null ? void 0 : snapshot.resultSourceMap) ? {
    result: turboChargeResultIfSourceMap(cache, liveDocument, snapshot.result, perspective, snapshot.resultSourceMap),
    resultSourceMap: snapshot.resultSourceMap
  } : snapshot, [cache, documentsCacheLastUpdated, liveDocument, perspective, snapshot]);
}
var warnedAboutCrossDatasetReference = false;
function turboChargeResultIfSourceMap(cache, liveDocument, result, perspective, resultSourceMap) {
  if (perspective === "raw")
    throw new Error("turboChargeResultIfSourceMap does not support raw perspective");
  return applySourceDocuments(result, resultSourceMap, (sourceDocument) => {
    if (sourceDocument._projectId) {
      warnedAboutCrossDatasetReference || (console.warn("Cross dataset references are not supported yet, ignoring source document", sourceDocument), warnedAboutCrossDatasetReference = true);
      return;
    }
    return (liveDocument == null ? void 0 : liveDocument._id) && getPublishedId(liveDocument._id) === getPublishedId(sourceDocument._id) ? typeof liveDocument._id == "string" && typeof sourceDocument._type == "string" ? liveDocument : {
      ...liveDocument,
      _id: liveDocument._id || sourceDocument._id,
      _type: liveDocument._type || sourceDocument._type
    } : cache.get(sourceDocument._id);
  }, mapChangedValue, perspective);
}
function getQueryCacheKey(query, params) {
  return `${query}-${typeof params == "string" ? params : JSON.stringify(params)}`;
}
export {
  LoaderQueries as default,
  turboChargeResultIfSourceMap
};
//# sourceMappingURL=LoaderQueries-6UCVSX7W.js.map
